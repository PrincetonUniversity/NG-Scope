/**
 * Copyright 2013-2021 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/s1ap.h"
#include <sstream>

using namespace asn1;
using namespace asn1::s1ap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// Criticality ::= ENUMERATED
const char* crit_opts::to_string() const
{
  static const char* options[] = {"reject", "ignore", "notify"};
  return convert_enum_idx(options, 3, value, "crit_e");
}

// Presence ::= ENUMERATED
const char* presence_opts::to_string() const
{
  static const char* options[] = {"optional", "conditional", "mandatory"};
  return convert_enum_idx(options, 3, value, "presence_e");
}

// PrivateIE-ID ::= CHOICE
void private_ie_id_c::set(types::options e)
{
  type_ = e;
}
uint32_t& private_ie_id_c::set_local()
{
  set(types::local);
  return c;
}
void private_ie_id_c::set_global()
{
  set(types::global);
}
void private_ie_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::local:
      j.write_int("local", c);
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
  }
  j.end_obj();
}
SRSASN_CODE private_ie_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::local:
      HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::local:
      HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* private_ie_id_c::types_opts::to_string() const
{
  static const char* options[] = {"local", "global"};
  return convert_enum_idx(options, 2, value, "private_ie_id_c::types");
}

// PrivateIE-Field{S1AP-PRIVATE-IES : IEsSetParam} ::= SEQUENCE{{S1AP-PRIVATE-IES}}
template <class ies_set_paramT_>
SRSASN_CODE private_ie_field_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(id.pack(bref));
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE private_ie_field_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(id.unpack(bref));
  HANDLE_CODE(crit.unpack(bref));
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void private_ie_field_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("id");
  id.to_json(j);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

// ProtocolExtensionField{S1AP-PROTOCOL-EXTENSION : ExtensionSetParam} ::= SEQUENCE{{S1AP-PROTOCOL-EXTENSION}}
template <class ext_set_paramT_>
SRSASN_CODE protocol_ext_field_s<ext_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  warn_assert(crit != ext_set_paramT_::get_crit(id), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(ext_value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ext_set_paramT_>
SRSASN_CODE protocol_ext_field_s<ext_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  ext_value = ext_set_paramT_::get_ext(id);
  HANDLE_CODE(ext_value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ext_set_paramT_>
void protocol_ext_field_s<ext_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}
template <class ext_set_paramT_>
bool protocol_ext_field_s<ext_set_paramT_>::load_info_obj(const uint32_t& id_)
{
  if (not ext_set_paramT_::is_id_valid(id_)) {
    return false;
  }
  id        = id_;
  crit      = ext_set_paramT_::get_crit(id);
  ext_value = ext_set_paramT_::get_ext(id);
  return ext_value.type().value != ext_set_paramT_::ext_c::types_opts::nulltype;
}

// ProtocolIE-Field{S1AP-PROTOCOL-IES : IEsSetParam} ::= SEQUENCE{{S1AP-PROTOCOL-IES}}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  warn_assert(crit != ies_set_paramT_::get_crit(id), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = ies_set_paramT_::get_value(id);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void protocol_ie_field_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}
template <class ies_set_paramT_>
bool protocol_ie_field_s<ies_set_paramT_>::load_info_obj(const uint32_t& id_)
{
  if (not ies_set_paramT_::is_id_valid(id_)) {
    return false;
  }
  id    = id_;
  crit  = ies_set_paramT_::get_crit(id);
  value = ies_set_paramT_::get_value(id);
  return value.type().value != ies_set_paramT_::value_c::types_opts::nulltype;
}

// ProtocolIE-SingleContainer{S1AP-PROTOCOL-IES : IEsSetParam} ::= SEQUENCE{{S1AP-PROTOCOL-IES}}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_single_container_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  warn_assert(crit != ies_set_paramT_::get_crit(id), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_single_container_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = ies_set_paramT_::get_value(id);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void protocol_ie_single_container_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}
template <class ies_set_paramT_>
bool protocol_ie_single_container_s<ies_set_paramT_>::load_info_obj(const uint32_t& id_)
{
  if (not ies_set_paramT_::is_id_valid(id_)) {
    return false;
  }
  id    = id_;
  crit  = ies_set_paramT_::get_crit(id);
  value = ies_set_paramT_::get_value(id);
  return value.type().value != ies_set_paramT_::value_c::types_opts::nulltype;
}
template bool protocol_ie_single_container_s<erab_admitted_item_ies_o>::load_info_obj(const uint32_t& id_);

// ProtocolIE-FieldPair{S1AP-PROTOCOL-IES-PAIR : IEsSetParam} ::= SEQUENCE{{S1AP-PROTOCOL-IES-PAIR}}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_pair_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  warn_assert(first_crit != ies_set_paramT_::get_first_crit(id), __func__, __LINE__);
  HANDLE_CODE(first_crit.pack(bref));
  HANDLE_CODE(first_value.pack(bref));
  warn_assert(second_crit != ies_set_paramT_::get_second_crit(id), __func__, __LINE__);
  HANDLE_CODE(second_crit.pack(bref));
  HANDLE_CODE(second_value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_pair_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(first_crit.unpack(bref));
  first_value = ies_set_paramT_::get_first_value(id);
  HANDLE_CODE(first_value.unpack(bref));
  HANDLE_CODE(second_crit.unpack(bref));
  second_value = ies_set_paramT_::get_second_value(id);
  HANDLE_CODE(second_value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void protocol_ie_field_pair_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("firstCriticality", first_crit.to_string());
  j.write_str("secondCriticality", second_crit.to_string());
  j.end_obj();
}
template <class ies_set_paramT_>
bool protocol_ie_field_pair_s<ies_set_paramT_>::load_info_obj(const uint32_t& id_)
{
  if (not ies_set_paramT_::is_id_valid(id_)) {
    return false;
  }
  id           = id_;
  first_crit   = ies_set_paramT_::get_first_crit(id);
  first_value  = ies_set_paramT_::get_first_value(id);
  second_crit  = ies_set_paramT_::get_second_crit(id);
  second_value = ies_set_paramT_::get_second_value(id);
  return first_value.type().value != ies_set_paramT_::first_value_c::types_opts::nulltype and
         second_value.type().value != ies_set_paramT_::second_value_c::types_opts::nulltype;
}

// ActivatedCellsList-Item ::= SEQUENCE
SRSASN_CODE activ_cells_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(cell_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE activ_cells_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(cell_id.unpack(bref));

  return SRSASN_SUCCESS;
}
void activ_cells_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cell-ID", cell_id.to_string());
  j.end_obj();
}

uint32_t s1ap_protocol_ext_empty_o::idx_to_id(uint32_t idx)
{
  asn1::log_error("object set is empty\n");
  return 0;
}
bool s1ap_protocol_ext_empty_o::is_id_valid(const uint32_t& id)
{
  asn1::log_error("object set is empty\n");
  return false;
}
crit_e s1ap_protocol_ext_empty_o::get_crit(const uint32_t& id)
{
  return {};
}
s1ap_protocol_ext_empty_o::ext_c s1ap_protocol_ext_empty_o::get_ext(const uint32_t& id)
{
  return {};
}
presence_e s1ap_protocol_ext_empty_o::get_presence(const uint32_t& id)
{
  return {};
}

// Extension ::= OPEN TYPE
void s1ap_protocol_ext_empty_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}
SRSASN_CODE s1ap_protocol_ext_empty_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_protocol_ext_empty_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}

const char* s1ap_protocol_ext_empty_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {};
  return convert_enum_idx(options, 0, value, "s1ap_protocol_ext_empty_o::ext_c::types");
}

template <class extT_>
protocol_ext_container_item_s<extT_>::protocol_ext_container_item_s(uint32_t id_, crit_e crit_) : id(id_), crit(crit_)

{}
template <class extT_>
SRSASN_CODE protocol_ext_container_item_s<extT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.pack(bref));
  {
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ext.pack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class extT_>
SRSASN_CODE protocol_ext_container_item_s<extT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  {
    varlength_field_unpack_guard varlen_scope(bref, true);
    HANDLE_CODE(ext.unpack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class extT_>
void protocol_ext_container_item_s<extT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

SRSASN_CODE protocol_ext_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE protocol_ext_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void protocol_ext_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// GUMMEI ::= SEQUENCE
SRSASN_CODE gummei_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(mme_group_id.pack(bref));
  HANDLE_CODE(mme_code.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gummei_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(mme_group_id.unpack(bref));
  HANDLE_CODE(mme_code.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gummei_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_str("mME-Group-ID", mme_group_id.to_string());
  j.write_str("mME-Code", mme_code.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Additional-GUTI ::= SEQUENCE
SRSASN_CODE add_guti_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gummei.pack(bref));
  HANDLE_CODE(m_tmsi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_guti_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gummei.unpack(bref));
  HANDLE_CODE(m_tmsi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_guti_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gUMMEI");
  gummei.to_json(j);
  j.write_str("m-TMSI", m_tmsi.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Pre-emptionCapability ::= ENUMERATED
const char* pre_emption_cap_opts::to_string() const
{
  static const char* options[] = {"shall-not-trigger-pre-emption", "may-trigger-pre-emption"};
  return convert_enum_idx(options, 2, value, "pre_emption_cap_e");
}

// Pre-emptionVulnerability ::= ENUMERATED
const char* pre_emption_vulnerability_opts::to_string() const
{
  static const char* options[] = {"not-pre-emptable", "pre-emptable"};
  return convert_enum_idx(options, 2, value, "pre_emption_vulnerability_e");
}

// AllocationAndRetentionPriority ::= SEQUENCE
SRSASN_CODE alloc_and_retention_prio_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alloc_and_retention_prio_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alloc_and_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevel", prio_level);
  j.write_str("pre-emptionCapability", pre_emption_cap.to_string());
  j.write_str("pre-emptionVulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-CGI ::= SEQUENCE
SRSASN_CODE eutran_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("cell-ID", cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAI ::= SEQUENCE
SRSASN_CODE tai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedMDT ::= SEQUENCE
SRSASN_CODE cell_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT");
  for (const auto& e1 : cell_id_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedMDT ::= SEQUENCE
SRSASN_CODE ta_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, talistfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(talistfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforMDT");
  for (const auto& e1 : talistfor_mdt) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedMDT ::= SEQUENCE
SRSASN_CODE tai_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforMDT");
  for (const auto& e1 : tai_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT ::= CHOICE
void area_scope_of_mdt_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_s>();
      break;
    case types::tabased:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_s>();
      break;
    case types::tabased:
      c.init<ta_based_mdt_s>();
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
  }
}
area_scope_of_mdt_c::area_scope_of_mdt_c(const area_scope_of_mdt_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_s>());
      break;
    case types::tabased:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
  }
}
area_scope_of_mdt_c& area_scope_of_mdt_c::operator=(const area_scope_of_mdt_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_s>());
      break;
    case types::tabased:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
  }

  return *this;
}
cell_based_mdt_s& area_scope_of_mdt_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_s>();
}
ta_based_mdt_s& area_scope_of_mdt_c::set_tabased()
{
  set(types::tabased);
  return c.get<ta_based_mdt_s>();
}
void area_scope_of_mdt_c::set_plmn_wide()
{
  set(types::plmn_wide);
}
tai_based_mdt_s& area_scope_of_mdt_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
void area_scope_of_mdt_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_s>().to_json(j);
      break;
    case types::tabased:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_s>().pack(bref));
      break;
    case types::tabased:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_s>().unpack(bref));
      break;
    case types::tabased:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_c::types_opts::to_string() const
{
  static const char* options[] = {"cellBased", "tABased", "pLMNWide", "tAIBased"};
  return convert_enum_idx(options, 4, value, "area_scope_of_mdt_c::types");
}

// CellBasedQMC ::= SEQUENCE
SRSASN_CODE cell_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_qmc, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_qmc, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforQMC");
  for (const auto& e1 : cell_id_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNAreaBasedQMC ::= SEQUENCE
SRSASN_CODE plmn_area_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, plmn_listfor_qmc, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_area_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(plmn_listfor_qmc, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_area_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("plmnListforQMC");
  for (const auto& e1 : plmn_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedQMC ::= SEQUENCE
SRSASN_CODE ta_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, talistfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(talistfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforQMC");
  for (const auto& e1 : talistfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedQMC ::= SEQUENCE
SRSASN_CODE tai_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforQMC");
  for (const auto& e1 : tai_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfQMC ::= CHOICE
void area_scope_of_qmc_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_qmc_s>();
      break;
    case types::tabased:
      c.destroy<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.destroy<plmn_area_based_qmc_s>();
      break;
    default:
      break;
  }
}
void area_scope_of_qmc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_qmc_s>();
      break;
    case types::tabased:
      c.init<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.init<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.init<plmn_area_based_qmc_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c::area_scope_of_qmc_c(const area_scope_of_qmc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_qmc_s>());
      break;
    case types::tabased:
      c.init(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.init(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c& area_scope_of_qmc_c::operator=(const area_scope_of_qmc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_qmc_s>());
      break;
    case types::tabased:
      c.set(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.set(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }

  return *this;
}
cell_based_qmc_s& area_scope_of_qmc_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_qmc_s>();
}
ta_based_qmc_s& area_scope_of_qmc_c::set_tabased()
{
  set(types::tabased);
  return c.get<ta_based_qmc_s>();
}
tai_based_qmc_s& area_scope_of_qmc_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_qmc_s>();
}
plmn_area_based_qmc_s& area_scope_of_qmc_c::set_plmn_area_based()
{
  set(types::plmn_area_based);
  return c.get<plmn_area_based_qmc_s>();
}
void area_scope_of_qmc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_qmc_s>().to_json(j);
      break;
    case types::tabased:
      j.write_fieldname("tABased");
      c.get<ta_based_qmc_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_qmc_s>().to_json(j);
      break;
    case types::plmn_area_based:
      j.write_fieldname("pLMNAreaBased");
      c.get<plmn_area_based_qmc_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_qmc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().pack(bref));
      break;
    case types::tabased:
      HANDLE_CODE(c.get<ta_based_qmc_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().pack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_qmc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().unpack(bref));
      break;
    case types::tabased:
      HANDLE_CODE(c.get<ta_based_qmc_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().unpack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_qmc_c::types_opts::to_string() const
{
  static const char* options[] = {"cellBased", "tABased", "tAIBased", "pLMNAreaBased"};
  return convert_enum_idx(options, 4, value, "area_scope_of_qmc_c::types");
}

// CellIdentifierAndCELevelForCECapableUEs ::= SEQUENCE
SRSASN_CODE cell_id_and_ce_level_for_ce_capable_ues_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.pack(bref));
  HANDLE_CODE(celevel.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_and_ce_level_for_ce_capable_ues_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.unpack(bref));
  HANDLE_CODE(celevel.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_and_ce_level_for_ce_capable_ues_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-Cell-ID");
  global_cell_id.to_json(j);
  j.write_str("cELevel", celevel.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForCECapableUEs ::= SEQUENCE
SRSASN_CODE assist_data_for_ce_capable_ues_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_id_and_ce_level_for_ce_capable_ues.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_ce_capable_ues_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id_and_ce_level_for_ce_capable_ues.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_ce_capable_ues_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cellIdentifierAndCELevelForCECapableUEs");
  cell_id_and_ce_level_for_ce_capable_ues.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedCellItem ::= SEQUENCE
SRSASN_CODE recommended_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRAN-CGI");
  eutran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedCellItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t recommended_cell_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {214};
  return map_enum_number(options, 1, idx, "id");
}
bool recommended_cell_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 214 == id;
}
crit_e recommended_cell_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 214) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
recommended_cell_item_ies_o::value_c recommended_cell_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 214) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e recommended_cell_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 214) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void recommended_cell_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RecommendedCellItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE recommended_cell_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cell_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* recommended_cell_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"RecommendedCellItem"};
  return convert_enum_idx(options, 1, value, "recommended_cell_item_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<recommended_cell_item_ies_o>;

// NextPagingAreaScope ::= ENUMERATED
const char* next_paging_area_scope_opts::to_string() const
{
  static const char* options[] = {"same", "changed"};
  return convert_enum_idx(options, 2, value, "next_paging_area_scope_e");
}

// RecommendedCellsForPaging ::= SEQUENCE
SRSASN_CODE recommended_cells_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_cell_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cells_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_cell_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cells_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedCellList");
  for (const auto& e1 : recommended_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForRecommendedCells ::= SEQUENCE
SRSASN_CODE assist_data_for_recommended_cells_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_recommended_cells_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_recommended_cells_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingAttemptInformation ::= SEQUENCE
SRSASN_CODE paging_attempt_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, paging_attempt_count, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, intended_nof_paging_attempts, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_attempt_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(paging_attempt_count, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(intended_nof_paging_attempts, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_attempt_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pagingAttemptCount", paging_attempt_count);
  j.write_int("intendedNumberOfPagingAttempts", intended_nof_paging_attempts);
  if (next_paging_area_scope_present) {
    j.write_str("nextPagingAreaScope", next_paging_area_scope.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForPaging ::= SEQUENCE
SRSASN_CODE assist_data_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.pack(assist_data_for_ce_capable_ues_present, 1));
  HANDLE_CODE(bref.pack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.pack(bref));
  }
  if (assist_data_for_ce_capable_ues_present) {
    HANDLE_CODE(assist_data_for_ce_capable_ues.pack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.unpack(assist_data_for_ce_capable_ues_present, 1));
  HANDLE_CODE(bref.unpack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.unpack(bref));
  }
  if (assist_data_for_ce_capable_ues_present) {
    HANDLE_CODE(assist_data_for_ce_capable_ues.unpack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (assist_data_for_recommended_cells_present) {
    j.write_fieldname("assistanceDataForRecommendedCells");
    assist_data_for_recommended_cells.to_json(j);
  }
  if (assist_data_for_ce_capable_ues_present) {
    j.write_fieldname("assistanceDataForCECapableUEs");
    assist_data_for_ce_capable_ues.to_json(j);
  }
  if (paging_attempt_info_present) {
    j.write_fieldname("pagingAttemptInformation");
    paging_attempt_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// COUNTValueExtended ::= SEQUENCE
SRSASN_CODE count_value_extended_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn_extended, (uint16_t)0u, (uint16_t)32767u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_modified, (uint32_t)0u, (uint32_t)131071u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_value_extended_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn_extended, bref, (uint16_t)0u, (uint16_t)32767u, false, true));
  HANDLE_CODE(unpack_integer(hfn_modified, bref, (uint32_t)0u, (uint32_t)131071u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_value_extended_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SNExtended", pdcp_sn_extended);
  j.write_int("hFNModified", hfn_modified);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// COUNTvaluePDCP-SNlength18 ::= SEQUENCE
SRSASN_CODE coun_tvalue_pdcp_snlen18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_snlen18, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(pack_integer(bref, hfnfor_pdcp_snlen18, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE coun_tvalue_pdcp_snlen18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_snlen18, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(unpack_integer(hfnfor_pdcp_snlen18, bref, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void coun_tvalue_pdcp_snlen18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SNlength18", pdcp_snlen18);
  j.write_int("hFNforPDCP-SNlength18", hfnfor_pdcp_snlen18);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Bearers-SubjectToStatusTransfer-ItemExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t bearers_subject_to_status_transfer_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {179, 180, 181, 217, 218, 219};
  return map_enum_number(options, 6, idx, "id");
}
bool bearers_subject_to_status_transfer_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {179, 180, 181, 217, 218, 219};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e bearers_subject_to_status_transfer_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 179:
      return crit_e::ignore;
    case 180:
      return crit_e::ignore;
    case 181:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c
bearers_subject_to_status_transfer_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 179:
      ret.set(ext_c::types::ulcount_value_extended);
      break;
    case 180:
      ret.set(ext_c::types::dlcount_value_extended);
      break;
    case 181:
      ret.set(ext_c::types::receive_status_of_ulpdcpsdus_extended);
      break;
    case 217:
      ret.set(ext_c::types::ulcount_value_pdcp_snlen18);
      break;
    case 218:
      ret.set(ext_c::types::dlcount_value_pdcp_snlen18);
      break;
    case 219:
      ret.set(ext_c::types::receive_status_of_ulpdcpsdus_pdcp_snlen18);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e bearers_subject_to_status_transfer_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 179:
      return presence_e::optional;
    case 180:
      return presence_e::optional;
    case 181:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ulcount_value_extended:
      c.destroy<count_value_extended_s>();
      break;
    case types::dlcount_value_extended:
      c.destroy<count_value_extended_s>();
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      c.destroy<bounded_bitstring<1, 16384, false, true> >();
      break;
    case types::ulcount_value_pdcp_snlen18:
      c.destroy<coun_tvalue_pdcp_snlen18_s>();
      break;
    case types::dlcount_value_pdcp_snlen18:
      c.destroy<coun_tvalue_pdcp_snlen18_s>();
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      c.destroy<bounded_bitstring<1, 131072, false, true> >();
      break;
    default:
      break;
  }
}
void bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ulcount_value_extended:
      c.init<count_value_extended_s>();
      break;
    case types::dlcount_value_extended:
      c.init<count_value_extended_s>();
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      c.init<bounded_bitstring<1, 16384, false, true> >();
      break;
    case types::ulcount_value_pdcp_snlen18:
      c.init<coun_tvalue_pdcp_snlen18_s>();
      break;
    case types::dlcount_value_pdcp_snlen18:
      c.init<coun_tvalue_pdcp_snlen18_s>();
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      c.init<bounded_bitstring<1, 131072, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
  }
}
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::ext_c(
    const bearers_subject_to_status_transfer_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ulcount_value_extended:
      c.init(other.c.get<count_value_extended_s>());
      break;
    case types::dlcount_value_extended:
      c.init(other.c.get<count_value_extended_s>());
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      c.init(other.c.get<bounded_bitstring<1, 16384, false, true> >());
      break;
    case types::ulcount_value_pdcp_snlen18:
      c.init(other.c.get<coun_tvalue_pdcp_snlen18_s>());
      break;
    case types::dlcount_value_pdcp_snlen18:
      c.init(other.c.get<coun_tvalue_pdcp_snlen18_s>());
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      c.init(other.c.get<bounded_bitstring<1, 131072, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
  }
}
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::operator=(
    const bearers_subject_to_status_transfer_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ulcount_value_extended:
      c.set(other.c.get<count_value_extended_s>());
      break;
    case types::dlcount_value_extended:
      c.set(other.c.get<count_value_extended_s>());
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      c.set(other.c.get<bounded_bitstring<1, 16384, false, true> >());
      break;
    case types::ulcount_value_pdcp_snlen18:
      c.set(other.c.get<coun_tvalue_pdcp_snlen18_s>());
      break;
    case types::dlcount_value_pdcp_snlen18:
      c.set(other.c.get<coun_tvalue_pdcp_snlen18_s>());
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      c.set(other.c.get<bounded_bitstring<1, 131072, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
  }

  return *this;
}
count_value_extended_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::ulcount_value_extended()
{
  assert_choice_type(types::ulcount_value_extended, type_, "Extension");
  return c.get<count_value_extended_s>();
}
count_value_extended_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::dlcount_value_extended()
{
  assert_choice_type(types::dlcount_value_extended, type_, "Extension");
  return c.get<count_value_extended_s>();
}
bounded_bitstring<1, 16384, false, true>&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::receive_status_of_ulpdcpsdus_extended()
{
  assert_choice_type(types::receive_status_of_ulpdcpsdus_extended, type_, "Extension");
  return c.get<bounded_bitstring<1, 16384, false, true> >();
}
coun_tvalue_pdcp_snlen18_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::ulcount_value_pdcp_snlen18()
{
  assert_choice_type(types::ulcount_value_pdcp_snlen18, type_, "Extension");
  return c.get<coun_tvalue_pdcp_snlen18_s>();
}
coun_tvalue_pdcp_snlen18_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::dlcount_value_pdcp_snlen18()
{
  assert_choice_type(types::dlcount_value_pdcp_snlen18, type_, "Extension");
  return c.get<coun_tvalue_pdcp_snlen18_s>();
}
bounded_bitstring<1, 131072, false, true>&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::receive_status_of_ulpdcpsdus_pdcp_snlen18()
{
  assert_choice_type(types::receive_status_of_ulpdcpsdus_pdcp_snlen18, type_, "Extension");
  return c.get<bounded_bitstring<1, 131072, false, true> >();
}
const count_value_extended_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::ulcount_value_extended() const
{
  assert_choice_type(types::ulcount_value_extended, type_, "Extension");
  return c.get<count_value_extended_s>();
}
const count_value_extended_s& bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::dlcount_value_extended() const
{
  assert_choice_type(types::dlcount_value_extended, type_, "Extension");
  return c.get<count_value_extended_s>();
}
const bounded_bitstring<1, 16384, false, true>&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::receive_status_of_ulpdcpsdus_extended() const
{
  assert_choice_type(types::receive_status_of_ulpdcpsdus_extended, type_, "Extension");
  return c.get<bounded_bitstring<1, 16384, false, true> >();
}
const coun_tvalue_pdcp_snlen18_s&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::ulcount_value_pdcp_snlen18() const
{
  assert_choice_type(types::ulcount_value_pdcp_snlen18, type_, "Extension");
  return c.get<coun_tvalue_pdcp_snlen18_s>();
}
const coun_tvalue_pdcp_snlen18_s&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::dlcount_value_pdcp_snlen18() const
{
  assert_choice_type(types::dlcount_value_pdcp_snlen18, type_, "Extension");
  return c.get<coun_tvalue_pdcp_snlen18_s>();
}
const bounded_bitstring<1, 131072, false, true>&
bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::receive_status_of_ulpdcpsdus_pdcp_snlen18() const
{
  assert_choice_type(types::receive_status_of_ulpdcpsdus_pdcp_snlen18, type_, "Extension");
  return c.get<bounded_bitstring<1, 131072, false, true> >();
}
void bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ulcount_value_extended:
      j.write_fieldname("COUNTValueExtended");
      c.get<count_value_extended_s>().to_json(j);
      break;
    case types::dlcount_value_extended:
      j.write_fieldname("COUNTValueExtended");
      c.get<count_value_extended_s>().to_json(j);
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 16384, false, true> >().to_string());
      break;
    case types::ulcount_value_pdcp_snlen18:
      j.write_fieldname("COUNTvaluePDCP-SNlength18");
      c.get<coun_tvalue_pdcp_snlen18_s>().to_json(j);
      break;
    case types::dlcount_value_pdcp_snlen18:
      j.write_fieldname("COUNTvaluePDCP-SNlength18");
      c.get<coun_tvalue_pdcp_snlen18_s>().to_json(j);
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 131072, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ulcount_value_extended:
      HANDLE_CODE(c.get<count_value_extended_s>().pack(bref));
      break;
    case types::dlcount_value_extended:
      HANDLE_CODE(c.get<count_value_extended_s>().pack(bref));
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      HANDLE_CODE((c.get<bounded_bitstring<1, 16384, false, true> >().pack(bref)));
      break;
    case types::ulcount_value_pdcp_snlen18:
      HANDLE_CODE(c.get<coun_tvalue_pdcp_snlen18_s>().pack(bref));
      break;
    case types::dlcount_value_pdcp_snlen18:
      HANDLE_CODE(c.get<coun_tvalue_pdcp_snlen18_s>().pack(bref));
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      HANDLE_CODE((c.get<bounded_bitstring<1, 131072, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ulcount_value_extended:
      HANDLE_CODE(c.get<count_value_extended_s>().unpack(bref));
      break;
    case types::dlcount_value_extended:
      HANDLE_CODE(c.get<count_value_extended_s>().unpack(bref));
      break;
    case types::receive_status_of_ulpdcpsdus_extended:
      HANDLE_CODE((c.get<bounded_bitstring<1, 16384, false, true> >().unpack(bref)));
      break;
    case types::ulcount_value_pdcp_snlen18:
      HANDLE_CODE(c.get<coun_tvalue_pdcp_snlen18_s>().unpack(bref));
      break;
    case types::dlcount_value_pdcp_snlen18:
      HANDLE_CODE(c.get<coun_tvalue_pdcp_snlen18_s>().unpack(bref));
      break;
    case types::receive_status_of_ulpdcpsdus_pdcp_snlen18:
      HANDLE_CODE((c.get<bounded_bitstring<1, 131072, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"COUNTValueExtended",
                                  "COUNTValueExtended",
                                  "BIT STRING",
                                  "COUNTvaluePDCP-SNlength18",
                                  "COUNTvaluePDCP-SNlength18",
                                  "BIT STRING"};
  return convert_enum_idx(options, 6, value, "bearers_subject_to_status_transfer_item_ext_ies_o::ext_c::types");
}

// COUNTvalue ::= SEQUENCE
SRSASN_CODE coun_tvalue_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE coun_tvalue_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(hfn, bref, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void coun_tvalue_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SN", pdcp_sn);
  j.write_int("hFN", hfn);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ext_field_s<bearers_subject_to_status_transfer_item_ext_ies_o>;

bearers_subject_to_status_transfer_item_ext_ies_container::bearers_subject_to_status_transfer_item_ext_ies_container() :
  ulcount_value_extended(179, crit_e::ignore),
  dlcount_value_extended(180, crit_e::ignore),
  receive_status_of_ulpdcpsdus_extended(181, crit_e::ignore),
  ulcount_value_pdcp_snlen18(217, crit_e::ignore),
  dlcount_value_pdcp_snlen18(218, crit_e::ignore),
  receive_status_of_ulpdcpsdus_pdcp_snlen18(219, crit_e::ignore)
{}
SRSASN_CODE bearers_subject_to_status_transfer_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ulcount_value_extended_present ? 1 : 0;
  nof_ies += dlcount_value_extended_present ? 1 : 0;
  nof_ies += receive_status_of_ulpdcpsdus_extended_present ? 1 : 0;
  nof_ies += ulcount_value_pdcp_snlen18_present ? 1 : 0;
  nof_ies += dlcount_value_pdcp_snlen18_present ? 1 : 0;
  nof_ies += receive_status_of_ulpdcpsdus_pdcp_snlen18_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ulcount_value_extended_present) {
    HANDLE_CODE(ulcount_value_extended.pack(bref));
  }
  if (dlcount_value_extended_present) {
    HANDLE_CODE(dlcount_value_extended.pack(bref));
  }
  if (receive_status_of_ulpdcpsdus_extended_present) {
    HANDLE_CODE(receive_status_of_ulpdcpsdus_extended.pack(bref));
  }
  if (ulcount_value_pdcp_snlen18_present) {
    HANDLE_CODE(ulcount_value_pdcp_snlen18.pack(bref));
  }
  if (dlcount_value_pdcp_snlen18_present) {
    HANDLE_CODE(dlcount_value_pdcp_snlen18.pack(bref));
  }
  if (receive_status_of_ulpdcpsdus_pdcp_snlen18_present) {
    HANDLE_CODE(receive_status_of_ulpdcpsdus_pdcp_snlen18.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bearers_subject_to_status_transfer_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<bearers_subject_to_status_transfer_item_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 179:
        ulcount_value_extended_present = true;
        ulcount_value_extended.id      = c.id;
        ulcount_value_extended.crit    = c.crit;
        ulcount_value_extended.ext     = c.ext_value.ulcount_value_extended();
        break;
      case 180:
        dlcount_value_extended_present = true;
        dlcount_value_extended.id      = c.id;
        dlcount_value_extended.crit    = c.crit;
        dlcount_value_extended.ext     = c.ext_value.dlcount_value_extended();
        break;
      case 181:
        receive_status_of_ulpdcpsdus_extended_present = true;
        receive_status_of_ulpdcpsdus_extended.id      = c.id;
        receive_status_of_ulpdcpsdus_extended.crit    = c.crit;
        receive_status_of_ulpdcpsdus_extended.ext     = c.ext_value.receive_status_of_ulpdcpsdus_extended();
        break;
      case 217:
        ulcount_value_pdcp_snlen18_present = true;
        ulcount_value_pdcp_snlen18.id      = c.id;
        ulcount_value_pdcp_snlen18.crit    = c.crit;
        ulcount_value_pdcp_snlen18.ext     = c.ext_value.ulcount_value_pdcp_snlen18();
        break;
      case 218:
        dlcount_value_pdcp_snlen18_present = true;
        dlcount_value_pdcp_snlen18.id      = c.id;
        dlcount_value_pdcp_snlen18.crit    = c.crit;
        dlcount_value_pdcp_snlen18.ext     = c.ext_value.dlcount_value_pdcp_snlen18();
        break;
      case 219:
        receive_status_of_ulpdcpsdus_pdcp_snlen18_present = true;
        receive_status_of_ulpdcpsdus_pdcp_snlen18.id      = c.id;
        receive_status_of_ulpdcpsdus_pdcp_snlen18.crit    = c.crit;
        receive_status_of_ulpdcpsdus_pdcp_snlen18.ext     = c.ext_value.receive_status_of_ulpdcpsdus_pdcp_snlen18();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void bearers_subject_to_status_transfer_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ulcount_value_extended_present) {
    j.write_fieldname("");
    ulcount_value_extended.to_json(j);
  }
  if (dlcount_value_extended_present) {
    j.write_fieldname("");
    dlcount_value_extended.to_json(j);
  }
  if (receive_status_of_ulpdcpsdus_extended_present) {
    j.write_fieldname("");
    receive_status_of_ulpdcpsdus_extended.to_json(j);
  }
  if (ulcount_value_pdcp_snlen18_present) {
    j.write_fieldname("");
    ulcount_value_pdcp_snlen18.to_json(j);
  }
  if (dlcount_value_pdcp_snlen18_present) {
    j.write_fieldname("");
    dlcount_value_pdcp_snlen18.to_json(j);
  }
  if (receive_status_of_ulpdcpsdus_pdcp_snlen18_present) {
    j.write_fieldname("");
    receive_status_of_ulpdcpsdus_pdcp_snlen18.to_json(j);
  }
  j.end_obj();
}

// Bearers-SubjectToStatusTransfer-Item ::= SEQUENCE
SRSASN_CODE bearers_subject_to_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_statusof_ulpdcpsdus_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(ul_coun_tvalue.pack(bref));
  HANDLE_CODE(dl_coun_tvalue.pack(bref));
  if (receive_statusof_ulpdcpsdus_present) {
    HANDLE_CODE(receive_statusof_ulpdcpsdus.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bearers_subject_to_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_statusof_ulpdcpsdus_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(ul_coun_tvalue.unpack(bref));
  HANDLE_CODE(dl_coun_tvalue.unpack(bref));
  if (receive_statusof_ulpdcpsdus_present) {
    HANDLE_CODE(receive_statusof_ulpdcpsdus.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bearers_subject_to_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("uL-COUNTvalue");
  ul_coun_tvalue.to_json(j);
  j.write_fieldname("dL-COUNTvalue");
  dl_coun_tvalue.to_json(j);
  if (receive_statusof_ulpdcpsdus_present) {
    j.write_str("receiveStatusofULPDCPSDUs", receive_statusof_ulpdcpsdus.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Bearers-SubjectToStatusTransfer-ItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t bearers_subject_to_status_transfer_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {89};
  return map_enum_number(options, 1, idx, "id");
}
bool bearers_subject_to_status_transfer_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 89 == id;
}
crit_e bearers_subject_to_status_transfer_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 89) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
bearers_subject_to_status_transfer_item_ies_o::value_c
bearers_subject_to_status_transfer_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 89) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e bearers_subject_to_status_transfer_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 89) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void bearers_subject_to_status_transfer_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("Bearers-SubjectToStatusTransfer-Item");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE bearers_subject_to_status_transfer_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE bearers_subject_to_status_transfer_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* bearers_subject_to_status_transfer_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Bearers-SubjectToStatusTransfer-Item"};
  return convert_enum_idx(options, 1, value, "bearers_subject_to_status_transfer_item_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<bearers_subject_to_status_transfer_item_ies_o>;

// BluetoothMeasConfig ::= ENUMERATED
const char* bluetooth_meas_cfg_opts::to_string() const
{
  static const char* options[] = {"setup"};
  return convert_enum_idx(options, 1, value, "bluetooth_meas_cfg_e");
}

// BluetoothMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.pack(bt_rssi_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  if (bluetooth_meas_cfg_name_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bluetooth_meas_cfg_name_list, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(bt_rssi_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  if (bluetooth_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bluetooth_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothMeasConfig", "setup");
  if (bluetooth_meas_cfg_name_list_present) {
    j.start_array("bluetoothMeasConfigNameList");
    for (const auto& e1 : bluetooth_meas_cfg_name_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (bt_rssi_present) {
    j.write_str("bt-rssi", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* bluetooth_meas_cfg_s::bt_rssi_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "bluetooth_meas_cfg_s::bt_rssi_e_");
}

// CancelledCellinEAI-Item ::= SEQUENCE
SRSASN_CODE cancelled_cellin_eai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cellin_eai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cellin_eai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellinTAI-Item ::= SEQUENCE
SRSASN_CODE cancelled_cellin_tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cellin_tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cellin_tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellID-Cancelled-Item ::= SEQUENCE
SRSASN_CODE cell_id_cancelled_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_cancelled_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_cancelled_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaID-Cancelled-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_cancelled_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cellin_eai, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_cancelled_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cellin_eai, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_cancelled_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("cancelledCellinEAI");
  for (const auto& e1 : cancelled_cellin_eai) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAI-Cancelled-Item ::= SEQUENCE
SRSASN_CODE tai_cancelled_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cellin_tai, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_cancelled_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cellin_tai, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_cancelled_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("cancelledCellinTAI");
  for (const auto& e1 : cancelled_cellin_tai) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCancelledAreaList ::= CHOICE
void broadcast_cancelled_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_cancelled:
      c.destroy<cell_id_cancelled_l>();
      break;
    case types::tai_cancelled:
      c.destroy<tai_cancelled_l>();
      break;
    case types::emergency_area_id_cancelled:
      c.destroy<emergency_area_id_cancelled_l>();
      break;
    default:
      break;
  }
}
void broadcast_cancelled_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_cancelled:
      c.init<cell_id_cancelled_l>();
      break;
    case types::tai_cancelled:
      c.init<tai_cancelled_l>();
      break;
    case types::emergency_area_id_cancelled:
      c.init<emergency_area_id_cancelled_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c::broadcast_cancelled_area_list_c(const broadcast_cancelled_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_cancelled:
      c.init(other.c.get<cell_id_cancelled_l>());
      break;
    case types::tai_cancelled:
      c.init(other.c.get<tai_cancelled_l>());
      break;
    case types::emergency_area_id_cancelled:
      c.init(other.c.get<emergency_area_id_cancelled_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c&
broadcast_cancelled_area_list_c::operator=(const broadcast_cancelled_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_cancelled:
      c.set(other.c.get<cell_id_cancelled_l>());
      break;
    case types::tai_cancelled:
      c.set(other.c.get<tai_cancelled_l>());
      break;
    case types::emergency_area_id_cancelled:
      c.set(other.c.get<emergency_area_id_cancelled_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }

  return *this;
}
cell_id_cancelled_l& broadcast_cancelled_area_list_c::set_cell_id_cancelled()
{
  set(types::cell_id_cancelled);
  return c.get<cell_id_cancelled_l>();
}
tai_cancelled_l& broadcast_cancelled_area_list_c::set_tai_cancelled()
{
  set(types::tai_cancelled);
  return c.get<tai_cancelled_l>();
}
emergency_area_id_cancelled_l& broadcast_cancelled_area_list_c::set_emergency_area_id_cancelled()
{
  set(types::emergency_area_id_cancelled);
  return c.get<emergency_area_id_cancelled_l>();
}
void broadcast_cancelled_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_cancelled:
      j.start_array("cellID-Cancelled");
      for (const auto& e1 : c.get<cell_id_cancelled_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_cancelled:
      j.start_array("tAI-Cancelled");
      for (const auto& e1 : c.get<tai_cancelled_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_cancelled:
      j.start_array("emergencyAreaID-Cancelled");
      for (const auto& e1 : c.get<emergency_area_id_cancelled_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_cancelled_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_cancelled:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_cancelled_l>(), 1, 65535, true));
      break;
    case types::tai_cancelled:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_cancelled_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_cancelled_l>(), 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_cancelled_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_cancelled:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_cancelled_l>(), bref, 1, 65535, true));
      break;
    case types::tai_cancelled:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_cancelled_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_cancelled_l>(), bref, 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_cancelled_area_list_c::types_opts::to_string() const
{
  static const char* options[] = {"cellID-Cancelled", "tAI-Cancelled", "emergencyAreaID-Cancelled"};
  return convert_enum_idx(options, 3, value, "broadcast_cancelled_area_list_c::types");
}

// CompletedCellinEAI-Item ::= SEQUENCE
SRSASN_CODE completed_cellin_eai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cellin_eai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cellin_eai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellinTAI-Item ::= SEQUENCE
SRSASN_CODE completed_cellin_tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cellin_tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cellin_tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellID-Broadcast-Item ::= SEQUENCE
SRSASN_CODE cell_id_broadcast_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_broadcast_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_broadcast_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaID-Broadcast-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_broadcast_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cellin_eai, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_broadcast_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cellin_eai, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_broadcast_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("completedCellinEAI");
  for (const auto& e1 : completed_cellin_eai) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAI-Broadcast-Item ::= SEQUENCE
SRSASN_CODE tai_broadcast_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cellin_tai, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_broadcast_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cellin_tai, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_broadcast_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("completedCellinTAI");
  for (const auto& e1 : completed_cellin_tai) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCompletedAreaList ::= CHOICE
void broadcast_completed_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_broadcast:
      c.destroy<cell_id_broadcast_l>();
      break;
    case types::tai_broadcast:
      c.destroy<tai_broadcast_l>();
      break;
    case types::emergency_area_id_broadcast:
      c.destroy<emergency_area_id_broadcast_l>();
      break;
    default:
      break;
  }
}
void broadcast_completed_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_broadcast:
      c.init<cell_id_broadcast_l>();
      break;
    case types::tai_broadcast:
      c.init<tai_broadcast_l>();
      break;
    case types::emergency_area_id_broadcast:
      c.init<emergency_area_id_broadcast_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c::broadcast_completed_area_list_c(const broadcast_completed_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_broadcast:
      c.init(other.c.get<cell_id_broadcast_l>());
      break;
    case types::tai_broadcast:
      c.init(other.c.get<tai_broadcast_l>());
      break;
    case types::emergency_area_id_broadcast:
      c.init(other.c.get<emergency_area_id_broadcast_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c&
broadcast_completed_area_list_c::operator=(const broadcast_completed_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_broadcast:
      c.set(other.c.get<cell_id_broadcast_l>());
      break;
    case types::tai_broadcast:
      c.set(other.c.get<tai_broadcast_l>());
      break;
    case types::emergency_area_id_broadcast:
      c.set(other.c.get<emergency_area_id_broadcast_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }

  return *this;
}
cell_id_broadcast_l& broadcast_completed_area_list_c::set_cell_id_broadcast()
{
  set(types::cell_id_broadcast);
  return c.get<cell_id_broadcast_l>();
}
tai_broadcast_l& broadcast_completed_area_list_c::set_tai_broadcast()
{
  set(types::tai_broadcast);
  return c.get<tai_broadcast_l>();
}
emergency_area_id_broadcast_l& broadcast_completed_area_list_c::set_emergency_area_id_broadcast()
{
  set(types::emergency_area_id_broadcast);
  return c.get<emergency_area_id_broadcast_l>();
}
void broadcast_completed_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_broadcast:
      j.start_array("cellID-Broadcast");
      for (const auto& e1 : c.get<cell_id_broadcast_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_broadcast:
      j.start_array("tAI-Broadcast");
      for (const auto& e1 : c.get<tai_broadcast_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_broadcast:
      j.start_array("emergencyAreaID-Broadcast");
      for (const auto& e1 : c.get<emergency_area_id_broadcast_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_completed_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_broadcast:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_broadcast_l>(), 1, 65535, true));
      break;
    case types::tai_broadcast:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_broadcast_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_broadcast_l>(), 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_completed_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_broadcast:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_broadcast_l>(), bref, 1, 65535, true));
      break;
    case types::tai_broadcast:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_broadcast_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_broadcast_l>(), bref, 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_completed_area_list_c::types_opts::to_string() const
{
  static const char* options[] = {"cellID-Broadcast", "tAI-Broadcast", "emergencyAreaID-Broadcast"};
  return convert_enum_idx(options, 3, value, "broadcast_completed_area_list_c::types");
}

// CGI ::= SEQUENCE
SRSASN_CODE cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(lac.pack(bref));
  HANDLE_CODE(ci.pack(bref));
  if (rac_present) {
    HANDLE_CODE(rac.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(lac.unpack(bref));
  HANDLE_CODE(ci.unpack(bref));
  if (rac_present) {
    HANDLE_CODE(rac.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("lAC", lac.to_string());
  j.write_str("cI", ci.to_string());
  if (rac_present) {
    j.write_str("rAC", rac.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNType ::= ENUMERATED
const char* cn_type_opts::to_string() const
{
  static const char* options[] = {"fiveGCForbidden", "epc-Forbiddden"};
  return convert_enum_idx(options, 2, value, "cn_type_e");
}
uint8_t cn_type_opts::to_number() const
{
  static const uint8_t options[] = {5};
  return map_enum_number(options, 1, value, "cn_type_e");
}

// CNTypeRestrictions-Item ::= SEQUENCE
SRSASN_CODE cn_type_restricts_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(cntype.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_type_restricts_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(cntype.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_type_restricts_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_str("cNType", cntype.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CSG-IdList-Item ::= SEQUENCE
SRSASN_CODE csg_id_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(csg_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE csg_id_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(csg_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void csg_id_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cSG-Id", csg_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CSGMembershipStatus ::= ENUMERATED
const char* csg_membership_status_opts::to_string() const
{
  static const char* options[] = {"member", "not-member"};
  return convert_enum_idx(options, 2, value, "csg_membership_status_e");
}

// CellAccessMode ::= ENUMERATED
const char* cell_access_mode_opts::to_string() const
{
  static const char* options[] = {"hybrid"};
  return convert_enum_idx(options, 1, value, "cell_access_mode_e");
}

// CSGMembershipInfo ::= SEQUENCE
SRSASN_CODE csg_membership_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_access_mode_present, 1));
  HANDLE_CODE(bref.pack(plm_nid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(csg_membership_status.pack(bref));
  HANDLE_CODE(csg_id.pack(bref));
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.pack(bref));
  }
  if (plm_nid_present) {
    HANDLE_CODE(plm_nid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE csg_membership_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_access_mode_present, 1));
  HANDLE_CODE(bref.unpack(plm_nid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(csg_membership_status.unpack(bref));
  HANDLE_CODE(csg_id.unpack(bref));
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.unpack(bref));
  }
  if (plm_nid_present) {
    HANDLE_CODE(plm_nid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void csg_membership_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cSGMembershipStatus", csg_membership_status.to_string());
  j.write_str("cSG-Id", csg_id.to_string());
  if (cell_access_mode_present) {
    j.write_str("cellAccessMode", "hybrid");
  }
  if (plm_nid_present) {
    j.write_str("pLMNidentity", plm_nid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IRAT-Cell-ID ::= CHOICE
void irat_cell_id_c::destroy_()
{
  switch (type_) {
    case types::eutran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::utran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::geran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.destroy<fixed_octstring<16, true> >();
      break;
    default:
      break;
  }
}
void irat_cell_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::utran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::geran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.init<fixed_octstring<16, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
  }
}
irat_cell_id_c::irat_cell_id_c(const irat_cell_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::utran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.init(other.c.get<fixed_octstring<16, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
  }
}
irat_cell_id_c& irat_cell_id_c::operator=(const irat_cell_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::utran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.set(other.c.get<fixed_octstring<16, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
  }

  return *this;
}
unbounded_octstring<true>& irat_cell_id_c::set_eutran()
{
  set(types::eutran);
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& irat_cell_id_c::set_utran()
{
  set(types::utran);
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& irat_cell_id_c::set_geran()
{
  set(types::geran);
  return c.get<unbounded_octstring<true> >();
}
fixed_octstring<16, true>& irat_cell_id_c::set_ehrpd()
{
  set(types::ehrpd);
  return c.get<fixed_octstring<16, true> >();
}
void irat_cell_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran:
      j.write_str("eUTRAN", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::utran:
      j.write_str("uTRAN", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::geran:
      j.write_str("gERAN", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ehrpd:
      j.write_str("eHRPD", c.get<fixed_octstring<16, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
  }
  j.end_obj();
}
SRSASN_CODE irat_cell_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::geran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ehrpd: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_octstring<16, true> >().pack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE irat_cell_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::geran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ehrpd: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_octstring<16, true> >().unpack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "irat_cell_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* irat_cell_id_c::types_opts::to_string() const
{
  static const char* options[] = {"eUTRAN", "uTRAN", "gERAN", "eHRPD"};
  return convert_enum_idx(options, 4, value, "irat_cell_id_c::types");
}

// CandidatePCI ::= SEQUENCE
SRSASN_CODE candidate_pci_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, pci, (uint16_t)0u, (uint16_t)503u, false, true));
  HANDLE_CODE(earfcn.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_pci_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(pci, bref, (uint16_t)0u, (uint16_t)503u, false, true));
  HANDLE_CODE(earfcn.unpack(bref));

  return SRSASN_SUCCESS;
}
void candidate_pci_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pCI", pci);
  j.write_str("eARFCN", earfcn.to_string());
  j.end_obj();
}

// CauseMisc ::= ENUMERATED
const char* cause_misc_opts::to_string() const
{
  static const char* options[] = {"control-processing-overload",
                                  "not-enough-user-plane-processing-resources",
                                  "hardware-failure",
                                  "om-intervention",
                                  "unspecified",
                                  "unknown-PLMN"};
  return convert_enum_idx(options, 6, value, "cause_misc_e");
}

// CauseNas ::= ENUMERATED
const char* cause_nas_opts::to_string() const
{
  static const char* options[] = {
      "normal-release", "authentication-failure", "detach", "unspecified", "csg-subscription-expiry"};
  return convert_enum_idx(options, 5, value, "cause_nas_e");
}

// CauseProtocol ::= ENUMERATED
const char* cause_protocol_opts::to_string() const
{
  static const char* options[] = {"transfer-syntax-error",
                                  "abstract-syntax-error-reject",
                                  "abstract-syntax-error-ignore-and-notify",
                                  "message-not-compatible-with-receiver-state",
                                  "semantic-error",
                                  "abstract-syntax-error-falsely-constructed-message",
                                  "unspecified"};
  return convert_enum_idx(options, 7, value, "cause_protocol_e");
}

// CauseRadioNetwork ::= ENUMERATED
const char* cause_radio_network_opts::to_string() const
{
  static const char* options[] = {"unspecified",
                                  "tx2relocoverall-expiry",
                                  "successful-handover",
                                  "release-due-to-eutran-generated-reason",
                                  "handover-cancelled",
                                  "partial-handover",
                                  "ho-failure-in-target-EPC-eNB-or-target-system",
                                  "ho-target-not-allowed",
                                  "tS1relocoverall-expiry",
                                  "tS1relocprep-expiry",
                                  "cell-not-available",
                                  "unknown-targetID",
                                  "no-radio-resources-available-in-target-cell",
                                  "unknown-mme-ue-s1ap-id",
                                  "unknown-enb-ue-s1ap-id",
                                  "unknown-pair-ue-s1ap-id",
                                  "handover-desirable-for-radio-reason",
                                  "time-critical-handover",
                                  "resource-optimisation-handover",
                                  "reduce-load-in-serving-cell",
                                  "user-inactivity",
                                  "radio-connection-with-ue-lost",
                                  "load-balancing-tau-required",
                                  "cs-fallback-triggered",
                                  "ue-not-available-for-ps-service",
                                  "radio-resources-not-available",
                                  "failure-in-radio-interface-procedure",
                                  "invalid-qos-combination",
                                  "interrat-redirection",
                                  "interaction-with-other-procedure",
                                  "unknown-E-RAB-ID",
                                  "multiple-E-RAB-ID-instances",
                                  "encryption-and-or-integrity-protection-algorithms-not-supported",
                                  "s1-intra-system-handover-triggered",
                                  "s1-inter-system-handover-triggered",
                                  "x2-handover-triggered",
                                  "redirection-towards-1xRTT",
                                  "not-supported-QCI-value",
                                  "invalid-CSG-Id",
                                  "release-due-to-pre-emption"};
  return convert_enum_idx(options, 40, value, "cause_radio_network_e");
}

// CauseTransport ::= ENUMERATED
const char* cause_transport_opts::to_string() const
{
  static const char* options[] = {"transport-resource-unavailable", "unspecified"};
  return convert_enum_idx(options, 2, value, "cause_transport_e");
}

// Cause ::= CHOICE
void cause_c::destroy_() {}
void cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
cause_c::cause_c(const cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::radio_network:
      c.init(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.init(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.init(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.init(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.init(other.c.get<cause_misc_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c& cause_c::operator=(const cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::radio_network:
      c.set(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.set(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.set(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.set(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.set(other.c.get<cause_misc_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }

  return *this;
}
cause_radio_network_e& cause_c::set_radio_network()
{
  set(types::radio_network);
  return c.get<cause_radio_network_e>();
}
cause_transport_e& cause_c::set_transport()
{
  set(types::transport);
  return c.get<cause_transport_e>();
}
cause_nas_e& cause_c::set_nas()
{
  set(types::nas);
  return c.get<cause_nas_e>();
}
cause_protocol_e& cause_c::set_protocol()
{
  set(types::protocol);
  return c.get<cause_protocol_e>();
}
cause_misc_e& cause_c::set_misc()
{
  set(types::misc);
  return c.get<cause_misc_e>();
}
void cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::radio_network:
      j.write_str("radioNetwork", c.get<cause_radio_network_e>().to_string());
      break;
    case types::transport:
      j.write_str("transport", c.get<cause_transport_e>().to_string());
      break;
    case types::nas:
      j.write_str("nas", c.get<cause_nas_e>().to_string());
      break;
    case types::protocol:
      j.write_str("protocol", c.get<cause_protocol_e>().to_string());
      break;
    case types::misc:
      j.write_str("misc", c.get<cause_misc_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
  j.end_obj();
}
SRSASN_CODE cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().pack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().pack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().pack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().pack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().unpack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().unpack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().unpack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().unpack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cause_c::types_opts::to_string() const
{
  static const char* options[] = {"radioNetwork", "transport", "nas", "protocol", "misc"};
  return convert_enum_idx(options, 5, value, "cause_c::types");
}
uint8_t cause_c::types_opts::to_number() const
{
  static const uint8_t options[] = {2};
  return map_enum_number(options, 1, value, "cause_c::types");
}

// Cdma2000OneXSRVCCInfo ::= SEQUENCE
SRSASN_CODE cdma2000_one_xsrvcc_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cdma2000_one_xmeid.pack(bref));
  HANDLE_CODE(cdma2000_one_xmsi.pack(bref));
  HANDLE_CODE(cdma2000_one_xpilot.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cdma2000_one_xsrvcc_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cdma2000_one_xmeid.unpack(bref));
  HANDLE_CODE(cdma2000_one_xmsi.unpack(bref));
  HANDLE_CODE(cdma2000_one_xpilot.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cdma2000_one_xsrvcc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cdma2000OneXMEID", cdma2000_one_xmeid.to_string());
  j.write_str("cdma2000OneXMSI", cdma2000_one_xmsi.to_string());
  j.write_str("cdma2000OneXPilot", cdma2000_one_xpilot.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellsToActivateList-Item ::= SEQUENCE
SRSASN_CODE cells_to_activ_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(cell_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_activ_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(cell_id.unpack(bref));

  return SRSASN_SUCCESS;
}
void cells_to_activ_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cell-ID", cell_id.to_string());
  j.end_obj();
}

// CellActivationRequest ::= SEQUENCE
SRSASN_CODE cell_activation_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(minimum_activation_time_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cells_to_activ_list, 1, 256, true));
  if (minimum_activation_time_present) {
    HANDLE_CODE(pack_integer(bref, minimum_activation_time, (uint8_t)1u, (uint8_t)60u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_activation_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(minimum_activation_time_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cells_to_activ_list, bref, 1, 256, true));
  if (minimum_activation_time_present) {
    HANDLE_CODE(unpack_integer(minimum_activation_time, bref, (uint8_t)1u, (uint8_t)60u, false, true));
  }

  return SRSASN_SUCCESS;
}
void cell_activation_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellsToActivateList");
  for (const auto& e1 : cells_to_activ_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (minimum_activation_time_present) {
    j.write_int("minimumActivationTime", minimum_activation_time);
  }
  j.end_obj();
}

// CellActivationResponse ::= SEQUENCE
SRSASN_CODE cell_activation_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, activ_cells_list, 0, 256, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_activation_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(activ_cells_list, bref, 0, 256, true));

  return SRSASN_SUCCESS;
}
void cell_activation_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("activatedCellsList");
  for (const auto& e1 : activ_cells_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

// EHRPDCompositeAvailableCapacity ::= SEQUENCE
SRSASN_CODE ehrpd_composite_available_capacity_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, ehrpd_sector_capacity_class_value, (uint8_t)1u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, ehrpd_capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ehrpd_composite_available_capacity_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(ehrpd_sector_capacity_class_value, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(ehrpd_capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));

  return SRSASN_SUCCESS;
}
void ehrpd_composite_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("eHRPDSectorCapacityClassValue", ehrpd_sector_capacity_class_value);
  j.write_int("eHRPDCapacityValue", ehrpd_capacity_value);
  j.end_obj();
}

// EHRPDSectorLoadReportingResponse ::= SEQUENCE
SRSASN_CODE ehrpd_sector_load_report_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(dl_ehrpd_composite_available_capacity.pack(bref));
  HANDLE_CODE(ul_ehrpd_composite_available_capacity.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ehrpd_sector_load_report_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(dl_ehrpd_composite_available_capacity.unpack(bref));
  HANDLE_CODE(ul_ehrpd_composite_available_capacity.unpack(bref));

  return SRSASN_SUCCESS;
}
void ehrpd_sector_load_report_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-EHRPD-CompositeAvailableCapacity");
  dl_ehrpd_composite_available_capacity.to_json(j);
  j.write_fieldname("uL-EHRPD-CompositeAvailableCapacity");
  ul_ehrpd_composite_available_capacity.to_json(j);
  j.end_obj();
}

// EUTRANcellLoadReportingResponse ::= SEQUENCE
SRSASN_CODE eutra_ncell_load_report_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(composite_available_capacity_group.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_ncell_load_report_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(composite_available_capacity_group.unpack(bref));

  return SRSASN_SUCCESS;
}
void eutra_ncell_load_report_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("compositeAvailableCapacityGroup", composite_available_capacity_group.to_string());
  j.end_obj();
}

// CellLoadReportingResponse ::= CHOICE
void cell_load_report_resp_c::destroy_()
{
  switch (type_) {
    case types::eutran:
      c.destroy<eutra_ncell_load_report_resp_s>();
      break;
    case types::utran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::geran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.destroy<ehrpd_sector_load_report_resp_s>();
      break;
    default:
      break;
  }
}
void cell_load_report_resp_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran:
      c.init<eutra_ncell_load_report_resp_s>();
      break;
    case types::utran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::geran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.init<ehrpd_sector_load_report_resp_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
  }
}
cell_load_report_resp_c::cell_load_report_resp_c(const cell_load_report_resp_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran:
      c.init(other.c.get<eutra_ncell_load_report_resp_s>());
      break;
    case types::utran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.init(other.c.get<ehrpd_sector_load_report_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
  }
}
cell_load_report_resp_c& cell_load_report_resp_c::operator=(const cell_load_report_resp_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran:
      c.set(other.c.get<eutra_ncell_load_report_resp_s>());
      break;
    case types::utran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.set(other.c.get<ehrpd_sector_load_report_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
  }

  return *this;
}
eutra_ncell_load_report_resp_s& cell_load_report_resp_c::set_eutran()
{
  set(types::eutran);
  return c.get<eutra_ncell_load_report_resp_s>();
}
unbounded_octstring<true>& cell_load_report_resp_c::set_utran()
{
  set(types::utran);
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& cell_load_report_resp_c::set_geran()
{
  set(types::geran);
  return c.get<unbounded_octstring<true> >();
}
ehrpd_sector_load_report_resp_s& cell_load_report_resp_c::set_ehrpd()
{
  set(types::ehrpd);
  return c.get<ehrpd_sector_load_report_resp_s>();
}
void cell_load_report_resp_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran:
      j.write_fieldname("eUTRAN");
      c.get<eutra_ncell_load_report_resp_s>().to_json(j);
      break;
    case types::utran:
      j.write_str("uTRAN", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::geran:
      j.write_str("gERAN", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ehrpd:
      j.write_fieldname("eHRPD");
      c.get<ehrpd_sector_load_report_resp_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_load_report_resp_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutra_ncell_load_report_resp_s>().pack(bref));
      break;
    case types::utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::geran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ehrpd: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ehrpd_sector_load_report_resp_s>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_load_report_resp_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutra_ncell_load_report_resp_s>().unpack(bref));
      break;
    case types::utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::geran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ehrpd: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ehrpd_sector_load_report_resp_s>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "cell_load_report_resp_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_load_report_resp_c::types_opts::to_string() const
{
  static const char* options[] = {"eUTRAN", "uTRAN", "gERAN", "eHRPD"};
  return convert_enum_idx(options, 4, value, "cell_load_report_resp_c::types");
}

// NotifyFlag ::= ENUMERATED
const char* notify_flag_opts::to_string() const
{
  static const char* options[] = {"activated", "deactivated"};
  return convert_enum_idx(options, 2, value, "notify_flag_e");
}

// NotificationCellList-Item ::= SEQUENCE
SRSASN_CODE notif_cell_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(cell_id.pack(bref));
  HANDLE_CODE(notify_flag.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE notif_cell_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(cell_id.unpack(bref));
  HANDLE_CODE(notify_flag.unpack(bref));

  return SRSASN_SUCCESS;
}
void notif_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cell-ID", cell_id.to_string());
  j.write_str("notifyFlag", notify_flag.to_string());
  j.end_obj();
}

// CellStateIndication ::= SEQUENCE
SRSASN_CODE cell_state_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, notif_cell_list, 1, 256, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_state_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(notif_cell_list, bref, 1, 256, true));

  return SRSASN_SUCCESS;
}
void cell_state_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("notificationCellList");
  for (const auto& e1 : notif_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

// PrivacyIndicator ::= ENUMERATED
const char* privacy_ind_opts::to_string() const
{
  static const char* options[] = {"immediate-MDT", "logged-MDT"};
  return convert_enum_idx(options, 2, value, "privacy_ind_e");
}

// CellTrafficTraceIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t cell_traffic_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 86, 100, 131, 166};
  return map_enum_number(options, 6, idx, "id");
}
bool cell_traffic_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 86, 100, 131, 166};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cell_traffic_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 100:
      return crit_e::ignore;
    case 131:
      return crit_e::ignore;
    case 166:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
cell_traffic_trace_ies_o::value_c cell_traffic_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 86:
      ret.set(value_c::types::e_utran_trace_id);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 131:
      ret.set(value_c::types::trace_collection_entity_ip_address);
      break;
    case 166:
      ret.set(value_c::types::privacy_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e cell_traffic_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 131:
      return presence_e::mandatory;
    case 166:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void cell_traffic_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::e_utran_trace_id:
      c.destroy<fixed_octstring<8, true> >();
      break;
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::trace_collection_entity_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true> >();
      break;
    default:
      break;
  }
}
void cell_traffic_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::e_utran_trace_id:
      c.init<fixed_octstring<8, true> >();
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::trace_collection_entity_ip_address:
      c.init<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::privacy_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c::value_c(const cell_traffic_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::trace_collection_entity_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::privacy_ind:
      c.init(other.c.get<privacy_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c&
cell_traffic_trace_ies_o::value_c::operator=(const cell_traffic_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::trace_collection_entity_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::privacy_ind:
      c.set(other.c.get<privacy_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& cell_traffic_trace_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& cell_traffic_trace_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::e_utran_trace_id()
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
eutran_cgi_s& cell_traffic_trace_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
bounded_bitstring<1, 160, true, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address()
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind()
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& cell_traffic_trace_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::e_utran_trace_id() const
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
const eutran_cgi_s& cell_traffic_trace_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const bounded_bitstring<1, 160, true, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address() const
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
const privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind() const
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
void cell_traffic_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true> >().to_string());
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::trace_collection_entity_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true> >().to_string());
      break;
    case types::privacy_ind:
      j.write_str("PrivacyIndicator", c.get<privacy_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().pack(bref)));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().pack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().unpack(bref)));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().unpack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_traffic_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "EUTRAN-CGI",
                                  "BIT STRING",
                                  "PrivacyIndicator"};
  return convert_enum_idx(options, 6, value, "cell_traffic_trace_ies_o::value_c::types");
}

template <class valueT_>
protocol_ie_container_item_s<valueT_>::protocol_ie_container_item_s(uint32_t id_, crit_e crit_) : id(id_), crit(crit_)

{}
template <class valueT_>
SRSASN_CODE protocol_ie_container_item_s<valueT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.pack(bref));
  {
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.pack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
SRSASN_CODE protocol_ie_container_item_s<valueT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  {
    varlength_field_unpack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.unpack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
void protocol_ie_container_item_s<valueT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<cell_traffic_trace_ies_o>;

cell_traffic_trace_ies_container::cell_traffic_trace_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  e_utran_trace_id(86, crit_e::ignore),
  eutran_cgi(100, crit_e::ignore),
  trace_collection_entity_ip_address(131, crit_e::ignore),
  privacy_ind(166, crit_e::ignore)
{}
SRSASN_CODE cell_traffic_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += privacy_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(e_utran_trace_id.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (privacy_ind_present) {
    HANDLE_CODE(privacy_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<cell_traffic_trace_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 86:
        nof_mandatory_ies--;
        e_utran_trace_id.id    = c.id;
        e_utran_trace_id.crit  = c.crit;
        e_utran_trace_id.value = c.value.e_utran_trace_id();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 131:
        nof_mandatory_ies--;
        trace_collection_entity_ip_address.id    = c.id;
        trace_collection_entity_ip_address.crit  = c.crit;
        trace_collection_entity_ip_address.value = c.value.trace_collection_entity_ip_address();
        break;
      case 166:
        privacy_ind_present = true;
        privacy_ind.id      = c.id;
        privacy_ind.crit    = c.crit;
        privacy_ind.value   = c.value.privacy_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void cell_traffic_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  e_utran_trace_id.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  trace_collection_entity_ip_address.to_json(j);
  if (privacy_ind_present) {
    j.write_fieldname("");
    privacy_ind.to_json(j);
  }
  j.end_obj();
}

// CellTrafficTrace ::= SEQUENCE
SRSASN_CODE cell_traffic_trace_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void cell_traffic_trace_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// Cell-Size ::= ENUMERATED
const char* cell_size_opts::to_string() const
{
  static const char* options[] = {"verysmall", "small", "medium", "large"};
  return convert_enum_idx(options, 4, value, "cell_size_e");
}

// CellType ::= SEQUENCE
SRSASN_CODE cell_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cell-Size", cell_size.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RAT-Type ::= ENUMERATED
const char* rat_type_opts::to_string() const
{
  static const char* options[] = {"nbiot"};
  return convert_enum_idx(options, 1, value, "rat_type_e");
}

// SupportedTAs-Item-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t supported_tas_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {232};
  return map_enum_number(options, 1, idx, "id");
}
bool supported_tas_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 232 == id;
}
crit_e supported_tas_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 232) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
supported_tas_item_ext_ies_o::ext_c supported_tas_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 232) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e supported_tas_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 232) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void supported_tas_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("RAT-Type", "nbiot");
  j.end_obj();
}
SRSASN_CODE supported_tas_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_tas_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* supported_tas_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"RAT-Type"};
  return convert_enum_idx(options, 1, value, "supported_tas_item_ext_ies_o::ext_c::types");
}

// SupportedTAs-Item ::= SEQUENCE
SRSASN_CODE supported_tas_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmns, 1, 6, true));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_tas_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmns, bref, 1, 6, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void supported_tas_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tAC", tac.to_string());
  j.start_array("broadcastPLMNs");
  for (const auto& e1 : broadcast_plmns) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ConnectedengNBItem ::= SEQUENCE
SRSASN_CODE connectedeng_nb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(en_g_nb_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, supported_tas, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE connectedeng_nb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(en_g_nb_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(supported_tas, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void connectedeng_nb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("en-gNB-ID", en_g_nb_id.to_string());
  j.start_array("supportedTAs");
  for (const auto& e1 : supported_tas) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GBR-QosInformation-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t gbr_qos_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {255, 256, 257, 258};
  return map_enum_number(options, 4, idx, "id");
}
bool gbr_qos_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {255, 256, 257, 258};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e gbr_qos_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 255:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    case 258:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
gbr_qos_info_ext_ies_o::ext_c gbr_qos_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 255:
      ret.set(ext_c::types::extended_erab_maximum_bitrate_dl);
      break;
    case 256:
      ret.set(ext_c::types::extended_erab_maximum_bitrate_ul);
      break;
    case 257:
      ret.set(ext_c::types::extended_erab_guaranteed_bitrate_dl);
      break;
    case 258:
      ret.set(ext_c::types::extended_erab_guaranteed_bitrate_ul);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e gbr_qos_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 255:
      return presence_e::optional;
    case 256:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    case 258:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void gbr_qos_info_ext_ies_o::ext_c::destroy_() {}
void gbr_qos_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
gbr_qos_info_ext_ies_o::ext_c::ext_c(const gbr_qos_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_erab_maximum_bitrate_dl:
      c.init(other.c.get<uint64_t>());
      break;
    case types::extended_erab_maximum_bitrate_ul:
      c.init(other.c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_dl:
      c.init(other.c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_ul:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gbr_qos_info_ext_ies_o::ext_c");
  }
}
gbr_qos_info_ext_ies_o::ext_c& gbr_qos_info_ext_ies_o::ext_c::operator=(const gbr_qos_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_erab_maximum_bitrate_dl:
      c.set(other.c.get<uint64_t>());
      break;
    case types::extended_erab_maximum_bitrate_ul:
      c.set(other.c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_dl:
      c.set(other.c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_ul:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gbr_qos_info_ext_ies_o::ext_c");
  }

  return *this;
}
uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_maximum_bitrate_dl()
{
  assert_choice_type(types::extended_erab_maximum_bitrate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_maximum_bitrate_ul()
{
  assert_choice_type(types::extended_erab_maximum_bitrate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_guaranteed_bitrate_dl()
{
  assert_choice_type(types::extended_erab_guaranteed_bitrate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_guaranteed_bitrate_ul()
{
  assert_choice_type(types::extended_erab_guaranteed_bitrate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_maximum_bitrate_dl() const
{
  assert_choice_type(types::extended_erab_maximum_bitrate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_maximum_bitrate_ul() const
{
  assert_choice_type(types::extended_erab_maximum_bitrate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_guaranteed_bitrate_dl() const
{
  assert_choice_type(types::extended_erab_guaranteed_bitrate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& gbr_qos_info_ext_ies_o::ext_c::extended_erab_guaranteed_bitrate_ul() const
{
  assert_choice_type(types::extended_erab_guaranteed_bitrate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
void gbr_qos_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_erab_maximum_bitrate_dl:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    case types::extended_erab_maximum_bitrate_ul:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_dl:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    case types::extended_erab_guaranteed_bitrate_ul:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "gbr_qos_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_erab_maximum_bitrate_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_maximum_bitrate_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_guaranteed_bitrate_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_guaranteed_bitrate_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "gbr_qos_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_erab_maximum_bitrate_dl:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_maximum_bitrate_ul:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_guaranteed_bitrate_dl:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_erab_guaranteed_bitrate_ul:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "gbr_qos_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gbr_qos_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (10000000001..4000000000000,...)",
                                  "INTEGER (10000000001..4000000000000,...)",
                                  "INTEGER (10000000001..4000000000000,...)",
                                  "INTEGER (10000000001..4000000000000,...)"};
  return convert_enum_idx(options, 4, value, "gbr_qos_info_ext_ies_o::ext_c::types");
}

// E-RABQoSParameters-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t erab_qos_params_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {273, 274};
  return map_enum_number(options, 2, idx, "id");
}
bool erab_qos_params_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {273, 274};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_qos_params_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 273:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_qos_params_ext_ies_o::ext_c erab_qos_params_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 273:
      ret.set(ext_c::types::dl_packet_loss_rate);
      break;
    case 274:
      ret.set(ext_c::types::ul_packet_loss_rate);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_qos_params_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 273:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_qos_params_ext_ies_o::ext_c::destroy_() {}
void erab_qos_params_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
erab_qos_params_ext_ies_o::ext_c::ext_c(const erab_qos_params_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::dl_packet_loss_rate:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ul_packet_loss_rate:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_qos_params_ext_ies_o::ext_c");
  }
}
erab_qos_params_ext_ies_o::ext_c&
erab_qos_params_ext_ies_o::ext_c::operator=(const erab_qos_params_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::dl_packet_loss_rate:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ul_packet_loss_rate:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_qos_params_ext_ies_o::ext_c");
  }

  return *this;
}
uint16_t& erab_qos_params_ext_ies_o::ext_c::dl_packet_loss_rate()
{
  assert_choice_type(types::dl_packet_loss_rate, type_, "Extension");
  return c.get<uint16_t>();
}
uint16_t& erab_qos_params_ext_ies_o::ext_c::ul_packet_loss_rate()
{
  assert_choice_type(types::ul_packet_loss_rate, type_, "Extension");
  return c.get<uint16_t>();
}
const uint16_t& erab_qos_params_ext_ies_o::ext_c::dl_packet_loss_rate() const
{
  assert_choice_type(types::dl_packet_loss_rate, type_, "Extension");
  return c.get<uint16_t>();
}
const uint16_t& erab_qos_params_ext_ies_o::ext_c::ul_packet_loss_rate() const
{
  assert_choice_type(types::ul_packet_loss_rate, type_, "Extension");
  return c.get<uint16_t>();
}
void erab_qos_params_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dl_packet_loss_rate:
      j.write_int("INTEGER (0..1000)", c.get<uint16_t>());
      break;
    case types::ul_packet_loss_rate:
      j.write_int("INTEGER (0..1000)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "erab_qos_params_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_qos_params_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_packet_loss_rate:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)1000u, false, true));
      break;
    case types::ul_packet_loss_rate:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)1000u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_qos_params_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_packet_loss_rate:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)1000u, false, true));
      break;
    case types::ul_packet_loss_rate:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)1000u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_qos_params_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..1000)", "INTEGER (0..1000)"};
  return convert_enum_idx(options, 2, value, "erab_qos_params_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<gbr_qos_info_ext_ies_o>;

gbr_qos_info_ext_ies_container::gbr_qos_info_ext_ies_container() :
  extended_erab_maximum_bitrate_dl(255, crit_e::ignore),
  extended_erab_maximum_bitrate_ul(256, crit_e::ignore),
  extended_erab_guaranteed_bitrate_dl(257, crit_e::ignore),
  extended_erab_guaranteed_bitrate_ul(258, crit_e::ignore)
{}
SRSASN_CODE gbr_qos_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_erab_maximum_bitrate_dl_present ? 1 : 0;
  nof_ies += extended_erab_maximum_bitrate_ul_present ? 1 : 0;
  nof_ies += extended_erab_guaranteed_bitrate_dl_present ? 1 : 0;
  nof_ies += extended_erab_guaranteed_bitrate_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_erab_maximum_bitrate_dl_present) {
    HANDLE_CODE(extended_erab_maximum_bitrate_dl.pack(bref));
  }
  if (extended_erab_maximum_bitrate_ul_present) {
    HANDLE_CODE(extended_erab_maximum_bitrate_ul.pack(bref));
  }
  if (extended_erab_guaranteed_bitrate_dl_present) {
    HANDLE_CODE(extended_erab_guaranteed_bitrate_dl.pack(bref));
  }
  if (extended_erab_guaranteed_bitrate_ul_present) {
    HANDLE_CODE(extended_erab_guaranteed_bitrate_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<gbr_qos_info_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 255:
        extended_erab_maximum_bitrate_dl_present = true;
        extended_erab_maximum_bitrate_dl.id      = c.id;
        extended_erab_maximum_bitrate_dl.crit    = c.crit;
        extended_erab_maximum_bitrate_dl.ext     = c.ext_value.extended_erab_maximum_bitrate_dl();
        break;
      case 256:
        extended_erab_maximum_bitrate_ul_present = true;
        extended_erab_maximum_bitrate_ul.id      = c.id;
        extended_erab_maximum_bitrate_ul.crit    = c.crit;
        extended_erab_maximum_bitrate_ul.ext     = c.ext_value.extended_erab_maximum_bitrate_ul();
        break;
      case 257:
        extended_erab_guaranteed_bitrate_dl_present = true;
        extended_erab_guaranteed_bitrate_dl.id      = c.id;
        extended_erab_guaranteed_bitrate_dl.crit    = c.crit;
        extended_erab_guaranteed_bitrate_dl.ext     = c.ext_value.extended_erab_guaranteed_bitrate_dl();
        break;
      case 258:
        extended_erab_guaranteed_bitrate_ul_present = true;
        extended_erab_guaranteed_bitrate_ul.id      = c.id;
        extended_erab_guaranteed_bitrate_ul.crit    = c.crit;
        extended_erab_guaranteed_bitrate_ul.ext     = c.ext_value.extended_erab_guaranteed_bitrate_ul();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_erab_maximum_bitrate_dl_present) {
    j.write_fieldname("");
    extended_erab_maximum_bitrate_dl.to_json(j);
  }
  if (extended_erab_maximum_bitrate_ul_present) {
    j.write_fieldname("");
    extended_erab_maximum_bitrate_ul.to_json(j);
  }
  if (extended_erab_guaranteed_bitrate_dl_present) {
    j.write_fieldname("");
    extended_erab_guaranteed_bitrate_dl.to_json(j);
  }
  if (extended_erab_guaranteed_bitrate_ul_present) {
    j.write_fieldname("");
    extended_erab_guaranteed_bitrate_ul.to_json(j);
  }
  j.end_obj();
}

// GBR-QosInformation ::= SEQUENCE
SRSASN_CODE gbr_qos_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_maximum_bitrate_dl, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(pack_integer(bref, erab_maximum_bitrate_ul, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(pack_integer(bref, erab_guaranteed_bitrate_dl, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(pack_integer(bref, erab_guaranteed_bitrate_ul, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_maximum_bitrate_dl, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(unpack_integer(erab_maximum_bitrate_ul, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(unpack_integer(erab_guaranteed_bitrate_dl, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(unpack_integer(erab_guaranteed_bitrate_ul, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-MaximumBitrateDL", erab_maximum_bitrate_dl);
  j.write_int("e-RAB-MaximumBitrateUL", erab_maximum_bitrate_ul);
  j.write_int("e-RAB-GuaranteedBitrateDL", erab_guaranteed_bitrate_dl);
  j.write_int("e-RAB-GuaranteedBitrateUL", erab_guaranteed_bitrate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ScheduledCommunicationTime ::= SEQUENCE
SRSASN_CODE sched_communication_time_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dayof_week_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.pack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_start, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_end, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sched_communication_time_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dayof_week_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.unpack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(unpack_integer(timeof_day_start, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(unpack_integer(timeof_day_end, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sched_communication_time_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dayof_week_present) {
    j.write_str("dayofWeek", dayof_week.to_string());
  }
  if (timeof_day_start_present) {
    j.write_int("timeofDayStart", timeof_day_start);
  }
  if (timeof_day_end_present) {
    j.write_int("timeofDayEnd", timeof_day_end);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CE-ModeBRestricted ::= ENUMERATED
const char* ce_mode_brestricted_opts::to_string() const
{
  static const char* options[] = {"restricted", "not-restricted"};
  return convert_enum_idx(options, 2, value, "ce_mode_brestricted_e");
}

// DL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE dl_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dl-NAS-MAC", dl_nas_mac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ext_field_s<erab_qos_params_ext_ies_o>;

erab_qos_params_ext_ies_container::erab_qos_params_ext_ies_container() :
  dl_packet_loss_rate(273, crit_e::ignore), ul_packet_loss_rate(274, crit_e::ignore)
{}
SRSASN_CODE erab_qos_params_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += dl_packet_loss_rate_present ? 1 : 0;
  nof_ies += ul_packet_loss_rate_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dl_packet_loss_rate_present) {
    HANDLE_CODE(dl_packet_loss_rate.pack(bref));
  }
  if (ul_packet_loss_rate_present) {
    HANDLE_CODE(ul_packet_loss_rate.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_qos_params_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<erab_qos_params_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 273:
        dl_packet_loss_rate_present = true;
        dl_packet_loss_rate.id      = c.id;
        dl_packet_loss_rate.crit    = c.crit;
        dl_packet_loss_rate.ext     = c.ext_value.dl_packet_loss_rate();
        break;
      case 274:
        ul_packet_loss_rate_present = true;
        ul_packet_loss_rate.id      = c.id;
        ul_packet_loss_rate.crit    = c.crit;
        ul_packet_loss_rate.ext     = c.ext_value.ul_packet_loss_rate();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_qos_params_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_packet_loss_rate_present) {
    j.write_fieldname("");
    dl_packet_loss_rate.to_json(j);
  }
  if (ul_packet_loss_rate_present) {
    j.write_fieldname("");
    ul_packet_loss_rate.to_json(j);
  }
  j.end_obj();
}

// E-RABLevelQoSParameters ::= SEQUENCE
SRSASN_CODE erab_level_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qci, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(alloc_retention_prio.pack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_level_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qci, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(alloc_retention_prio.unpack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_level_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qCI", qci);
  j.write_fieldname("allocationRetentionPriority");
  alloc_retention_prio.to_json(j);
  if (gbr_qos_info_present) {
    j.write_fieldname("gbrQosInformation");
    gbr_qos_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EndIndication ::= ENUMERATED
const char* end_ind_opts::to_string() const
{
  static const char* options[] = {"no-further-data", "further-data-exists"};
  return convert_enum_idx(options, 2, value, "end_ind_e");
}

// EnhancedCoverageRestricted ::= ENUMERATED
const char* enhanced_coverage_restricted_opts::to_string() const
{
  static const char* options[] = {"restricted"};
  return convert_enum_idx(options, 1, value, "enhanced_coverage_restricted_e");
}

// Subscription-Based-UE-DifferentiationInfo ::= SEQUENCE
SRSASN_CODE subscription_based_ue_differentiation_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.pack(periodic_time_present, 1));
  HANDLE_CODE(bref.pack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.pack(stationary_ind_present, 1));
  HANDLE_CODE(bref.pack(traffic_profile_present, 1));
  HANDLE_CODE(bref.pack(battery_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.pack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(pack_integer(bref, periodic_time, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.pack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.pack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.pack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE subscription_based_ue_differentiation_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.unpack(periodic_time_present, 1));
  HANDLE_CODE(bref.unpack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.unpack(stationary_ind_present, 1));
  HANDLE_CODE(bref.unpack(traffic_profile_present, 1));
  HANDLE_CODE(bref.unpack(battery_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.unpack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(unpack_integer(periodic_time, bref, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.unpack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.unpack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.unpack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void subscription_based_ue_differentiation_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (periodic_communication_ind_present) {
    j.write_str("periodicCommunicationIndicator", periodic_communication_ind.to_string());
  }
  if (periodic_time_present) {
    j.write_int("periodicTime", periodic_time);
  }
  if (sched_communication_time_present) {
    j.write_fieldname("scheduledCommunicationTime");
    sched_communication_time.to_json(j);
  }
  if (stationary_ind_present) {
    j.write_str("stationaryIndication", stationary_ind.to_string());
  }
  if (traffic_profile_present) {
    j.write_str("trafficProfile", traffic_profile.to_string());
  }
  if (battery_ind_present) {
    j.write_str("batteryIndication", battery_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* subscription_based_ue_differentiation_info_s::periodic_communication_ind_opts::to_string() const
{
  static const char* options[] = {"periodically", "ondemand"};
  return convert_enum_idx(
      options, 2, value, "subscription_based_ue_differentiation_info_s::periodic_communication_ind_e_");
}

const char* subscription_based_ue_differentiation_info_s::stationary_ind_opts::to_string() const
{
  static const char* options[] = {"stationary", "mobile"};
  return convert_enum_idx(options, 2, value, "subscription_based_ue_differentiation_info_s::stationary_ind_e_");
}

const char* subscription_based_ue_differentiation_info_s::traffic_profile_opts::to_string() const
{
  static const char* options[] = {"single-packet", "dual-packets", "multiple-packets"};
  return convert_enum_idx(options, 3, value, "subscription_based_ue_differentiation_info_s::traffic_profile_e_");
}

const char* subscription_based_ue_differentiation_info_s::battery_ind_opts::to_string() const
{
  static const char* options[] = {
      "battery-powered", "battery-powered-not-rechargeable-or-replaceable", "not-battery-powered"};
  return convert_enum_idx(options, 3, value, "subscription_based_ue_differentiation_info_s::battery_ind_e_");
}

// ConnectionEstablishmentIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t conn_establishment_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 74, 251, 253, 271, 280, 278, 252};
  return map_enum_number(options, 9, idx, "id");
}
bool conn_establishment_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 74, 251, 253, 271, 280, 278, 252};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e conn_establishment_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 74:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 253:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    case 280:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 252:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
conn_establishment_ind_ies_o::value_c conn_establishment_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 253:
      ret.set(value_c::types::dl_cp_security_info);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 280:
      ret.set(value_c::types::end_ind);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 252:
      ret.set(value_c::types::ue_level_qos_params);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e conn_establishment_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 74:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 253:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 280:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 252:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void conn_establishment_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::dl_cp_security_info:
      c.destroy<dl_cp_security_info_s>();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    case types::ue_level_qos_params:
      c.destroy<erab_level_qos_params_s>();
      break;
    default:
      break;
  }
}
void conn_establishment_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::dl_cp_security_info:
      c.init<dl_cp_security_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::end_ind:
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::ue_level_qos_params:
      c.init<erab_level_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c::value_c(const conn_establishment_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::dl_cp_security_info:
      c.init(other.c.get<dl_cp_security_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::ue_level_qos_params:
      c.init(other.c.get<erab_level_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c&
conn_establishment_ind_ies_o::value_c::operator=(const conn_establishment_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::dl_cp_security_info:
      c.set(other.c.get<dl_cp_security_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::ue_level_qos_params:
      c.set(other.c.get<erab_level_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& conn_establishment_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& conn_establishment_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
enhanced_coverage_restricted_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info()
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
subscription_based_ue_differentiation_info_s&
conn_establishment_ind_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
erab_level_qos_params_s& conn_establishment_ind_ies_o::value_c::ue_level_qos_params()
{
  assert_choice_type(types::ue_level_qos_params, type_, "Value");
  return c.get<erab_level_qos_params_s>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& conn_establishment_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const enhanced_coverage_restricted_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info() const
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
const ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const subscription_based_ue_differentiation_info_s&
conn_establishment_ind_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const erab_level_qos_params_s& conn_establishment_ind_ies_o::value_c::ue_level_qos_params() const
{
  assert_choice_type(types::ue_level_qos_params, type_, "Value");
  return c.get<erab_level_qos_params_s>();
}
void conn_establishment_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::dl_cp_security_info:
      j.write_fieldname("DL-CP-SecurityInformation");
      c.get<dl_cp_security_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::ue_level_qos_params:
      j.write_fieldname("E-RABLevelQoSParameters");
      c.get<erab_level_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::ue_level_qos_params:
      HANDLE_CODE(c.get<erab_level_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::ue_level_qos_params:
      HANDLE_CODE(c.get<erab_level_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* conn_establishment_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "EnhancedCoverageRestricted",
                                  "DL-CP-SecurityInformation",
                                  "CE-ModeBRestricted",
                                  "EndIndication",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "E-RABLevelQoSParameters"};
  return convert_enum_idx(options, 9, value, "conn_establishment_ind_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<conn_establishment_ind_ies_o>;

conn_establishment_ind_ies_container::conn_establishment_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  ue_radio_cap(74, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  dl_cp_security_info(253, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore),
  end_ind(280, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  ue_level_qos_params(252, crit_e::ignore)
{}
SRSASN_CODE conn_establishment_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += dl_cp_security_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += ue_level_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (dl_cp_security_info_present) {
    HANDLE_CODE(dl_cp_security_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (ue_level_qos_params_present) {
    HANDLE_CODE(ue_level_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<conn_establishment_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 74:
        ue_radio_cap_present = true;
        ue_radio_cap.id      = c.id;
        ue_radio_cap.crit    = c.crit;
        ue_radio_cap.value   = c.value.ue_radio_cap();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 253:
        dl_cp_security_info_present = true;
        dl_cp_security_info.id      = c.id;
        dl_cp_security_info.crit    = c.crit;
        dl_cp_security_info.value   = c.value.dl_cp_security_info();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      case 280:
        end_ind_present = true;
        end_ind.id      = c.id;
        end_ind.crit    = c.crit;
        end_ind.value   = c.value.end_ind();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 252:
        ue_level_qos_params_present = true;
        ue_level_qos_params.id      = c.id;
        ue_level_qos_params.crit    = c.crit;
        ue_level_qos_params.value   = c.value.ue_level_qos_params();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void conn_establishment_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (dl_cp_security_info_present) {
    j.write_fieldname("");
    dl_cp_security_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (ue_level_qos_params_present) {
    j.write_fieldname("");
    ue_level_qos_params.to_json(j);
  }
  j.end_obj();
}

// ConnectionEstablishmentIndication ::= SEQUENCE
SRSASN_CODE conn_establishment_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void conn_establishment_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// ENB-ID ::= CHOICE
void enb_id_c::destroy_()
{
  switch (type_) {
    case types::macro_enb_id:
      c.destroy<fixed_bitstring<20, false, true> >();
      break;
    case types::home_enb_id:
      c.destroy<fixed_bitstring<28, false, true> >();
      break;
    case types::short_macro_enb_id:
      c.destroy<fixed_bitstring<18, false, true> >();
      break;
    case types::long_macro_enb_id:
      c.destroy<fixed_bitstring<21, false, true> >();
      break;
    default:
      break;
  }
}
void enb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::macro_enb_id:
      c.init<fixed_bitstring<20, false, true> >();
      break;
    case types::home_enb_id:
      c.init<fixed_bitstring<28, false, true> >();
      break;
    case types::short_macro_enb_id:
      c.init<fixed_bitstring<18, false, true> >();
      break;
    case types::long_macro_enb_id:
      c.init<fixed_bitstring<21, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c::enb_id_c(const enb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::macro_enb_id:
      c.init(other.c.get<fixed_bitstring<20, false, true> >());
      break;
    case types::home_enb_id:
      c.init(other.c.get<fixed_bitstring<28, false, true> >());
      break;
    case types::short_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<18, false, true> >());
      break;
    case types::long_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<21, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c& enb_id_c::operator=(const enb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::macro_enb_id:
      c.set(other.c.get<fixed_bitstring<20, false, true> >());
      break;
    case types::home_enb_id:
      c.set(other.c.get<fixed_bitstring<28, false, true> >());
      break;
    case types::short_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<18, false, true> >());
      break;
    case types::long_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<21, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& enb_id_c::set_macro_enb_id()
{
  set(types::macro_enb_id);
  return c.get<fixed_bitstring<20, false, true> >();
}
fixed_bitstring<28, false, true>& enb_id_c::set_home_enb_id()
{
  set(types::home_enb_id);
  return c.get<fixed_bitstring<28, false, true> >();
}
fixed_bitstring<18, false, true>& enb_id_c::set_short_macro_enb_id()
{
  set(types::short_macro_enb_id);
  return c.get<fixed_bitstring<18, false, true> >();
}
fixed_bitstring<21, false, true>& enb_id_c::set_long_macro_enb_id()
{
  set(types::long_macro_enb_id);
  return c.get<fixed_bitstring<21, false, true> >();
}
void enb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::macro_enb_id:
      j.write_str("macroENB-ID", c.get<fixed_bitstring<20, false, true> >().to_string());
      break;
    case types::home_enb_id:
      j.write_str("homeENB-ID", c.get<fixed_bitstring<28, false, true> >().to_string());
      break;
    case types::short_macro_enb_id:
      j.write_str("short-macroENB-ID", c.get<fixed_bitstring<18, false, true> >().to_string());
      break;
    case types::long_macro_enb_id:
      j.write_str("long-macroENB-ID", c.get<fixed_bitstring<21, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true> >().pack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true> >().pack(bref)));
      break;
    case types::short_macro_enb_id: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true> >().pack(bref)));
    } break;
    case types::long_macro_enb_id: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true> >().pack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true> >().unpack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true> >().unpack(bref)));
      break;
    case types::short_macro_enb_id: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true> >().unpack(bref)));
    } break;
    case types::long_macro_enb_id: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true> >().unpack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_id_c::types_opts::to_string() const
{
  static const char* options[] = {"macroENB-ID", "homeENB-ID", "short-macroENB-ID", "long-macroENB-ID"};
  return convert_enum_idx(options, 4, value, "enb_id_c::types");
}

// GNB-Identity ::= CHOICE
void gnb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("gNB-ID", c.to_string());
  j.end_obj();
}
SRSASN_CODE gnb_id_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_id_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "gnb_id_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* gnb_id_c::types_opts::to_string() const
{
  static const char* options[] = {"gNB-ID"};
  return convert_enum_idx(options, 1, value, "gnb_id_c::types");
}

// Global-ENB-ID ::= SEQUENCE
SRSASN_CODE global_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_fieldname("eNB-ID");
  enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Global-GNB-ID ::= SEQUENCE
SRSASN_CODE global_gnb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(gnb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_gnb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(gnb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_gnb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_fieldname("gNB-ID");
  gnb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB ::= SEQUENCE
SRSASN_CODE gnb_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_g_nb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_g_nb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-gNB-ID");
  global_g_nb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NG-eNB ::= SEQUENCE
SRSASN_CODE ng_enb_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ng_enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ng_enb_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-ng-eNB-ID");
  global_ng_enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Global-RAN-NODE-ID ::= CHOICE
void global_ran_node_id_c::destroy_()
{
  switch (type_) {
    case types::gnb:
      c.destroy<gnb_s>();
      break;
    case types::ng_enb:
      c.destroy<ng_enb_s>();
      break;
    default:
      break;
  }
}
void global_ran_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb:
      c.init<gnb_s>();
      break;
    case types::ng_enb:
      c.init<ng_enb_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c::global_ran_node_id_c(const global_ran_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb:
      c.init(other.c.get<gnb_s>());
      break;
    case types::ng_enb:
      c.init(other.c.get<ng_enb_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c& global_ran_node_id_c::operator=(const global_ran_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb:
      c.set(other.c.get<gnb_s>());
      break;
    case types::ng_enb:
      c.set(other.c.get<ng_enb_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }

  return *this;
}
gnb_s& global_ran_node_id_c::set_gnb()
{
  set(types::gnb);
  return c.get<gnb_s>();
}
ng_enb_s& global_ran_node_id_c::set_ng_enb()
{
  set(types::ng_enb);
  return c.get<ng_enb_s>();
}
void global_ran_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb:
      j.write_fieldname("gNB");
      c.get<gnb_s>().to_json(j);
      break;
    case types::ng_enb:
      j.write_fieldname("ng-eNB");
      c.get<ng_enb_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ran_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gnb:
      HANDLE_CODE(c.get<gnb_s>().pack(bref));
      break;
    case types::ng_enb:
      HANDLE_CODE(c.get<ng_enb_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ran_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gnb:
      HANDLE_CODE(c.get<gnb_s>().unpack(bref));
      break;
    case types::ng_enb:
      HANDLE_CODE(c.get<ng_enb_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ran_node_id_c::types_opts::to_string() const
{
  static const char* options[] = {"gNB", "ng-eNB"};
  return convert_enum_idx(options, 2, value, "global_ran_node_id_c::types");
}

// ContextatSource ::= SEQUENCE
SRSASN_CODE contextat_source_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_ng_ran_node_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE contextat_source_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_ng_ran_node_id.unpack(bref));
  HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void contextat_source_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceNG-RAN-node-ID");
  source_ng_ran_node_id.to_json(j);
  j.write_int("rAN-UE-NGAP-ID", ran_ue_ngap_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TypeOfError ::= ENUMERATED
const char* type_of_error_opts::to_string() const
{
  static const char* options[] = {"not-understood", "missing"};
  return convert_enum_idx(options, 2, value, "type_of_error_e");
}

// CriticalityDiagnostics-IE-Item ::= SEQUENCE
SRSASN_CODE crit_diagnostics_ie_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iecrit.pack(bref));
  HANDLE_CODE(pack_integer(bref, ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_ie_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iecrit.unpack(bref));
  HANDLE_CODE(unpack_integer(ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_ie_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iECriticality", iecrit.to_string());
  j.write_int("iE-ID", ie_id);
  j.write_str("typeOfError", type_of_error.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TriggeringMessage ::= ENUMERATED
const char* trigger_msg_opts::to_string() const
{
  static const char* options[] = {"initiating-message", "successful-outcome", "unsuccessfull-outcome"};
  return convert_enum_idx(options, 3, value, "trigger_msg_e");
}

// CriticalityDiagnostics ::= SEQUENCE
SRSASN_CODE crit_diagnostics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(proc_code_present, 1));
  HANDLE_CODE(bref.pack(trigger_msg_present, 1));
  HANDLE_CODE(bref.pack(proc_crit_present, 1));
  HANDLE_CODE(bref.pack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.pack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.pack(bref));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ies_crit_diagnostics, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(proc_code_present, 1));
  HANDLE_CODE(bref.unpack(trigger_msg_present, 1));
  HANDLE_CODE(bref.unpack(proc_crit_present, 1));
  HANDLE_CODE(bref.unpack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.unpack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.unpack(bref));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ies_crit_diagnostics, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (proc_code_present) {
    j.write_int("procedureCode", proc_code);
  }
  if (trigger_msg_present) {
    j.write_str("triggeringMessage", trigger_msg.to_string());
  }
  if (proc_crit_present) {
    j.write_str("procedureCriticality", proc_crit.to_string());
  }
  if (ies_crit_diagnostics_present) {
    j.start_array("iEsCriticalityDiagnostics");
    for (const auto& e1 : ies_crit_diagnostics) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DeactivateTraceIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t deactiv_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 86};
  return map_enum_number(options, 3, idx, "id");
}
bool deactiv_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 86};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e deactiv_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
deactiv_trace_ies_o::value_c deactiv_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 86:
      ret.set(value_c::types::e_utran_trace_id);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e deactiv_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void deactiv_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::e_utran_trace_id:
      c.destroy<fixed_octstring<8, true> >();
      break;
    default:
      break;
  }
}
void deactiv_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::e_utran_trace_id:
      c.init<fixed_octstring<8, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c::value_c(const deactiv_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c& deactiv_trace_ies_o::value_c::operator=(const deactiv_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& deactiv_trace_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& deactiv_trace_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::e_utran_trace_id()
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
const uint64_t& deactiv_trace_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& deactiv_trace_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::e_utran_trace_id() const
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
void deactiv_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE deactiv_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* deactiv_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "OCTET STRING"};
  return convert_enum_idx(options, 3, value, "deactiv_trace_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<deactiv_trace_ies_o>;

deactiv_trace_ies_container::deactiv_trace_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), e_utran_trace_id(86, crit_e::ignore)
{}
SRSASN_CODE deactiv_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(e_utran_trace_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<deactiv_trace_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 86:
        nof_mandatory_ies--;
        e_utran_trace_id.id    = c.id;
        e_utran_trace_id.crit  = c.crit;
        e_utran_trace_id.value = c.value.e_utran_trace_id();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void deactiv_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  e_utran_trace_id.to_json(j);
  j.end_obj();
}

// DeactivateTrace ::= SEQUENCE
SRSASN_CODE deactiv_trace_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void deactiv_trace_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// ForbiddenLAs-Item ::= SEQUENCE
SRSASN_CODE forbidden_las_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_lacs, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE forbidden_las_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(forbidden_lacs, bref, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void forbidden_las_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.start_array("forbiddenLACs");
  for (const auto& e1 : forbidden_lacs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ForbiddenTAs-Item ::= SEQUENCE
SRSASN_CODE forbidden_tas_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_tacs, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE forbidden_tas_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(forbidden_tacs, bref, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void forbidden_tas_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.start_array("forbiddenTACs");
  for (const auto& e1 : forbidden_tacs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRrestrictionin5GS ::= ENUMERATED
const char* nrrestrictin5_gs_opts::to_string() const
{
  static const char* options[] = {"nRrestrictedin5GS"};
  return convert_enum_idx(options, 1, value, "nrrestrictin5_gs_e");
}
uint8_t nrrestrictin5_gs_opts::to_number() const
{
  static const uint8_t options[] = {5};
  return map_enum_number(options, 1, value, "nrrestrictin5_gs_e");
}

// NRrestrictioninEPSasSecondaryRAT ::= ENUMERATED
const char* nrrestrictin_ep_sas_secondary_rat_opts::to_string() const
{
  static const char* options[] = {"nRrestrictedinEPSasSecondaryRAT"};
  return convert_enum_idx(options, 1, value, "nrrestrictin_ep_sas_secondary_rat_e");
}

// UnlicensedSpectrumRestriction ::= ENUMERATED
const char* unlicensed_spec_restrict_opts::to_string() const
{
  static const char* options[] = {"unlicensed-restricted"};
  return convert_enum_idx(options, 1, value, "unlicensed_spec_restrict_e");
}

// ForbiddenInterRATs ::= ENUMERATED
const char* forbidden_inter_rats_opts::to_string() const
{
  static const char* options[] = {"all", "geran", "utran", "cdma2000", "geranandutran", "cdma2000andutran"};
  return convert_enum_idx(options, 6, value, "forbidden_inter_rats_e");
}

// HandoverRestrictionList-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t ho_restrict_list_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {261, 270, 282, 287, 290};
  return map_enum_number(options, 5, idx, "id");
}
bool ho_restrict_list_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {261, 270, 282, 287, 290};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_restrict_list_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 261:
      return crit_e::ignore;
    case 270:
      return crit_e::ignore;
    case 282:
      return crit_e::ignore;
    case 287:
      return crit_e::ignore;
    case 290:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_restrict_list_ext_ies_o::ext_c ho_restrict_list_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 261:
      ret.set(ext_c::types::nrrestrictin_ep_sas_secondary_rat);
      break;
    case 270:
      ret.set(ext_c::types::unlicensed_spec_restrict);
      break;
    case 282:
      ret.set(ext_c::types::cn_type_restricts);
      break;
    case 287:
      ret.set(ext_c::types::nrrestrictin5_gs);
      break;
    case 290:
      ret.set(ext_c::types::last_ng_ranplmn_id);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_restrict_list_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 261:
      return presence_e::optional;
    case 270:
      return presence_e::optional;
    case 282:
      return presence_e::optional;
    case 287:
      return presence_e::optional;
    case 290:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ho_restrict_list_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::cn_type_restricts:
      c.destroy<cn_type_restricts_l>();
      break;
    case types::last_ng_ranplmn_id:
      c.destroy<plm_nid>();
      break;
    default:
      break;
  }
}
void ho_restrict_list_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      break;
    case types::unlicensed_spec_restrict:
      break;
    case types::cn_type_restricts:
      c.init<cn_type_restricts_l>();
      break;
    case types::nrrestrictin5_gs:
      break;
    case types::last_ng_ranplmn_id:
      c.init<plm_nid>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
  }
}
ho_restrict_list_ext_ies_o::ext_c::ext_c(const ho_restrict_list_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      c.init(other.c.get<nrrestrictin_ep_sas_secondary_rat_e>());
      break;
    case types::unlicensed_spec_restrict:
      c.init(other.c.get<unlicensed_spec_restrict_e>());
      break;
    case types::cn_type_restricts:
      c.init(other.c.get<cn_type_restricts_l>());
      break;
    case types::nrrestrictin5_gs:
      c.init(other.c.get<nrrestrictin5_gs_e>());
      break;
    case types::last_ng_ranplmn_id:
      c.init(other.c.get<plm_nid>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
  }
}
ho_restrict_list_ext_ies_o::ext_c&
ho_restrict_list_ext_ies_o::ext_c::operator=(const ho_restrict_list_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      c.set(other.c.get<nrrestrictin_ep_sas_secondary_rat_e>());
      break;
    case types::unlicensed_spec_restrict:
      c.set(other.c.get<unlicensed_spec_restrict_e>());
      break;
    case types::cn_type_restricts:
      c.set(other.c.get<cn_type_restricts_l>());
      break;
    case types::nrrestrictin5_gs:
      c.set(other.c.get<nrrestrictin5_gs_e>());
      break;
    case types::last_ng_ranplmn_id:
      c.set(other.c.get<plm_nid>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
  }

  return *this;
}
nrrestrictin_ep_sas_secondary_rat_e& ho_restrict_list_ext_ies_o::ext_c::nrrestrictin_ep_sas_secondary_rat()
{
  assert_choice_type(types::nrrestrictin_ep_sas_secondary_rat, type_, "Extension");
  return c.get<nrrestrictin_ep_sas_secondary_rat_e>();
}
unlicensed_spec_restrict_e& ho_restrict_list_ext_ies_o::ext_c::unlicensed_spec_restrict()
{
  assert_choice_type(types::unlicensed_spec_restrict, type_, "Extension");
  return c.get<unlicensed_spec_restrict_e>();
}
cn_type_restricts_l& ho_restrict_list_ext_ies_o::ext_c::cn_type_restricts()
{
  assert_choice_type(types::cn_type_restricts, type_, "Extension");
  return c.get<cn_type_restricts_l>();
}
nrrestrictin5_gs_e& ho_restrict_list_ext_ies_o::ext_c::nrrestrictin5_gs()
{
  assert_choice_type(types::nrrestrictin5_gs, type_, "Extension");
  return c.get<nrrestrictin5_gs_e>();
}
plm_nid& ho_restrict_list_ext_ies_o::ext_c::last_ng_ranplmn_id()
{
  assert_choice_type(types::last_ng_ranplmn_id, type_, "Extension");
  return c.get<plm_nid>();
}
const nrrestrictin_ep_sas_secondary_rat_e& ho_restrict_list_ext_ies_o::ext_c::nrrestrictin_ep_sas_secondary_rat() const
{
  assert_choice_type(types::nrrestrictin_ep_sas_secondary_rat, type_, "Extension");
  return c.get<nrrestrictin_ep_sas_secondary_rat_e>();
}
const unlicensed_spec_restrict_e& ho_restrict_list_ext_ies_o::ext_c::unlicensed_spec_restrict() const
{
  assert_choice_type(types::unlicensed_spec_restrict, type_, "Extension");
  return c.get<unlicensed_spec_restrict_e>();
}
const cn_type_restricts_l& ho_restrict_list_ext_ies_o::ext_c::cn_type_restricts() const
{
  assert_choice_type(types::cn_type_restricts, type_, "Extension");
  return c.get<cn_type_restricts_l>();
}
const nrrestrictin5_gs_e& ho_restrict_list_ext_ies_o::ext_c::nrrestrictin5_gs() const
{
  assert_choice_type(types::nrrestrictin5_gs, type_, "Extension");
  return c.get<nrrestrictin5_gs_e>();
}
const plm_nid& ho_restrict_list_ext_ies_o::ext_c::last_ng_ranplmn_id() const
{
  assert_choice_type(types::last_ng_ranplmn_id, type_, "Extension");
  return c.get<plm_nid>();
}
void ho_restrict_list_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      j.write_str("NRrestrictioninEPSasSecondaryRAT", "nRrestrictedinEPSasSecondaryRAT");
      break;
    case types::unlicensed_spec_restrict:
      j.write_str("UnlicensedSpectrumRestriction", "unlicensed-restricted");
      break;
    case types::cn_type_restricts:
      j.start_array("CNTypeRestrictions");
      for (const auto& e1 : c.get<cn_type_restricts_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nrrestrictin5_gs:
      j.write_str("NRrestrictionin5GS", "nRrestrictedin5GS");
      break;
    case types::last_ng_ranplmn_id:
      j.write_str("PLMNidentity", c.get<plm_nid>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_restrict_list_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      HANDLE_CODE(c.get<nrrestrictin_ep_sas_secondary_rat_e>().pack(bref));
      break;
    case types::unlicensed_spec_restrict:
      HANDLE_CODE(c.get<unlicensed_spec_restrict_e>().pack(bref));
      break;
    case types::cn_type_restricts:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cn_type_restricts_l>(), 1, 16, true));
      break;
    case types::nrrestrictin5_gs:
      HANDLE_CODE(c.get<nrrestrictin5_gs_e>().pack(bref));
      break;
    case types::last_ng_ranplmn_id:
      HANDLE_CODE(c.get<plm_nid>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_restrict_list_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nrrestrictin_ep_sas_secondary_rat:
      HANDLE_CODE(c.get<nrrestrictin_ep_sas_secondary_rat_e>().unpack(bref));
      break;
    case types::unlicensed_spec_restrict:
      HANDLE_CODE(c.get<unlicensed_spec_restrict_e>().unpack(bref));
      break;
    case types::cn_type_restricts:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cn_type_restricts_l>(), bref, 1, 16, true));
      break;
    case types::nrrestrictin5_gs:
      HANDLE_CODE(c.get<nrrestrictin5_gs_e>().unpack(bref));
      break;
    case types::last_ng_ranplmn_id:
      HANDLE_CODE(c.get<plm_nid>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_restrict_list_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"NRrestrictioninEPSasSecondaryRAT",
                                  "UnlicensedSpectrumRestriction",
                                  "CNTypeRestrictions",
                                  "NRrestrictionin5GS",
                                  "PLMNidentity"};
  return convert_enum_idx(options, 5, value, "ho_restrict_list_ext_ies_o::ext_c::types");
}
uint8_t ho_restrict_list_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == nrrestrictin5_gs) {
    return 5;
  }
  invalid_enum_number(value, "ho_restrict_list_ext_ies_o::ext_c::types");
  return 0;
}

// DLNASPDUDeliveryAckRequest ::= ENUMERATED
const char* dlnaspdu_delivery_ack_request_opts::to_string() const
{
  static const char* options[] = {"requested"};
  return convert_enum_idx(options, 1, value, "dlnaspdu_delivery_ack_request_e");
}

template struct asn1::s1ap::protocol_ext_field_s<ho_restrict_list_ext_ies_o>;

ho_restrict_list_ext_ies_container::ho_restrict_list_ext_ies_container() :
  nrrestrictin_ep_sas_secondary_rat(261, crit_e::ignore),
  unlicensed_spec_restrict(270, crit_e::ignore),
  cn_type_restricts(282, crit_e::ignore),
  nrrestrictin5_gs(287, crit_e::ignore),
  last_ng_ranplmn_id(290, crit_e::ignore)
{}
SRSASN_CODE ho_restrict_list_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += nrrestrictin_ep_sas_secondary_rat_present ? 1 : 0;
  nof_ies += unlicensed_spec_restrict_present ? 1 : 0;
  nof_ies += cn_type_restricts_present ? 1 : 0;
  nof_ies += nrrestrictin5_gs_present ? 1 : 0;
  nof_ies += last_ng_ranplmn_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (nrrestrictin_ep_sas_secondary_rat_present) {
    HANDLE_CODE(nrrestrictin_ep_sas_secondary_rat.pack(bref));
  }
  if (unlicensed_spec_restrict_present) {
    HANDLE_CODE(unlicensed_spec_restrict.pack(bref));
  }
  if (cn_type_restricts_present) {
    HANDLE_CODE(cn_type_restricts.pack(bref));
  }
  if (nrrestrictin5_gs_present) {
    HANDLE_CODE(nrrestrictin5_gs.pack(bref));
  }
  if (last_ng_ranplmn_id_present) {
    HANDLE_CODE(last_ng_ranplmn_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_restrict_list_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<ho_restrict_list_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 261:
        nrrestrictin_ep_sas_secondary_rat_present = true;
        nrrestrictin_ep_sas_secondary_rat.id      = c.id;
        nrrestrictin_ep_sas_secondary_rat.crit    = c.crit;
        nrrestrictin_ep_sas_secondary_rat.ext     = c.ext_value.nrrestrictin_ep_sas_secondary_rat();
        break;
      case 270:
        unlicensed_spec_restrict_present = true;
        unlicensed_spec_restrict.id      = c.id;
        unlicensed_spec_restrict.crit    = c.crit;
        unlicensed_spec_restrict.ext     = c.ext_value.unlicensed_spec_restrict();
        break;
      case 282:
        cn_type_restricts_present = true;
        cn_type_restricts.id      = c.id;
        cn_type_restricts.crit    = c.crit;
        cn_type_restricts.ext     = c.ext_value.cn_type_restricts();
        break;
      case 287:
        nrrestrictin5_gs_present = true;
        nrrestrictin5_gs.id      = c.id;
        nrrestrictin5_gs.crit    = c.crit;
        nrrestrictin5_gs.ext     = c.ext_value.nrrestrictin5_gs();
        break;
      case 290:
        last_ng_ranplmn_id_present = true;
        last_ng_ranplmn_id.id      = c.id;
        last_ng_ranplmn_id.crit    = c.crit;
        last_ng_ranplmn_id.ext     = c.ext_value.last_ng_ranplmn_id();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ho_restrict_list_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (nrrestrictin_ep_sas_secondary_rat_present) {
    j.write_fieldname("");
    nrrestrictin_ep_sas_secondary_rat.to_json(j);
  }
  if (unlicensed_spec_restrict_present) {
    j.write_fieldname("");
    unlicensed_spec_restrict.to_json(j);
  }
  if (cn_type_restricts_present) {
    j.write_fieldname("");
    cn_type_restricts.to_json(j);
  }
  if (nrrestrictin5_gs_present) {
    j.write_fieldname("");
    nrrestrictin5_gs.to_json(j);
  }
  if (last_ng_ranplmn_id_present) {
    j.write_fieldname("");
    last_ng_ranplmn_id.to_json(j);
  }
  j.end_obj();
}

// HandoverRestrictionList ::= SEQUENCE
SRSASN_CODE ho_restrict_list_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(equivalent_plmns_present, 1));
  HANDLE_CODE(bref.pack(forbidden_tas_present, 1));
  HANDLE_CODE(bref.pack(forbidden_las_present, 1));
  HANDLE_CODE(bref.pack(forbidden_inter_rats_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  if (equivalent_plmns_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, equivalent_plmns, 1, 15, true));
  }
  if (forbidden_tas_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_tas, 1, 16, true));
  }
  if (forbidden_las_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_las, 1, 16, true));
  }
  if (forbidden_inter_rats_present) {
    HANDLE_CODE(forbidden_inter_rats.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_restrict_list_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(equivalent_plmns_present, 1));
  HANDLE_CODE(bref.unpack(forbidden_tas_present, 1));
  HANDLE_CODE(bref.unpack(forbidden_las_present, 1));
  HANDLE_CODE(bref.unpack(forbidden_inter_rats_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  if (equivalent_plmns_present) {
    HANDLE_CODE(unpack_dyn_seq_of(equivalent_plmns, bref, 1, 15, true));
  }
  if (forbidden_tas_present) {
    HANDLE_CODE(unpack_dyn_seq_of(forbidden_tas, bref, 1, 16, true));
  }
  if (forbidden_las_present) {
    HANDLE_CODE(unpack_dyn_seq_of(forbidden_las, bref, 1, 16, true));
  }
  if (forbidden_inter_rats_present) {
    HANDLE_CODE(forbidden_inter_rats.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_restrict_list_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("servingPLMN", serving_plmn.to_string());
  if (equivalent_plmns_present) {
    j.start_array("equivalentPLMNs");
    for (const auto& e1 : equivalent_plmns) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (forbidden_tas_present) {
    j.start_array("forbiddenTAs");
    for (const auto& e1 : forbidden_tas) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (forbidden_las_present) {
    j.start_array("forbiddenLAs");
    for (const auto& e1 : forbidden_las) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (forbidden_inter_rats_present) {
    j.write_str("forbiddenInterRATs", forbidden_inter_rats.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRUESecurityCapabilities ::= SEQUENCE
SRSASN_CODE nrue_security_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nrencryption_algorithms.pack(bref));
  HANDLE_CODE(nrintegrity_protection_algorithms.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nrue_security_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nrencryption_algorithms.unpack(bref));
  HANDLE_CODE(nrintegrity_protection_algorithms.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nrue_security_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRencryptionAlgorithms", nrencryption_algorithms.to_string());
  j.write_str("nRintegrityProtectionAlgorithms", nrintegrity_protection_algorithms.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PendingDataIndication ::= ENUMERATED
const char* pending_data_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "pending_data_ind_e");
}

// SRVCCOperationPossible ::= ENUMERATED
const char* srvcc_operation_possible_opts::to_string() const
{
  static const char* options[] = {"possible"};
  return convert_enum_idx(options, 1, value, "srvcc_operation_possible_e");
}

// UECapabilityInfoRequest ::= ENUMERATED
const char* ue_cap_info_request_opts::to_string() const
{
  static const char* options[] = {"requested"};
  return convert_enum_idx(options, 1, value, "ue_cap_info_request_e");
}

// DownlinkNASTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t dl_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 26, 41, 106, 124, 74, 249, 251, 269, 271, 275, 280, 283, 278, 299};
  return map_enum_number(options, 16, idx, "id");
}
bool dl_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 26, 41, 106, 124, 74, 249, 251, 269, 271, 275, 280, 283, 278, 299};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 41:
      return crit_e::ignore;
    case 106:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 74:
      return crit_e::ignore;
    case 249:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    case 275:
      return crit_e::ignore;
    case 280:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
dl_nas_transport_ies_o::value_c dl_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 26:
      ret.set(value_c::types::nas_pdu);
      break;
    case 41:
      ret.set(value_c::types::ho_restrict_list);
      break;
    case 106:
      ret.set(value_c::types::subscriber_profile_idfor_rfp);
      break;
    case 124:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 249:
      ret.set(value_c::types::dlnaspdu_delivery_ack_request);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 275:
      ret.set(value_c::types::ue_cap_info_request);
      break;
    case 280:
      ret.set(value_c::types::end_ind);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 299:
      ret.set(value_c::types::add_rrm_prio_idx);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e dl_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 106:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 74:
      return presence_e::optional;
    case 249:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 275:
      return presence_e::optional;
    case 280:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ho_restrict_list:
      c.destroy<ho_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    default:
      break;
  }
}
void dl_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ho_restrict_list:
      c.init<ho_restrict_list_s>();
      break;
    case types::subscriber_profile_idfor_rfp:
      break;
    case types::srvcc_operation_possible:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::dlnaspdu_delivery_ack_request:
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_cap_info_request:
      break;
    case types::end_ind:
      break;
    case types::pending_data_ind:
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c::value_c(const dl_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ho_restrict_list:
      c.init(other.c.get<ho_restrict_list_s>());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::dlnaspdu_delivery_ack_request:
      c.init(other.c.get<dlnaspdu_delivery_ack_request_e>());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_cap_info_request:
      c.init(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c&
dl_nas_transport_ies_o::value_c::operator=(const dl_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ho_restrict_list:
      c.set(other.c.get<ho_restrict_list_s>());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::dlnaspdu_delivery_ack_request:
      c.set(other.c.get<dlnaspdu_delivery_ack_request_e>());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_cap_info_request:
      c.set(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_nas_transport_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& dl_nas_transport_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
ho_restrict_list_s& dl_nas_transport_ies_o::value_c::ho_restrict_list()
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
uint16_t& dl_nas_transport_ies_o::value_c::subscriber_profile_idfor_rfp()
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
dlnaspdu_delivery_ack_request_e& dl_nas_transport_ies_o::value_c::dlnaspdu_delivery_ack_request()
{
  assert_choice_type(types::dlnaspdu_delivery_ack_request, type_, "Value");
  return c.get<dlnaspdu_delivery_ack_request_e>();
}
enhanced_coverage_restricted_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
nrue_security_cap_s& dl_nas_transport_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request()
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
end_ind_e& dl_nas_transport_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
pending_data_ind_e& dl_nas_transport_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
subscription_based_ue_differentiation_info_s&
dl_nas_transport_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
fixed_bitstring<32, false, true>& dl_nas_transport_ies_o::value_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
const uint64_t& dl_nas_transport_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& dl_nas_transport_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const ho_restrict_list_s& dl_nas_transport_ies_o::value_c::ho_restrict_list() const
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::subscriber_profile_idfor_rfp() const
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
const srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const dlnaspdu_delivery_ack_request_e& dl_nas_transport_ies_o::value_c::dlnaspdu_delivery_ack_request() const
{
  assert_choice_type(types::dlnaspdu_delivery_ack_request, type_, "Value");
  return c.get<dlnaspdu_delivery_ack_request_e>();
}
const enhanced_coverage_restricted_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const nrue_security_cap_s& dl_nas_transport_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request() const
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
const end_ind_e& dl_nas_transport_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const pending_data_ind_e& dl_nas_transport_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const subscription_based_ue_differentiation_info_s&
dl_nas_transport_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const fixed_bitstring<32, false, true>& dl_nas_transport_ies_o::value_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
void dl_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ho_restrict_list:
      j.write_fieldname("HandoverRestrictionList");
      c.get<ho_restrict_list_s>().to_json(j);
      break;
    case types::subscriber_profile_idfor_rfp:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", "possible");
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::dlnaspdu_delivery_ack_request:
      j.write_str("DLNASPDUDeliveryAckRequest", "requested");
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_cap_info_request:
      j.write_str("UECapabilityInfoRequest", "requested");
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().pack(bref));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::dlnaspdu_delivery_ack_request:
      HANDLE_CODE(c.get<dlnaspdu_delivery_ack_request_e>().pack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().unpack(bref));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::dlnaspdu_delivery_ack_request:
      HANDLE_CODE(c.get<dlnaspdu_delivery_ack_request_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "HandoverRestrictionList",
                                  "INTEGER (1..256)",
                                  "SRVCCOperationPossible",
                                  "OCTET STRING",
                                  "DLNASPDUDeliveryAckRequest",
                                  "EnhancedCoverageRestricted",
                                  "NRUESecurityCapabilities",
                                  "CE-ModeBRestricted",
                                  "UECapabilityInfoRequest",
                                  "EndIndication",
                                  "PendingDataIndication",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "BIT STRING"};
  return convert_enum_idx(options, 16, value, "dl_nas_transport_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<dl_nas_transport_ies_o>;

dl_nas_transport_ies_container::dl_nas_transport_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  nas_pdu(26, crit_e::reject),
  ho_restrict_list(41, crit_e::ignore),
  subscriber_profile_idfor_rfp(106, crit_e::ignore),
  srvcc_operation_possible(124, crit_e::ignore),
  ue_radio_cap(74, crit_e::ignore),
  dlnaspdu_delivery_ack_request(249, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore),
  ue_cap_info_request(275, crit_e::ignore),
  end_ind(280, crit_e::ignore),
  pending_data_ind(283, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore)
{}
SRSASN_CODE dl_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_restrict_list_present ? 1 : 0;
  nof_ies += subscriber_profile_idfor_rfp_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += dlnaspdu_delivery_ack_request_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_cap_info_request_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  if (ho_restrict_list_present) {
    HANDLE_CODE(ho_restrict_list.pack(bref));
  }
  if (subscriber_profile_idfor_rfp_present) {
    HANDLE_CODE(subscriber_profile_idfor_rfp.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (dlnaspdu_delivery_ack_request_present) {
    HANDLE_CODE(dlnaspdu_delivery_ack_request.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_cap_info_request_present) {
    HANDLE_CODE(ue_cap_info_request.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<dl_nas_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 26:
        nof_mandatory_ies--;
        nas_pdu.id    = c.id;
        nas_pdu.crit  = c.crit;
        nas_pdu.value = c.value.nas_pdu();
        break;
      case 41:
        ho_restrict_list_present = true;
        ho_restrict_list.id      = c.id;
        ho_restrict_list.crit    = c.crit;
        ho_restrict_list.value   = c.value.ho_restrict_list();
        break;
      case 106:
        subscriber_profile_idfor_rfp_present = true;
        subscriber_profile_idfor_rfp.id      = c.id;
        subscriber_profile_idfor_rfp.crit    = c.crit;
        subscriber_profile_idfor_rfp.value   = c.value.subscriber_profile_idfor_rfp();
        break;
      case 124:
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = c.id;
        srvcc_operation_possible.crit    = c.crit;
        srvcc_operation_possible.value   = c.value.srvcc_operation_possible();
        break;
      case 74:
        ue_radio_cap_present = true;
        ue_radio_cap.id      = c.id;
        ue_radio_cap.crit    = c.crit;
        ue_radio_cap.value   = c.value.ue_radio_cap();
        break;
      case 249:
        dlnaspdu_delivery_ack_request_present = true;
        dlnaspdu_delivery_ack_request.id      = c.id;
        dlnaspdu_delivery_ack_request.crit    = c.crit;
        dlnaspdu_delivery_ack_request.value   = c.value.dlnaspdu_delivery_ack_request();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      case 275:
        ue_cap_info_request_present = true;
        ue_cap_info_request.id      = c.id;
        ue_cap_info_request.crit    = c.crit;
        ue_cap_info_request.value   = c.value.ue_cap_info_request();
        break;
      case 280:
        end_ind_present = true;
        end_ind.id      = c.id;
        end_ind.crit    = c.crit;
        end_ind.value   = c.value.end_ind();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.value   = c.value.add_rrm_prio_idx();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  if (ho_restrict_list_present) {
    j.write_fieldname("");
    ho_restrict_list.to_json(j);
  }
  if (subscriber_profile_idfor_rfp_present) {
    j.write_fieldname("");
    subscriber_profile_idfor_rfp.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (dlnaspdu_delivery_ack_request_present) {
    j.write_fieldname("");
    dlnaspdu_delivery_ack_request.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_cap_info_request_present) {
    j.write_fieldname("");
    ue_cap_info_request.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  j.end_obj();
}

// DownlinkNASTransport ::= SEQUENCE
SRSASN_CODE dl_nas_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void dl_nas_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// DownlinkNonUEAssociatedLPPaTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t dl_non_ueassociated_lp_pa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {148, 147};
  return map_enum_number(options, 2, idx, "id");
}
bool dl_non_ueassociated_lp_pa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {148, 147};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_non_ueassociated_lp_pa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 148:
      return crit_e::reject;
    case 147:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
dl_non_ueassociated_lp_pa_transport_ies_o::value_c
dl_non_ueassociated_lp_pa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 148:
      ret.set(value_c::types::routing_id);
      break;
    case 147:
      ret.set(value_c::types::lp_pa_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e dl_non_ueassociated_lp_pa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 148:
      return presence_e::mandatory;
    case 147:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_non_ueassociated_lp_pa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::lp_pa_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void dl_non_ueassociated_lp_pa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      break;
    case types::lp_pa_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
dl_non_ueassociated_lp_pa_transport_ies_o::value_c::value_c(
    const dl_non_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
dl_non_ueassociated_lp_pa_transport_ies_o::value_c& dl_non_ueassociated_lp_pa_transport_ies_o::value_c::operator=(
    const dl_non_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }

  return *this;
}
uint16_t& dl_non_ueassociated_lp_pa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_non_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu()
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint16_t& dl_non_ueassociated_lp_pa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_non_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu() const
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void dl_non_ueassociated_lp_pa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_non_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..255)", "OCTET STRING"};
  return convert_enum_idx(options, 2, value, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c::types");
}
uint8_t dl_non_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {0};
  return map_enum_number(options, 1, value, "dl_non_ueassociated_lp_pa_transport_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<dl_non_ueassociated_lp_pa_transport_ies_o>;

dl_non_ueassociated_lp_pa_transport_ies_container::dl_non_ueassociated_lp_pa_transport_ies_container() :
  routing_id(148, crit_e::reject), lp_pa_pdu(147, crit_e::reject)
{}
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(lp_pa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<dl_non_ueassociated_lp_pa_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 148:
        nof_mandatory_ies--;
        routing_id.id    = c.id;
        routing_id.crit  = c.crit;
        routing_id.value = c.value.routing_id();
        break;
      case 147:
        nof_mandatory_ies--;
        lp_pa_pdu.id    = c.id;
        lp_pa_pdu.crit  = c.crit;
        lp_pa_pdu.value = c.value.lp_pa_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_non_ueassociated_lp_pa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  lp_pa_pdu.to_json(j);
  j.end_obj();
}

// DownlinkNonUEAssociatedLPPaTransport ::= SEQUENCE
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ueassociated_lp_pa_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void dl_non_ueassociated_lp_pa_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABDataForwardingItem ::= SEQUENCE
SRSASN_CODE erab_data_forwarding_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_transport_layer_address_present, 1));
  HANDLE_CODE(bref.pack(dl_g_tp_teid_present, 1));
  HANDLE_CODE(bref.pack(ul_transport_layer_address_present, 1));
  HANDLE_CODE(bref.pack(ul_gtp_teid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_transport_layer_address_present) {
    HANDLE_CODE(dl_transport_layer_address.pack(bref));
  }
  if (dl_g_tp_teid_present) {
    HANDLE_CODE(dl_g_tp_teid.pack(bref));
  }
  if (ul_transport_layer_address_present) {
    HANDLE_CODE(ul_transport_layer_address.pack(bref));
  }
  if (ul_gtp_teid_present) {
    HANDLE_CODE(ul_gtp_teid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_data_forwarding_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_transport_layer_address_present, 1));
  HANDLE_CODE(bref.unpack(dl_g_tp_teid_present, 1));
  HANDLE_CODE(bref.unpack(ul_transport_layer_address_present, 1));
  HANDLE_CODE(bref.unpack(ul_gtp_teid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_transport_layer_address_present) {
    HANDLE_CODE(dl_transport_layer_address.unpack(bref));
  }
  if (dl_g_tp_teid_present) {
    HANDLE_CODE(dl_g_tp_teid.unpack(bref));
  }
  if (ul_transport_layer_address_present) {
    HANDLE_CODE(ul_transport_layer_address.unpack(bref));
  }
  if (ul_gtp_teid_present) {
    HANDLE_CODE(ul_gtp_teid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_data_forwarding_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (dl_transport_layer_address_present) {
    j.write_str("dL-transportLayerAddress", dl_transport_layer_address.to_string());
  }
  if (dl_g_tp_teid_present) {
    j.write_str("dL-gTP-TEID", dl_g_tp_teid.to_string());
  }
  if (ul_transport_layer_address_present) {
    j.write_str("uL-TransportLayerAddress", ul_transport_layer_address.to_string());
  }
  if (ul_gtp_teid_present) {
    j.write_str("uL-GTP-TEID", ul_gtp_teid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABDataForwardingItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_data_forwarding_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {14};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_data_forwarding_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 14 == id;
}
crit_e erab_data_forwarding_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 14) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_data_forwarding_item_ies_o::value_c erab_data_forwarding_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 14) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_data_forwarding_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 14) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_data_forwarding_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABDataForwardingItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_data_forwarding_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_data_forwarding_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_data_forwarding_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABDataForwardingItem"};
  return convert_enum_idx(options, 1, value, "erab_data_forwarding_item_ies_o::value_c::types");
}

// Cdma2000HOStatus ::= ENUMERATED
const char* cdma2000_ho_status_opts::to_string() const
{
  static const char* options[] = {"hOSuccess", "hOFailure"};
  return convert_enum_idx(options, 2, value, "cdma2000_ho_status_e");
}

// Cdma2000RATType ::= ENUMERATED
const char* cdma2000_rat_type_opts::to_string() const
{
  static const char* options[] = {"hRPD", "onexRTT"};
  return convert_enum_idx(options, 2, value, "cdma2000_rat_type_e");
}
uint8_t cdma2000_rat_type_opts::to_number() const
{
  if (value == onex_rtt) {
    return 1;
  }
  invalid_enum_number(value, "cdma2000_rat_type_e");
  return 0;
}

// DownlinkS1cdma2000tunnellingIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t dl_s1cdma2000tunnelling_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 12, 83, 71, 70};
  return map_enum_number(options, 6, idx, "id");
}
bool dl_s1cdma2000tunnelling_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 12, 83, 71, 70};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_s1cdma2000tunnelling_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 83:
      return crit_e::ignore;
    case 71:
      return crit_e::reject;
    case 70:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
dl_s1cdma2000tunnelling_ies_o::value_c dl_s1cdma2000tunnelling_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 12:
      ret.set(value_c::types::erab_subjectto_data_forwarding_list);
      break;
    case 83:
      ret.set(value_c::types::cdma2000_ho_status);
      break;
    case 71:
      ret.set(value_c::types::cdma2000_rat_type);
      break;
    case 70:
      ret.set(value_c::types::cdma2000_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e dl_s1cdma2000tunnelling_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 12:
      return presence_e::optional;
    case 83:
      return presence_e::optional;
    case 71:
      return presence_e::mandatory;
    case 70:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_s1cdma2000tunnelling_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_subjectto_data_forwarding_list:
      c.destroy<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
      break;
    case types::cdma2000_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void dl_s1cdma2000tunnelling_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.init<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
      break;
    case types::cdma2000_ho_status:
      break;
    case types::cdma2000_rat_type:
      break;
    case types::cdma2000_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
  }
}
dl_s1cdma2000tunnelling_ies_o::value_c::value_c(const dl_s1cdma2000tunnelling_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.init(other.c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >());
      break;
    case types::cdma2000_ho_status:
      c.init(other.c.get<cdma2000_ho_status_e>());
      break;
    case types::cdma2000_rat_type:
      c.init(other.c.get<cdma2000_rat_type_e>());
      break;
    case types::cdma2000_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
  }
}
dl_s1cdma2000tunnelling_ies_o::value_c&
dl_s1cdma2000tunnelling_ies_o::value_c::operator=(const dl_s1cdma2000tunnelling_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.set(other.c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >());
      break;
    case types::cdma2000_ho_status:
      c.set(other.c.get<cdma2000_ho_status_e>());
      break;
    case types::cdma2000_rat_type:
      c.set(other.c.get<cdma2000_rat_type_e>());
      break;
    case types::cdma2000_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_s1cdma2000tunnelling_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& dl_s1cdma2000tunnelling_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_data_forwarding_item_ies_o>&
dl_s1cdma2000tunnelling_ies_o::value_c::erab_subjectto_data_forwarding_list()
{
  assert_choice_type(types::erab_subjectto_data_forwarding_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
}
cdma2000_ho_status_e& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_ho_status()
{
  assert_choice_type(types::cdma2000_ho_status, type_, "Value");
  return c.get<cdma2000_ho_status_e>();
}
cdma2000_rat_type_e& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_rat_type()
{
  assert_choice_type(types::cdma2000_rat_type, type_, "Value");
  return c.get<cdma2000_rat_type_e>();
}
unbounded_octstring<true>& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_pdu()
{
  assert_choice_type(types::cdma2000_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint64_t& dl_s1cdma2000tunnelling_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& dl_s1cdma2000tunnelling_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_data_forwarding_item_ies_o>&
dl_s1cdma2000tunnelling_ies_o::value_c::erab_subjectto_data_forwarding_list() const
{
  assert_choice_type(types::erab_subjectto_data_forwarding_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
}
const cdma2000_ho_status_e& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_ho_status() const
{
  assert_choice_type(types::cdma2000_ho_status, type_, "Value");
  return c.get<cdma2000_ho_status_e>();
}
const cdma2000_rat_type_e& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_rat_type() const
{
  assert_choice_type(types::cdma2000_rat_type, type_, "Value");
  return c.get<cdma2000_rat_type_e>();
}
const unbounded_octstring<true>& dl_s1cdma2000tunnelling_ies_o::value_c::cdma2000_pdu() const
{
  assert_choice_type(types::cdma2000_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void dl_s1cdma2000tunnelling_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_subjectto_data_forwarding_list:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABDataForwardingItemIEs}}");
      break;
    case types::cdma2000_ho_status:
      j.write_str("Cdma2000HOStatus", c.get<cdma2000_ho_status_e>().to_string());
      break;
    case types::cdma2000_rat_type:
      j.write_str("Cdma2000RATType", c.get<cdma2000_rat_type_e>().to_string());
      break;
    case types::cdma2000_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_s1cdma2000tunnelling_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_subjectto_data_forwarding_list:
      HANDLE_CODE(
          pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >(), 1, 256, true));
      break;
    case types::cdma2000_ho_status:
      HANDLE_CODE(c.get<cdma2000_ho_status_e>().pack(bref));
      break;
    case types::cdma2000_rat_type:
      HANDLE_CODE(c.get<cdma2000_rat_type_e>().pack(bref));
      break;
    case types::cdma2000_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_s1cdma2000tunnelling_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_subjectto_data_forwarding_list:
      HANDLE_CODE(
          unpack_dyn_seq_of(c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >(), bref, 1, 256, true));
      break;
    case types::cdma2000_ho_status:
      HANDLE_CODE(c.get<cdma2000_ho_status_e>().unpack(bref));
      break;
    case types::cdma2000_rat_type:
      HANDLE_CODE(c.get<cdma2000_rat_type_e>().unpack(bref));
      break;
    case types::cdma2000_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_s1cdma2000tunnelling_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_s1cdma2000tunnelling_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABDataForwardingItemIEs}}",
                                  "Cdma2000HOStatus",
                                  "Cdma2000RATType",
                                  "OCTET STRING"};
  return convert_enum_idx(options, 6, value, "dl_s1cdma2000tunnelling_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<dl_s1cdma2000tunnelling_ies_o>;

dl_s1cdma2000tunnelling_ies_container::dl_s1cdma2000tunnelling_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  erab_subjectto_data_forwarding_list(12, crit_e::ignore),
  cdma2000_ho_status(83, crit_e::ignore),
  cdma2000_rat_type(71, crit_e::reject),
  cdma2000_pdu(70, crit_e::reject)
{}
SRSASN_CODE dl_s1cdma2000tunnelling_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += erab_subjectto_data_forwarding_list_present ? 1 : 0;
  nof_ies += cdma2000_ho_status_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_subjectto_data_forwarding_list_present) {
    HANDLE_CODE(erab_subjectto_data_forwarding_list.pack(bref));
  }
  if (cdma2000_ho_status_present) {
    HANDLE_CODE(cdma2000_ho_status.pack(bref));
  }
  HANDLE_CODE(cdma2000_rat_type.pack(bref));
  HANDLE_CODE(cdma2000_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_s1cdma2000tunnelling_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<dl_s1cdma2000tunnelling_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 12:
        erab_subjectto_data_forwarding_list_present = true;
        erab_subjectto_data_forwarding_list.id      = c.id;
        erab_subjectto_data_forwarding_list.crit    = c.crit;
        erab_subjectto_data_forwarding_list.value   = c.value.erab_subjectto_data_forwarding_list();
        break;
      case 83:
        cdma2000_ho_status_present = true;
        cdma2000_ho_status.id      = c.id;
        cdma2000_ho_status.crit    = c.crit;
        cdma2000_ho_status.value   = c.value.cdma2000_ho_status();
        break;
      case 71:
        nof_mandatory_ies--;
        cdma2000_rat_type.id    = c.id;
        cdma2000_rat_type.crit  = c.crit;
        cdma2000_rat_type.value = c.value.cdma2000_rat_type();
        break;
      case 70:
        nof_mandatory_ies--;
        cdma2000_pdu.id    = c.id;
        cdma2000_pdu.crit  = c.crit;
        cdma2000_pdu.value = c.value.cdma2000_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_s1cdma2000tunnelling_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_subjectto_data_forwarding_list_present) {
    j.write_fieldname("");
    erab_subjectto_data_forwarding_list.to_json(j);
  }
  if (cdma2000_ho_status_present) {
    j.write_fieldname("");
    cdma2000_ho_status.to_json(j);
  }
  j.write_fieldname("");
  cdma2000_rat_type.to_json(j);
  j.write_fieldname("");
  cdma2000_pdu.to_json(j);
  j.end_obj();
}

// DownlinkS1cdma2000tunnelling ::= SEQUENCE
SRSASN_CODE dl_s1cdma2000tunnelling_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_s1cdma2000tunnelling_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void dl_s1cdma2000tunnelling_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// DownlinkUEAssociatedLPPaTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t dl_ueassociated_lp_pa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 148, 147};
  return map_enum_number(options, 4, idx, "id");
}
bool dl_ueassociated_lp_pa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 148, 147};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ueassociated_lp_pa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 147:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
dl_ueassociated_lp_pa_transport_ies_o::value_c dl_ueassociated_lp_pa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 148:
      ret.set(value_c::types::routing_id);
      break;
    case 147:
      ret.set(value_c::types::lp_pa_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e dl_ueassociated_lp_pa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 147:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ueassociated_lp_pa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::lp_pa_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void dl_ueassociated_lp_pa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::routing_id:
      break;
    case types::lp_pa_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
dl_ueassociated_lp_pa_transport_ies_o::value_c::value_c(const dl_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
dl_ueassociated_lp_pa_transport_ies_o::value_c&
dl_ueassociated_lp_pa_transport_ies_o::value_c::operator=(const dl_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
uint16_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu()
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint64_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const uint16_t& dl_ueassociated_lp_pa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu() const
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void dl_ueassociated_lp_pa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::routing_id:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ueassociated_lp_pa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ueassociated_lp_pa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "INTEGER (0..255)", "OCTET STRING"};
  return convert_enum_idx(options, 4, value, "dl_ueassociated_lp_pa_transport_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<dl_ueassociated_lp_pa_transport_ies_o>;

dl_ueassociated_lp_pa_transport_ies_container::dl_ueassociated_lp_pa_transport_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  routing_id(148, crit_e::reject),
  lp_pa_pdu(147, crit_e::reject)
{}
SRSASN_CODE dl_ueassociated_lp_pa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(lp_pa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ueassociated_lp_pa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<dl_ueassociated_lp_pa_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 148:
        nof_mandatory_ies--;
        routing_id.id    = c.id;
        routing_id.crit  = c.crit;
        routing_id.value = c.value.routing_id();
        break;
      case 147:
        nof_mandatory_ies--;
        lp_pa_pdu.id    = c.id;
        lp_pa_pdu.crit  = c.crit;
        lp_pa_pdu.value = c.value.lp_pa_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ueassociated_lp_pa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  lp_pa_pdu.to_json(j);
  j.end_obj();
}

// DownlinkUEAssociatedLPPaTransport ::= SEQUENCE
SRSASN_CODE dl_ueassociated_lp_pa_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ueassociated_lp_pa_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void dl_ueassociated_lp_pa_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABAdmittedItem ::= SEQUENCE
SRSASN_CODE erab_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_transport_layer_address_present, 1));
  HANDLE_CODE(bref.pack(dl_g_tp_teid_present, 1));
  HANDLE_CODE(bref.pack(ul_transport_layer_address_present, 1));
  HANDLE_CODE(bref.pack(ul_gtp_teid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (dl_transport_layer_address_present) {
    HANDLE_CODE(dl_transport_layer_address.pack(bref));
  }
  if (dl_g_tp_teid_present) {
    HANDLE_CODE(dl_g_tp_teid.pack(bref));
  }
  if (ul_transport_layer_address_present) {
    HANDLE_CODE(ul_transport_layer_address.pack(bref));
  }
  if (ul_gtp_teid_present) {
    HANDLE_CODE(ul_gtp_teid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_transport_layer_address_present, 1));
  HANDLE_CODE(bref.unpack(dl_g_tp_teid_present, 1));
  HANDLE_CODE(bref.unpack(ul_transport_layer_address_present, 1));
  HANDLE_CODE(bref.unpack(ul_gtp_teid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (dl_transport_layer_address_present) {
    HANDLE_CODE(dl_transport_layer_address.unpack(bref));
  }
  if (dl_g_tp_teid_present) {
    HANDLE_CODE(dl_g_tp_teid.unpack(bref));
  }
  if (ul_transport_layer_address_present) {
    HANDLE_CODE(ul_transport_layer_address.unpack(bref));
  }
  if (ul_gtp_teid_present) {
    HANDLE_CODE(ul_gtp_teid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (dl_transport_layer_address_present) {
    j.write_str("dL-transportLayerAddress", dl_transport_layer_address.to_string());
  }
  if (dl_g_tp_teid_present) {
    j.write_str("dL-gTP-TEID", dl_g_tp_teid.to_string());
  }
  if (ul_transport_layer_address_present) {
    j.write_str("uL-TransportLayerAddress", ul_transport_layer_address.to_string());
  }
  if (ul_gtp_teid_present) {
    j.write_str("uL-GTP-TEID", ul_gtp_teid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABAdmittedItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_admitted_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {20};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_admitted_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 20 == id;
}
crit_e erab_admitted_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 20) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_admitted_item_ies_o::value_c erab_admitted_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 20) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_admitted_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 20) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_admitted_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABAdmittedItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_admitted_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_admitted_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_admitted_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABAdmittedItem"};
  return convert_enum_idx(options, 1, value, "erab_admitted_item_ies_o::value_c::types");
}

// E-RABFailedToResumeItemResumeReq ::= SEQUENCE
SRSASN_CODE erab_failed_to_resume_item_resume_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failed_to_resume_item_resume_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_failed_to_resume_item_resume_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABFailedToResumeItemResumeReqIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_failed_to_resume_item_resume_req_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {236};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_failed_to_resume_item_resume_req_ies_o::is_id_valid(const uint32_t& id)
{
  return 236 == id;
}
crit_e erab_failed_to_resume_item_resume_req_ies_o::get_crit(const uint32_t& id)
{
  if (id == 236) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_failed_to_resume_item_resume_req_ies_o::value_c
erab_failed_to_resume_item_resume_req_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 236) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_failed_to_resume_item_resume_req_ies_o::get_presence(const uint32_t& id)
{
  if (id == 236) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_failed_to_resume_item_resume_req_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABFailedToResumeItemResumeReq");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_failed_to_resume_item_resume_req_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failed_to_resume_item_resume_req_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_failed_to_resume_item_resume_req_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABFailedToResumeItemResumeReq"};
  return convert_enum_idx(options, 1, value, "erab_failed_to_resume_item_resume_req_ies_o::value_c::types");
}

// E-RABFailedToResumeItemResumeRes ::= SEQUENCE
SRSASN_CODE erab_failed_to_resume_item_resume_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failed_to_resume_item_resume_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_failed_to_resume_item_resume_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABFailedToResumeItemResumeResIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_failed_to_resume_item_resume_res_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {238};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_failed_to_resume_item_resume_res_ies_o::is_id_valid(const uint32_t& id)
{
  return 238 == id;
}
crit_e erab_failed_to_resume_item_resume_res_ies_o::get_crit(const uint32_t& id)
{
  if (id == 238) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_failed_to_resume_item_resume_res_ies_o::value_c
erab_failed_to_resume_item_resume_res_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 238) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_failed_to_resume_item_resume_res_ies_o::get_presence(const uint32_t& id)
{
  if (id == 238) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_failed_to_resume_item_resume_res_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABFailedToResumeItemResumeRes");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_failed_to_resume_item_resume_res_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failed_to_resume_item_resume_res_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_failed_to_resume_item_resume_res_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABFailedToResumeItemResumeRes"};
  return convert_enum_idx(options, 1, value, "erab_failed_to_resume_item_resume_res_ies_o::value_c::types");
}

// E-RABFailedToSetupItemHOReqAck ::= SEQUENCE
SRSASN_CODE erab_failed_to_setup_item_ho_req_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failed_to_setup_item_ho_req_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_failed_to_setup_item_ho_req_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABFailedtoSetupItemHOReqAckIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_failedto_setup_item_ho_req_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {21};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_failedto_setup_item_ho_req_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 21 == id;
}
crit_e erab_failedto_setup_item_ho_req_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 21) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_failedto_setup_item_ho_req_ack_ies_o::value_c
erab_failedto_setup_item_ho_req_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 21) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_failedto_setup_item_ho_req_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 21) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_failedto_setup_item_ho_req_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABFailedToSetupItemHOReqAck");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_failedto_setup_item_ho_req_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_failedto_setup_item_ho_req_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_failedto_setup_item_ho_req_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABFailedToSetupItemHOReqAck"};
  return convert_enum_idx(options, 1, value, "erab_failedto_setup_item_ho_req_ack_ies_o::value_c::types");
}

// DL-Forwarding ::= ENUMERATED
const char* dl_forwarding_opts::to_string() const
{
  static const char* options[] = {"dL-Forwarding-proposed"};
  return convert_enum_idx(options, 1, value, "dl_forwarding_e");
}

// E-RABInformationListItem ::= SEQUENCE
SRSASN_CODE erab_info_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_info_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (dl_forwarding_present) {
    j.write_str("dL-Forwarding", "dL-Forwarding-proposed");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABInformationListIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_info_list_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {78};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_info_list_ies_o::is_id_valid(const uint32_t& id)
{
  return 78 == id;
}
crit_e erab_info_list_ies_o::get_crit(const uint32_t& id)
{
  if (id == 78) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_info_list_ies_o::value_c erab_info_list_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 78) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_info_list_ies_o::get_presence(const uint32_t& id)
{
  if (id == 78) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_info_list_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABInformationListItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_info_list_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_list_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_info_list_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABInformationListItem"};
  return convert_enum_idx(options, 1, value, "erab_info_list_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_info_list_ies_o>;

// E-RABItem ::= SEQUENCE
SRSASN_CODE erab_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {35};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 35 == id;
}
crit_e erab_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 35) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_item_ies_o::value_c erab_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 35) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 35) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABItem"};
  return convert_enum_idx(options, 1, value, "erab_item_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_item_ies_o>;

// E-RABModifyItemBearerModConf ::= SEQUENCE
SRSASN_CODE erab_modify_item_bearer_mod_conf_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_item_bearer_mod_conf_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_modify_item_bearer_mod_conf_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABModifyItemBearerModConfIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_modify_item_bearer_mod_conf_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {204};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_modify_item_bearer_mod_conf_ies_o::is_id_valid(const uint32_t& id)
{
  return 204 == id;
}
crit_e erab_modify_item_bearer_mod_conf_ies_o::get_crit(const uint32_t& id)
{
  if (id == 204) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_modify_item_bearer_mod_conf_ies_o::value_c erab_modify_item_bearer_mod_conf_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 204) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_modify_item_bearer_mod_conf_ies_o::get_presence(const uint32_t& id)
{
  if (id == 204) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_modify_item_bearer_mod_conf_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABModifyItemBearerModConf");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_modify_item_bearer_mod_conf_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_item_bearer_mod_conf_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_modify_item_bearer_mod_conf_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABModifyItemBearerModConf"};
  return convert_enum_idx(options, 1, value, "erab_modify_item_bearer_mod_conf_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_modify_item_bearer_mod_conf_ies_o>;

// E-RABModificationConfirmIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_mod_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 203, 205, 210, 58, 146};
  return map_enum_number(options, 7, idx, "id");
}
bool erab_mod_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 203, 205, 210, 58, 146};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_mod_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_mod_confirm_ies_o::value_c erab_mod_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 203:
      ret.set(value_c::types::erab_modify_list_bearer_mod_conf);
      break;
    case 205:
      ret.set(value_c::types::erab_failed_to_modify_list_bearer_mod_conf);
      break;
    case 210:
      ret.set(value_c::types::erab_to_be_released_list_bearer_mod_conf);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_mod_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 203:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_mod_confirm_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_modify_list_bearer_mod_conf:
      c.destroy<erab_modify_list_bearer_mod_conf_l>();
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      c.destroy<erab_list_l>();
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      c.destroy<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void erab_mod_confirm_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_modify_list_bearer_mod_conf:
      c.init<erab_modify_list_bearer_mod_conf_l>();
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      c.init<erab_list_l>();
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      c.init<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::csg_membership_status:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
  }
}
erab_mod_confirm_ies_o::value_c::value_c(const erab_mod_confirm_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_conf:
      c.init(other.c.get<erab_modify_list_bearer_mod_conf_l>());
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
  }
}
erab_mod_confirm_ies_o::value_c&
erab_mod_confirm_ies_o::value_c::operator=(const erab_mod_confirm_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_conf:
      c.set(other.c.get<erab_modify_list_bearer_mod_conf_l>());
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_mod_confirm_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_mod_confirm_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_modify_list_bearer_mod_conf_l& erab_mod_confirm_ies_o::value_c::erab_modify_list_bearer_mod_conf()
{
  assert_choice_type(types::erab_modify_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_modify_list_bearer_mod_conf_l>();
}
erab_list_l& erab_mod_confirm_ies_o::value_c::erab_failed_to_modify_list_bearer_mod_conf()
{
  assert_choice_type(types::erab_failed_to_modify_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_list_l>();
}
erab_list_l& erab_mod_confirm_ies_o::value_c::erab_to_be_released_list_bearer_mod_conf()
{
  assert_choice_type(types::erab_to_be_released_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_list_l>();
}
crit_diagnostics_s& erab_mod_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
csg_membership_status_e& erab_mod_confirm_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const uint64_t& erab_mod_confirm_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_mod_confirm_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_modify_list_bearer_mod_conf_l& erab_mod_confirm_ies_o::value_c::erab_modify_list_bearer_mod_conf() const
{
  assert_choice_type(types::erab_modify_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_modify_list_bearer_mod_conf_l>();
}
const erab_list_l& erab_mod_confirm_ies_o::value_c::erab_failed_to_modify_list_bearer_mod_conf() const
{
  assert_choice_type(types::erab_failed_to_modify_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_list_l>();
}
const erab_list_l& erab_mod_confirm_ies_o::value_c::erab_to_be_released_list_bearer_mod_conf() const
{
  assert_choice_type(types::erab_to_be_released_list_bearer_mod_conf, type_, "Value");
  return c.get<erab_list_l>();
}
const crit_diagnostics_s& erab_mod_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const csg_membership_status_e& erab_mod_confirm_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
void erab_mod_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_conf:
      j.start_array("E-RABModifyListBearerModConf");
      for (const auto& e1 : c.get<erab_modify_list_bearer_mod_conf_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_mod_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_modify_list_bearer_mod_conf:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_modify_list_bearer_mod_conf_l>(), 1, 256, true));
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_modify_list_bearer_mod_conf:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_modify_list_bearer_mod_conf_l>(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_modify_list_bearer_mod_conf:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::erab_to_be_released_list_bearer_mod_conf:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_mod_confirm_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABModifyListBearerModConf",
                                  "E-RABList",
                                  "E-RABList",
                                  "CriticalityDiagnostics",
                                  "CSGMembershipStatus"};
  return convert_enum_idx(options, 7, value, "erab_mod_confirm_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_mod_confirm_ies_o>;

erab_mod_confirm_ies_container::erab_mod_confirm_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_modify_list_bearer_mod_conf(203, crit_e::ignore),
  erab_failed_to_modify_list_bearer_mod_conf(205, crit_e::ignore),
  erab_to_be_released_list_bearer_mod_conf(210, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  csg_membership_status(146, crit_e::ignore)
{}
SRSASN_CODE erab_mod_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_modify_list_bearer_mod_conf_present ? 1 : 0;
  nof_ies += erab_failed_to_modify_list_bearer_mod_conf_present ? 1 : 0;
  nof_ies += erab_to_be_released_list_bearer_mod_conf_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_modify_list_bearer_mod_conf_present) {
    HANDLE_CODE(erab_modify_list_bearer_mod_conf.pack(bref));
  }
  if (erab_failed_to_modify_list_bearer_mod_conf_present) {
    HANDLE_CODE(erab_failed_to_modify_list_bearer_mod_conf.pack(bref));
  }
  if (erab_to_be_released_list_bearer_mod_conf_present) {
    HANDLE_CODE(erab_to_be_released_list_bearer_mod_conf.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_mod_confirm_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 203:
        erab_modify_list_bearer_mod_conf_present = true;
        erab_modify_list_bearer_mod_conf.id      = c.id;
        erab_modify_list_bearer_mod_conf.crit    = c.crit;
        erab_modify_list_bearer_mod_conf.value   = c.value.erab_modify_list_bearer_mod_conf();
        break;
      case 205:
        erab_failed_to_modify_list_bearer_mod_conf_present = true;
        erab_failed_to_modify_list_bearer_mod_conf.id      = c.id;
        erab_failed_to_modify_list_bearer_mod_conf.crit    = c.crit;
        erab_failed_to_modify_list_bearer_mod_conf.value   = c.value.erab_failed_to_modify_list_bearer_mod_conf();
        break;
      case 210:
        erab_to_be_released_list_bearer_mod_conf_present = true;
        erab_to_be_released_list_bearer_mod_conf.id      = c.id;
        erab_to_be_released_list_bearer_mod_conf.crit    = c.crit;
        erab_to_be_released_list_bearer_mod_conf.value   = c.value.erab_to_be_released_list_bearer_mod_conf();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_mod_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_modify_list_bearer_mod_conf_present) {
    j.write_fieldname("");
    erab_modify_list_bearer_mod_conf.to_json(j);
  }
  if (erab_failed_to_modify_list_bearer_mod_conf_present) {
    j.write_fieldname("");
    erab_failed_to_modify_list_bearer_mod_conf.to_json(j);
  }
  if (erab_to_be_released_list_bearer_mod_conf_present) {
    j.write_fieldname("");
    erab_to_be_released_list_bearer_mod_conf.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  j.end_obj();
}

// E-RABModificationConfirm ::= SEQUENCE
SRSASN_CODE erab_mod_confirm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_confirm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_mod_confirm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABUsageReportItem ::= SEQUENCE
SRSASN_CODE erabusage_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(start_timestamp.pack(bref));
  HANDLE_CODE(end_timestamp.pack(bref));
  HANDLE_CODE(pack_integer(bref, usage_count_ul, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(pack_integer(bref, usage_count_dl, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erabusage_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(start_timestamp.unpack(bref));
  HANDLE_CODE(end_timestamp.unpack(bref));
  HANDLE_CODE(unpack_integer(usage_count_ul, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(unpack_integer(usage_count_dl, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erabusage_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("startTimestamp", start_timestamp.to_string());
  j.write_str("endTimestamp", end_timestamp.to_string());
  j.write_int("usageCountUL", usage_count_ul);
  j.write_int("usageCountDL", usage_count_dl);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABUsageReportItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erabusage_report_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {267};
  return map_enum_number(options, 1, idx, "id");
}
bool erabusage_report_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 267 == id;
}
crit_e erabusage_report_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 267) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erabusage_report_item_ies_o::value_c erabusage_report_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 267) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erabusage_report_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 267) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erabusage_report_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABUsageReportItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erabusage_report_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erabusage_report_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erabusage_report_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABUsageReportItem"};
  return convert_enum_idx(options, 1, value, "erabusage_report_item_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erabusage_report_item_ies_o>;

// NR-CGI ::= SEQUENCE
SRSASN_CODE nr_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(nrcell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(nrcell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("nRCellIdentity", nrcell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecondaryRATType ::= ENUMERATED
const char* secondary_rat_type_opts::to_string() const
{
  static const char* options[] = {"nR", "unlicensed"};
  return convert_enum_idx(options, 2, value, "secondary_rat_type_e");
}

// E-RABNotToBeModifiedItemBearerModInd ::= SEQUENCE
SRSASN_CODE erab_not_to_be_modified_item_bearer_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(dl_gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_not_to_be_modified_item_bearer_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(dl_gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_not_to_be_modified_item_bearer_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("dL-GTP-TEID", dl_gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeModifiedItemBearerModInd ::= SEQUENCE
SRSASN_CODE erab_to_be_modified_item_bearer_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(dl_gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(dl_gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_modified_item_bearer_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("dL-GTP-TEID", dl_gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PSCellInformation ::= SEQUENCE
SRSASN_CODE ps_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ncgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ps_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ncgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ps_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nCGI");
  ncgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecondaryRATDataUsageReportItem ::= SEQUENCE
SRSASN_CODE secondary_rat_data_usage_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(secondary_rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, erabusage_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(secondary_rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(erabusage_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("secondaryRATType", secondary_rat_type.to_string());
  j.start_array("e-RABUsageReportList");
  for (const auto& e1 : erabusage_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABNotToBeModifiedItemBearerModIndIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_not_to_be_modified_item_bearer_mod_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {202};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_not_to_be_modified_item_bearer_mod_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 202 == id;
}
crit_e erab_not_to_be_modified_item_bearer_mod_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 202) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c
erab_not_to_be_modified_item_bearer_mod_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 202) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_not_to_be_modified_item_bearer_mod_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 202) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABNotToBeModifiedItemBearerModInd");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABNotToBeModifiedItemBearerModInd"};
  return convert_enum_idx(options, 1, value, "erab_not_to_be_modified_item_bearer_mod_ind_ies_o::value_c::types");
}

// E-RABToBeModifiedItemBearerModIndIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_modified_item_bearer_mod_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {200};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_modified_item_bearer_mod_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 200 == id;
}
crit_e erab_to_be_modified_item_bearer_mod_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 200) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c
erab_to_be_modified_item_bearer_mod_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 200) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_modified_item_bearer_mod_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 200) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeModifiedItemBearerModInd");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeModifiedItemBearerModInd"};
  return convert_enum_idx(options, 1, value, "erab_to_be_modified_item_bearer_mod_ind_ies_o::value_c::types");
}

// SecondaryRATDataUsageReportItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {265};
  return map_enum_number(options, 1, idx, "id");
}
bool secondary_rat_data_usage_report_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 265 == id;
}
crit_e secondary_rat_data_usage_report_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 265) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
secondary_rat_data_usage_report_item_ies_o::value_c
secondary_rat_data_usage_report_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 265) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 265) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SecondaryRATDataUsageReportItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* secondary_rat_data_usage_report_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"SecondaryRATDataUsageReportItem"};
  return convert_enum_idx(options, 1, value, "secondary_rat_data_usage_report_item_ies_o::value_c::types");
}

// UserLocationInformation-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t user_location_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {288};
  return map_enum_number(options, 1, idx, "id");
}
bool user_location_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 288 == id;
}
crit_e user_location_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 288) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
user_location_info_ext_ies_o::ext_c user_location_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 288) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 288) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("PSCellInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"PSCellInformation"};
  return convert_enum_idx(options, 1, value, "user_location_info_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<secondary_rat_data_usage_report_item_ies_o>;

// TunnelInformation ::= SEQUENCE
SRSASN_CODE tunnel_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(udp_port_num_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.pack(bref));
  if (udp_port_num_present) {
    HANDLE_CODE(udp_port_num.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tunnel_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(udp_port_num_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.unpack(bref));
  if (udp_port_num_present) {
    HANDLE_CODE(udp_port_num.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tunnel_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  if (udp_port_num_present) {
    j.write_str("uDP-Port-Number", udp_port_num.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UserLocationInformation ::= SEQUENCE
SRSASN_CODE user_location_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutran_cgi.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eutran-cgi");
  eutran_cgi.to_json(j);
  j.write_fieldname("tai");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// E-RABModificationIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_mod_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 199, 201, 226, 176, 264, 189};
  return map_enum_number(options, 8, idx, "id");
}
bool erab_mod_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 199, 201, 226, 176, 264, 189};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_mod_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 199:
      return crit_e::reject;
    case 201:
      return crit_e::reject;
    case 226:
      return crit_e::reject;
    case 176:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_mod_ind_ies_o::value_c erab_mod_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 199:
      ret.set(value_c::types::erab_to_be_modified_list_bearer_mod_ind);
      break;
    case 201:
      ret.set(value_c::types::erab_not_to_be_modified_list_bearer_mod_ind);
      break;
    case 226:
      ret.set(value_c::types::csg_membership_info);
      break;
    case 176:
      ret.set(value_c::types::tunnel_info_for_bbf);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_mod_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 199:
      return presence_e::mandatory;
    case 201:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 176:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 189:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_mod_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_to_be_modified_list_bearer_mod_ind:
      c.destroy<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >();
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      c.destroy<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >();
      break;
    case types::csg_membership_info:
      c.destroy<csg_membership_info_s>();
      break;
    case types::tunnel_info_for_bbf:
      c.destroy<tunnel_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    default:
      break;
  }
}
void erab_mod_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      c.init<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >();
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      c.init<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >();
      break;
    case types::csg_membership_info:
      c.init<csg_membership_info_s>();
      break;
    case types::tunnel_info_for_bbf:
      c.init<tunnel_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
  }
}
erab_mod_ind_ies_o::value_c::value_c(const erab_mod_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      c.init(other.c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >());
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      c.init(other.c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >());
      break;
    case types::csg_membership_info:
      c.init(other.c.get<csg_membership_info_s>());
      break;
    case types::tunnel_info_for_bbf:
      c.init(other.c.get<tunnel_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
  }
}
erab_mod_ind_ies_o::value_c& erab_mod_ind_ies_o::value_c::operator=(const erab_mod_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      c.set(other.c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >());
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      c.set(other.c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >());
      break;
    case types::csg_membership_info:
      c.set(other.c.get<csg_membership_info_s>());
      break;
    case types::tunnel_info_for_bbf:
      c.set(other.c.get<tunnel_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_mod_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_mod_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o>&
erab_mod_ind_ies_o::value_c::erab_to_be_modified_list_bearer_mod_ind()
{
  assert_choice_type(types::erab_to_be_modified_list_bearer_mod_ind, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >();
}
erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o>&
erab_mod_ind_ies_o::value_c::erab_not_to_be_modified_list_bearer_mod_ind()
{
  assert_choice_type(types::erab_not_to_be_modified_list_bearer_mod_ind, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >();
}
csg_membership_info_s& erab_mod_ind_ies_o::value_c::csg_membership_info()
{
  assert_choice_type(types::csg_membership_info, type_, "Value");
  return c.get<csg_membership_info_s>();
}
tunnel_info_s& erab_mod_ind_ies_o::value_c::tunnel_info_for_bbf()
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
secondary_rat_data_usage_report_list_l& erab_mod_ind_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
user_location_info_s& erab_mod_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const uint64_t& erab_mod_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_mod_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o>&
erab_mod_ind_ies_o::value_c::erab_to_be_modified_list_bearer_mod_ind() const
{
  assert_choice_type(types::erab_to_be_modified_list_bearer_mod_ind, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >();
}
const erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o>&
erab_mod_ind_ies_o::value_c::erab_not_to_be_modified_list_bearer_mod_ind() const
{
  assert_choice_type(types::erab_not_to_be_modified_list_bearer_mod_ind, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >();
}
const csg_membership_info_s& erab_mod_ind_ies_o::value_c::csg_membership_info() const
{
  assert_choice_type(types::csg_membership_info, type_, "Value");
  return c.get<csg_membership_info_s>();
}
const tunnel_info_s& erab_mod_ind_ies_o::value_c::tunnel_info_for_bbf() const
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
const secondary_rat_data_usage_report_list_l& erab_mod_ind_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const user_location_info_s& erab_mod_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
void erab_mod_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABToBeModifiedItemBearerModIndIEs}}");
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABNotToBeModifiedItemBearerModIndIEs}}");
      break;
    case types::csg_membership_info:
      j.write_fieldname("CSGMembershipInfo");
      c.get<csg_membership_info_s>().to_json(j);
      break;
    case types::tunnel_info_for_bbf:
      j.write_fieldname("TunnelInformation");
      c.get<tunnel_info_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_mod_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(
          bref, c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >(), 1, 256, true));
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(
          bref, c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >(), 1, 256, true));
      break;
    case types::csg_membership_info:
      HANDLE_CODE(c.get<csg_membership_info_s>().pack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_to_be_modified_list_bearer_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_to_be_modified_item_bearer_mod_ind_ies_o> >(), bref, 1, 256, true));
      break;
    case types::erab_not_to_be_modified_list_bearer_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_not_to_be_modified_item_bearer_mod_ind_ies_o> >(), bref, 1, 256, true));
      break;
    case types::csg_membership_info:
      HANDLE_CODE(c.get<csg_membership_info_s>().unpack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_mod_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_mod_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABToBeModifiedItemBearerModIndIEs}}",
                                  "E-RAB-IE-ContainerList{{E-RABNotToBeModifiedItemBearerModIndIEs}}",
                                  "CSGMembershipInfo",
                                  "TunnelInformation",
                                  "SecondaryRATDataUsageReportList",
                                  "UserLocationInformation"};
  return convert_enum_idx(options, 8, value, "erab_mod_ind_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_mod_ind_ies_o>;

erab_mod_ind_ies_container::erab_mod_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  erab_to_be_modified_list_bearer_mod_ind(199, crit_e::reject),
  erab_not_to_be_modified_list_bearer_mod_ind(201, crit_e::reject),
  csg_membership_info(226, crit_e::reject),
  tunnel_info_for_bbf(176, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore),
  user_location_info(189, crit_e::ignore)
{}
SRSASN_CODE erab_mod_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += erab_not_to_be_modified_list_bearer_mod_ind_present ? 1 : 0;
  nof_ies += csg_membership_info_present ? 1 : 0;
  nof_ies += tunnel_info_for_bbf_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(erab_to_be_modified_list_bearer_mod_ind.pack(bref));
  if (erab_not_to_be_modified_list_bearer_mod_ind_present) {
    HANDLE_CODE(erab_not_to_be_modified_list_bearer_mod_ind.pack(bref));
  }
  if (csg_membership_info_present) {
    HANDLE_CODE(csg_membership_info.pack(bref));
  }
  if (tunnel_info_for_bbf_present) {
    HANDLE_CODE(tunnel_info_for_bbf.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_mod_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 199:
        nof_mandatory_ies--;
        erab_to_be_modified_list_bearer_mod_ind.id    = c.id;
        erab_to_be_modified_list_bearer_mod_ind.crit  = c.crit;
        erab_to_be_modified_list_bearer_mod_ind.value = c.value.erab_to_be_modified_list_bearer_mod_ind();
        break;
      case 201:
        erab_not_to_be_modified_list_bearer_mod_ind_present = true;
        erab_not_to_be_modified_list_bearer_mod_ind.id      = c.id;
        erab_not_to_be_modified_list_bearer_mod_ind.crit    = c.crit;
        erab_not_to_be_modified_list_bearer_mod_ind.value   = c.value.erab_not_to_be_modified_list_bearer_mod_ind();
        break;
      case 226:
        csg_membership_info_present = true;
        csg_membership_info.id      = c.id;
        csg_membership_info.crit    = c.crit;
        csg_membership_info.value   = c.value.csg_membership_info();
        break;
      case 176:
        tunnel_info_for_bbf_present = true;
        tunnel_info_for_bbf.id      = c.id;
        tunnel_info_for_bbf.crit    = c.crit;
        tunnel_info_for_bbf.value   = c.value.tunnel_info_for_bbf();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_mod_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  erab_to_be_modified_list_bearer_mod_ind.to_json(j);
  if (erab_not_to_be_modified_list_bearer_mod_ind_present) {
    j.write_fieldname("");
    erab_not_to_be_modified_list_bearer_mod_ind.to_json(j);
  }
  if (csg_membership_info_present) {
    j.write_fieldname("");
    csg_membership_info.to_json(j);
  }
  if (tunnel_info_for_bbf_present) {
    j.write_fieldname("");
    tunnel_info_for_bbf.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

// E-RABModificationIndication ::= SEQUENCE
SRSASN_CODE erab_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABModifyItemBearerModRes ::= SEQUENCE
SRSASN_CODE erab_modify_item_bearer_mod_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_item_bearer_mod_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_modify_item_bearer_mod_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABModifyItemBearerModResIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_modify_item_bearer_mod_res_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {37};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_modify_item_bearer_mod_res_ies_o::is_id_valid(const uint32_t& id)
{
  return 37 == id;
}
crit_e erab_modify_item_bearer_mod_res_ies_o::get_crit(const uint32_t& id)
{
  if (id == 37) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_modify_item_bearer_mod_res_ies_o::value_c erab_modify_item_bearer_mod_res_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 37) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_modify_item_bearer_mod_res_ies_o::get_presence(const uint32_t& id)
{
  if (id == 37) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_modify_item_bearer_mod_res_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABModifyItemBearerModRes");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_modify_item_bearer_mod_res_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_item_bearer_mod_res_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_modify_item_bearer_mod_res_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABModifyItemBearerModRes"};
  return convert_enum_idx(options, 1, value, "erab_modify_item_bearer_mod_res_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_modify_item_bearer_mod_res_ies_o>;

// TransportInformation ::= SEQUENCE
SRSASN_CODE transport_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(ul_gtp_teid.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE transport_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(ul_gtp_teid.unpack(bref));

  return SRSASN_SUCCESS;
}
void transport_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("uL-GTP-TEID", ul_gtp_teid.to_string());
  j.end_obj();
}

// E-RABToBeModifyItemBearerModReqExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t erab_to_be_modify_item_bearer_mod_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {185};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_modify_item_bearer_mod_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 185 == id;
}
crit_e erab_to_be_modify_item_bearer_mod_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 185) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c
erab_to_be_modify_item_bearer_mod_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 185) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_modify_item_bearer_mod_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 185) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TransportInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"TransportInformation"};
  return convert_enum_idx(options, 1, value, "erab_to_be_modify_item_bearer_mod_req_ext_ies_o::ext_c::types");
}

// E-RABToBeModifiedItemBearerModReq ::= SEQUENCE
SRSASN_CODE erab_to_be_modified_item_bearer_mod_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.unpack(bref));
  HANDLE_CODE(nas_pdu.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_modified_item_bearer_mod_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("e-RABLevelQoSParameters");
  erab_level_qos_params.to_json(j);
  j.write_str("nAS-PDU", nas_pdu.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// E-RABToBeModifiedItemBearerModReqIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_modified_item_bearer_mod_req_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {36};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_modified_item_bearer_mod_req_ies_o::is_id_valid(const uint32_t& id)
{
  return 36 == id;
}
crit_e erab_to_be_modified_item_bearer_mod_req_ies_o::get_crit(const uint32_t& id)
{
  if (id == 36) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_modified_item_bearer_mod_req_ies_o::value_c
erab_to_be_modified_item_bearer_mod_req_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 36) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_modified_item_bearer_mod_req_ies_o::get_presence(const uint32_t& id)
{
  if (id == 36) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_modified_item_bearer_mod_req_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeModifiedItemBearerModReq");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_req_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_modified_item_bearer_mod_req_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_modified_item_bearer_mod_req_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeModifiedItemBearerModReq"};
  return convert_enum_idx(options, 1, value, "erab_to_be_modified_item_bearer_mod_req_ies_o::value_c::types");
}

// UEAggregate-MaximumBitrates-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t ue_aggregate_maximum_bitrates_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {259, 260};
  return map_enum_number(options, 2, idx, "id");
}
bool ue_aggregate_maximum_bitrates_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {259, 260};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_aggregate_maximum_bitrates_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 259:
      return crit_e::ignore;
    case 260:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_aggregate_maximum_bitrates_ext_ies_o::ext_c ue_aggregate_maximum_bitrates_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 259:
      ret.set(ext_c::types::extended_u_eaggregate_maximum_bit_rate_dl);
      break;
    case 260:
      ret.set(ext_c::types::extended_u_eaggregate_maximum_bit_rate_ul);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_aggregate_maximum_bitrates_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 259:
      return presence_e::optional;
    case 260:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::destroy_() {}
void ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::ext_c(const ue_aggregate_maximum_bitrates_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_u_eaggregate_maximum_bit_rate_dl:
      c.init(other.c.get<uint64_t>());
      break;
    case types::extended_u_eaggregate_maximum_bit_rate_ul:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c");
  }
}
ue_aggregate_maximum_bitrates_ext_ies_o::ext_c&
ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::operator=(const ue_aggregate_maximum_bitrates_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_u_eaggregate_maximum_bit_rate_dl:
      c.set(other.c.get<uint64_t>());
      break;
    case types::extended_u_eaggregate_maximum_bit_rate_ul:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c");
  }

  return *this;
}
uint64_t& ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::extended_u_eaggregate_maximum_bit_rate_dl()
{
  assert_choice_type(types::extended_u_eaggregate_maximum_bit_rate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
uint64_t& ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::extended_u_eaggregate_maximum_bit_rate_ul()
{
  assert_choice_type(types::extended_u_eaggregate_maximum_bit_rate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::extended_u_eaggregate_maximum_bit_rate_dl() const
{
  assert_choice_type(types::extended_u_eaggregate_maximum_bit_rate_dl, type_, "Extension");
  return c.get<uint64_t>();
}
const uint64_t& ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::extended_u_eaggregate_maximum_bit_rate_ul() const
{
  assert_choice_type(types::extended_u_eaggregate_maximum_bit_rate_ul, type_, "Extension");
  return c.get<uint64_t>();
}
void ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_u_eaggregate_maximum_bit_rate_dl:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    case types::extended_u_eaggregate_maximum_bit_rate_ul:
      j.write_int("INTEGER (10000000001..4000000000000,...)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_u_eaggregate_maximum_bit_rate_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_u_eaggregate_maximum_bit_rate_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_u_eaggregate_maximum_bit_rate_dl:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    case types::extended_u_eaggregate_maximum_bit_rate_ul:
      HANDLE_CODE(
          unpack_integer(c.get<uint64_t>(), bref, (uint64_t)10000000001u, (uint64_t)4000000000000u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (10000000001..4000000000000,...)",
                                  "INTEGER (10000000001..4000000000000,...)"};
  return convert_enum_idx(options, 2, value, "ue_aggregate_maximum_bitrates_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_to_be_modified_item_bearer_mod_req_ies_o>;

// SecondaryRATDataUsageRequest ::= ENUMERATED
const char* secondary_rat_data_usage_request_opts::to_string() const
{
  static const char* options[] = {"requested"};
  return convert_enum_idx(options, 1, value, "secondary_rat_data_usage_request_e");
}

template struct asn1::s1ap::protocol_ext_field_s<ue_aggregate_maximum_bitrates_ext_ies_o>;

ue_aggregate_maximum_bitrates_ext_ies_container::ue_aggregate_maximum_bitrates_ext_ies_container() :
  extended_u_eaggregate_maximum_bit_rate_dl(259, crit_e::ignore),
  extended_u_eaggregate_maximum_bit_rate_ul(260, crit_e::ignore)
{}
SRSASN_CODE ue_aggregate_maximum_bitrates_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_u_eaggregate_maximum_bit_rate_dl_present ? 1 : 0;
  nof_ies += extended_u_eaggregate_maximum_bit_rate_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_u_eaggregate_maximum_bit_rate_dl_present) {
    HANDLE_CODE(extended_u_eaggregate_maximum_bit_rate_dl.pack(bref));
  }
  if (extended_u_eaggregate_maximum_bit_rate_ul_present) {
    HANDLE_CODE(extended_u_eaggregate_maximum_bit_rate_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggregate_maximum_bitrates_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<ue_aggregate_maximum_bitrates_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 259:
        extended_u_eaggregate_maximum_bit_rate_dl_present = true;
        extended_u_eaggregate_maximum_bit_rate_dl.id      = c.id;
        extended_u_eaggregate_maximum_bit_rate_dl.crit    = c.crit;
        extended_u_eaggregate_maximum_bit_rate_dl.ext     = c.ext_value.extended_u_eaggregate_maximum_bit_rate_dl();
        break;
      case 260:
        extended_u_eaggregate_maximum_bit_rate_ul_present = true;
        extended_u_eaggregate_maximum_bit_rate_ul.id      = c.id;
        extended_u_eaggregate_maximum_bit_rate_ul.crit    = c.crit;
        extended_u_eaggregate_maximum_bit_rate_ul.ext     = c.ext_value.extended_u_eaggregate_maximum_bit_rate_ul();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ue_aggregate_maximum_bitrates_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_u_eaggregate_maximum_bit_rate_dl_present) {
    j.write_fieldname("");
    extended_u_eaggregate_maximum_bit_rate_dl.to_json(j);
  }
  if (extended_u_eaggregate_maximum_bit_rate_ul_present) {
    j.write_fieldname("");
    extended_u_eaggregate_maximum_bit_rate_ul.to_json(j);
  }
  j.end_obj();
}

// UEAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE ue_aggregate_maximum_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ueaggregate_maximum_bit_rate_dl, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(pack_integer(bref, ueaggregate_maximum_bit_rate_ul, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggregate_maximum_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ueaggregate_maximum_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  HANDLE_CODE(unpack_integer(ueaggregate_maximum_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_aggregate_maximum_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uEaggregateMaximumBitRateDL", ueaggregate_maximum_bit_rate_dl);
  j.write_int("uEaggregateMaximumBitRateUL", ueaggregate_maximum_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABModifyRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_modify_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 66, 30, 268};
  return map_enum_number(options, 5, idx, "id");
}
bool erab_modify_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 66, 30, 268};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_modify_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 30:
      return crit_e::reject;
    case 268:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_modify_request_ies_o::value_c erab_modify_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 30:
      ret.set(value_c::types::erab_to_be_modified_list_bearer_mod_req);
      break;
    case 268:
      ret.set(value_c::types::secondary_rat_data_usage_request);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_modify_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 30:
      return presence_e::mandatory;
    case 268:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_modify_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      c.destroy<erab_to_be_modified_list_bearer_mod_req_l>();
      break;
    default:
      break;
  }
}
void erab_modify_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      c.init<erab_to_be_modified_list_bearer_mod_req_l>();
      break;
    case types::secondary_rat_data_usage_request:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
  }
}
erab_modify_request_ies_o::value_c::value_c(const erab_modify_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      c.init(other.c.get<erab_to_be_modified_list_bearer_mod_req_l>());
      break;
    case types::secondary_rat_data_usage_request:
      c.init(other.c.get<secondary_rat_data_usage_request_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
  }
}
erab_modify_request_ies_o::value_c&
erab_modify_request_ies_o::value_c::operator=(const erab_modify_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      c.set(other.c.get<erab_to_be_modified_list_bearer_mod_req_l>());
      break;
    case types::secondary_rat_data_usage_request:
      c.set(other.c.get<secondary_rat_data_usage_request_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_modify_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_modify_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
ue_aggregate_maximum_bitrate_s& erab_modify_request_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_to_be_modified_list_bearer_mod_req_l& erab_modify_request_ies_o::value_c::erab_to_be_modified_list_bearer_mod_req()
{
  assert_choice_type(types::erab_to_be_modified_list_bearer_mod_req, type_, "Value");
  return c.get<erab_to_be_modified_list_bearer_mod_req_l>();
}
secondary_rat_data_usage_request_e& erab_modify_request_ies_o::value_c::secondary_rat_data_usage_request()
{
  assert_choice_type(types::secondary_rat_data_usage_request, type_, "Value");
  return c.get<secondary_rat_data_usage_request_e>();
}
const uint64_t& erab_modify_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_modify_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const ue_aggregate_maximum_bitrate_s& erab_modify_request_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_to_be_modified_list_bearer_mod_req_l&
erab_modify_request_ies_o::value_c::erab_to_be_modified_list_bearer_mod_req() const
{
  assert_choice_type(types::erab_to_be_modified_list_bearer_mod_req, type_, "Value");
  return c.get<erab_to_be_modified_list_bearer_mod_req_l>();
}
const secondary_rat_data_usage_request_e& erab_modify_request_ies_o::value_c::secondary_rat_data_usage_request() const
{
  assert_choice_type(types::secondary_rat_data_usage_request, type_, "Value");
  return c.get<secondary_rat_data_usage_request_e>();
}
void erab_modify_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      j.start_array("E-RABToBeModifiedListBearerModReq");
      for (const auto& e1 : c.get<erab_to_be_modified_list_bearer_mod_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::secondary_rat_data_usage_request:
      j.write_str("SecondaryRATDataUsageRequest", "requested");
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_modify_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_to_be_modified_list_bearer_mod_req_l>(), 1, 256, true));
      break;
    case types::secondary_rat_data_usage_request:
      HANDLE_CODE(c.get<secondary_rat_data_usage_request_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_modified_list_bearer_mod_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_to_be_modified_list_bearer_mod_req_l>(), bref, 1, 256, true));
      break;
    case types::secondary_rat_data_usage_request:
      HANDLE_CODE(c.get<secondary_rat_data_usage_request_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_modify_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "UEAggregateMaximumBitrate",
                                  "E-RABToBeModifiedListBearerModReq",
                                  "SecondaryRATDataUsageRequest"};
  return convert_enum_idx(options, 5, value, "erab_modify_request_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_modify_request_ies_o>;

erab_modify_request_ies_container::erab_modify_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  ueaggregate_maximum_bitrate(66, crit_e::reject),
  erab_to_be_modified_list_bearer_mod_req(30, crit_e::reject),
  secondary_rat_data_usage_request(268, crit_e::ignore)
{}
SRSASN_CODE erab_modify_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ueaggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_request_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ueaggregate_maximum_bitrate_present) {
    HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  }
  HANDLE_CODE(erab_to_be_modified_list_bearer_mod_req.pack(bref));
  if (secondary_rat_data_usage_request_present) {
    HANDLE_CODE(secondary_rat_data_usage_request.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_modify_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 66:
        ueaggregate_maximum_bitrate_present = true;
        ueaggregate_maximum_bitrate.id      = c.id;
        ueaggregate_maximum_bitrate.crit    = c.crit;
        ueaggregate_maximum_bitrate.value   = c.value.ueaggregate_maximum_bitrate();
        break;
      case 30:
        nof_mandatory_ies--;
        erab_to_be_modified_list_bearer_mod_req.id    = c.id;
        erab_to_be_modified_list_bearer_mod_req.crit  = c.crit;
        erab_to_be_modified_list_bearer_mod_req.value = c.value.erab_to_be_modified_list_bearer_mod_req();
        break;
      case 268:
        secondary_rat_data_usage_request_present = true;
        secondary_rat_data_usage_request.id      = c.id;
        secondary_rat_data_usage_request.crit    = c.crit;
        secondary_rat_data_usage_request.value   = c.value.secondary_rat_data_usage_request();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_modify_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ueaggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ueaggregate_maximum_bitrate.to_json(j);
  }
  j.write_fieldname("");
  erab_to_be_modified_list_bearer_mod_req.to_json(j);
  if (secondary_rat_data_usage_request_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_request.to_json(j);
  }
  j.end_obj();
}

// E-RABModifyRequest ::= SEQUENCE
SRSASN_CODE erab_modify_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_modify_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABModifyResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_modify_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 31, 32, 58, 264};
  return map_enum_number(options, 6, idx, "id");
}
bool erab_modify_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 31, 32, 58, 264};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_modify_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_modify_resp_ies_o::value_c erab_modify_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 31:
      ret.set(value_c::types::erab_modify_list_bearer_mod_res);
      break;
    case 32:
      ret.set(value_c::types::erab_failed_to_modify_list);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_modify_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 31:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_modify_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_modify_list_bearer_mod_res:
      c.destroy<erab_modify_list_bearer_mod_res_l>();
      break;
    case types::erab_failed_to_modify_list:
      c.destroy<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    default:
      break;
  }
}
void erab_modify_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_modify_list_bearer_mod_res:
      c.init<erab_modify_list_bearer_mod_res_l>();
      break;
    case types::erab_failed_to_modify_list:
      c.init<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
  }
}
erab_modify_resp_ies_o::value_c::value_c(const erab_modify_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_res:
      c.init(other.c.get<erab_modify_list_bearer_mod_res_l>());
      break;
    case types::erab_failed_to_modify_list:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
  }
}
erab_modify_resp_ies_o::value_c&
erab_modify_resp_ies_o::value_c::operator=(const erab_modify_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_res:
      c.set(other.c.get<erab_modify_list_bearer_mod_res_l>());
      break;
    case types::erab_failed_to_modify_list:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_modify_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_modify_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_modify_list_bearer_mod_res_l& erab_modify_resp_ies_o::value_c::erab_modify_list_bearer_mod_res()
{
  assert_choice_type(types::erab_modify_list_bearer_mod_res, type_, "Value");
  return c.get<erab_modify_list_bearer_mod_res_l>();
}
erab_list_l& erab_modify_resp_ies_o::value_c::erab_failed_to_modify_list()
{
  assert_choice_type(types::erab_failed_to_modify_list, type_, "Value");
  return c.get<erab_list_l>();
}
crit_diagnostics_s& erab_modify_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
secondary_rat_data_usage_report_list_l& erab_modify_resp_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const uint64_t& erab_modify_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_modify_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_modify_list_bearer_mod_res_l& erab_modify_resp_ies_o::value_c::erab_modify_list_bearer_mod_res() const
{
  assert_choice_type(types::erab_modify_list_bearer_mod_res, type_, "Value");
  return c.get<erab_modify_list_bearer_mod_res_l>();
}
const erab_list_l& erab_modify_resp_ies_o::value_c::erab_failed_to_modify_list() const
{
  assert_choice_type(types::erab_failed_to_modify_list, type_, "Value");
  return c.get<erab_list_l>();
}
const crit_diagnostics_s& erab_modify_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const secondary_rat_data_usage_report_list_l&
erab_modify_resp_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
void erab_modify_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_modify_list_bearer_mod_res:
      j.start_array("E-RABModifyListBearerModRes");
      for (const auto& e1 : c.get<erab_modify_list_bearer_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_failed_to_modify_list:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_modify_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_modify_list_bearer_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_modify_list_bearer_mod_res_l>(), 1, 256, true));
      break;
    case types::erab_failed_to_modify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_modify_list_bearer_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_modify_list_bearer_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_modify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_modify_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABModifyListBearerModRes",
                                  "E-RABList",
                                  "CriticalityDiagnostics",
                                  "SecondaryRATDataUsageReportList"};
  return convert_enum_idx(options, 6, value, "erab_modify_resp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_modify_resp_ies_o>;
template struct asn1::s1ap::protocol_ie_single_container_s<asn1::s1ap::erab_failedto_setup_item_ho_req_ack_ies_o>;

erab_modify_resp_ies_container::erab_modify_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_modify_list_bearer_mod_res(31, crit_e::ignore),
  erab_failed_to_modify_list(32, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore)
{}
SRSASN_CODE erab_modify_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_modify_list_bearer_mod_res_present ? 1 : 0;
  nof_ies += erab_failed_to_modify_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_modify_list_bearer_mod_res_present) {
    HANDLE_CODE(erab_modify_list_bearer_mod_res.pack(bref));
  }
  if (erab_failed_to_modify_list_present) {
    HANDLE_CODE(erab_failed_to_modify_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_modify_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 31:
        erab_modify_list_bearer_mod_res_present = true;
        erab_modify_list_bearer_mod_res.id      = c.id;
        erab_modify_list_bearer_mod_res.crit    = c.crit;
        erab_modify_list_bearer_mod_res.value   = c.value.erab_modify_list_bearer_mod_res();
        break;
      case 32:
        erab_failed_to_modify_list_present = true;
        erab_failed_to_modify_list.id      = c.id;
        erab_failed_to_modify_list.crit    = c.crit;
        erab_failed_to_modify_list.value   = c.value.erab_failed_to_modify_list();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_modify_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_modify_list_bearer_mod_res_present) {
    j.write_fieldname("");
    erab_modify_list_bearer_mod_res.to_json(j);
  }
  if (erab_failed_to_modify_list_present) {
    j.write_fieldname("");
    erab_failed_to_modify_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  j.end_obj();
}

// E-RABModifyResponse ::= SEQUENCE
SRSASN_CODE erab_modify_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_modify_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_modify_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABReleaseCommandIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 66, 33, 26};
  return map_enum_number(options, 5, idx, "id");
}
bool erab_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 66, 33, 26};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 33:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_release_cmd_ies_o::value_c erab_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 33:
      ret.set(value_c::types::erab_to_be_released_list);
      break;
    case 26:
      ret.set(value_c::types::nas_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 33:
      return presence_e::mandatory;
    case 26:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_released_list:
      c.destroy<erab_list_l>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void erab_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_released_list:
      c.init<erab_list_l>();
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
  }
}
erab_release_cmd_ies_o::value_c::value_c(const erab_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_released_list:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
  }
}
erab_release_cmd_ies_o::value_c&
erab_release_cmd_ies_o::value_c::operator=(const erab_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_released_list:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_release_cmd_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_release_cmd_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
ue_aggregate_maximum_bitrate_s& erab_release_cmd_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_list_l& erab_release_cmd_ies_o::value_c::erab_to_be_released_list()
{
  assert_choice_type(types::erab_to_be_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
unbounded_octstring<true>& erab_release_cmd_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint64_t& erab_release_cmd_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_release_cmd_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const ue_aggregate_maximum_bitrate_s& erab_release_cmd_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_list_l& erab_release_cmd_ies_o::value_c::erab_to_be_released_list() const
{
  assert_choice_type(types::erab_to_be_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
const unbounded_octstring<true>& erab_release_cmd_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void erab_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_released_list:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_released_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_released_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "UEAggregateMaximumBitrate", "E-RABList", "OCTET STRING"};
  return convert_enum_idx(options, 5, value, "erab_release_cmd_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_release_cmd_ies_o>;

erab_release_cmd_ies_container::erab_release_cmd_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  ueaggregate_maximum_bitrate(66, crit_e::reject),
  erab_to_be_released_list(33, crit_e::ignore),
  nas_pdu(26, crit_e::ignore)
{}
SRSASN_CODE erab_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ueaggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ueaggregate_maximum_bitrate_present) {
    HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  }
  HANDLE_CODE(erab_to_be_released_list.pack(bref));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_release_cmd_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 66:
        ueaggregate_maximum_bitrate_present = true;
        ueaggregate_maximum_bitrate.id      = c.id;
        ueaggregate_maximum_bitrate.crit    = c.crit;
        ueaggregate_maximum_bitrate.value   = c.value.ueaggregate_maximum_bitrate();
        break;
      case 33:
        nof_mandatory_ies--;
        erab_to_be_released_list.id    = c.id;
        erab_to_be_released_list.crit  = c.crit;
        erab_to_be_released_list.value = c.value.erab_to_be_released_list();
        break;
      case 26:
        nas_pdu_present = true;
        nas_pdu.id      = c.id;
        nas_pdu.crit    = c.crit;
        nas_pdu.value   = c.value.nas_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ueaggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ueaggregate_maximum_bitrate.to_json(j);
  }
  j.write_fieldname("");
  erab_to_be_released_list.to_json(j);
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  j.end_obj();
}

// E-RABReleaseCommand ::= SEQUENCE
SRSASN_CODE erab_release_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_release_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABReleaseIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_release_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 110, 189, 264};
  return map_enum_number(options, 5, idx, "id");
}
bool erab_release_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 110, 189, 264};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_release_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 110:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_release_ind_ies_o::value_c erab_release_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 110:
      ret.set(value_c::types::erab_released_list);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_release_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 110:
      return presence_e::mandatory;
    case 189:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_release_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_released_list:
      c.destroy<erab_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    default:
      break;
  }
}
void erab_release_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_released_list:
      c.init<erab_list_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
  }
}
erab_release_ind_ies_o::value_c::value_c(const erab_release_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_released_list:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
  }
}
erab_release_ind_ies_o::value_c&
erab_release_ind_ies_o::value_c::operator=(const erab_release_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_released_list:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_release_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_release_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_list_l& erab_release_ind_ies_o::value_c::erab_released_list()
{
  assert_choice_type(types::erab_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
user_location_info_s& erab_release_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
secondary_rat_data_usage_report_list_l& erab_release_ind_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const uint64_t& erab_release_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_release_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_list_l& erab_release_ind_ies_o::value_c::erab_released_list() const
{
  assert_choice_type(types::erab_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
const user_location_info_s& erab_release_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const secondary_rat_data_usage_report_list_l&
erab_release_ind_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
void erab_release_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_released_list:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_release_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_released_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_released_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_release_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABList",
                                  "UserLocationInformation",
                                  "SecondaryRATDataUsageReportList"};
  return convert_enum_idx(options, 5, value, "erab_release_ind_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_release_ind_ies_o>;

erab_release_ind_ies_container::erab_release_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  erab_released_list(110, crit_e::ignore),
  user_location_info(189, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore)
{}
SRSASN_CODE erab_release_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(erab_released_list.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_release_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 110:
        nof_mandatory_ies--;
        erab_released_list.id    = c.id;
        erab_released_list.crit  = c.crit;
        erab_released_list.value = c.value.erab_released_list();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_release_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  erab_released_list.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  j.end_obj();
}

// E-RABReleaseIndication ::= SEQUENCE
SRSASN_CODE erab_release_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_release_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABReleaseItemBearerRelComp ::= SEQUENCE
SRSASN_CODE erab_release_item_bearer_rel_comp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_item_bearer_rel_comp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_release_item_bearer_rel_comp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABReleaseItemBearerRelCompIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_release_item_bearer_rel_comp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {15};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_release_item_bearer_rel_comp_ies_o::is_id_valid(const uint32_t& id)
{
  return 15 == id;
}
crit_e erab_release_item_bearer_rel_comp_ies_o::get_crit(const uint32_t& id)
{
  if (id == 15) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_release_item_bearer_rel_comp_ies_o::value_c erab_release_item_bearer_rel_comp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 15) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_release_item_bearer_rel_comp_ies_o::get_presence(const uint32_t& id)
{
  if (id == 15) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_release_item_bearer_rel_comp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABReleaseItemBearerRelComp");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_release_item_bearer_rel_comp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_item_bearer_rel_comp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_release_item_bearer_rel_comp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABReleaseItemBearerRelComp"};
  return convert_enum_idx(options, 1, value, "erab_release_item_bearer_rel_comp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_release_item_bearer_rel_comp_ies_o>;

// E-RABReleaseResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 69, 34, 58, 189, 264};
  return map_enum_number(options, 7, idx, "id");
}
bool erab_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 69, 34, 58, 189, 264};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 69:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_release_resp_ies_o::value_c erab_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 69:
      ret.set(value_c::types::erab_release_list_bearer_rel_comp);
      break;
    case 34:
      ret.set(value_c::types::erab_failed_to_release_list);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 69:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 189:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_release_list_bearer_rel_comp:
      c.destroy<erab_release_list_bearer_rel_comp_l>();
      break;
    case types::erab_failed_to_release_list:
      c.destroy<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    default:
      break;
  }
}
void erab_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_release_list_bearer_rel_comp:
      c.init<erab_release_list_bearer_rel_comp_l>();
      break;
    case types::erab_failed_to_release_list:
      c.init<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
  }
}
erab_release_resp_ies_o::value_c::value_c(const erab_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_release_list_bearer_rel_comp:
      c.init(other.c.get<erab_release_list_bearer_rel_comp_l>());
      break;
    case types::erab_failed_to_release_list:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
  }
}
erab_release_resp_ies_o::value_c&
erab_release_resp_ies_o::value_c::operator=(const erab_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_release_list_bearer_rel_comp:
      c.set(other.c.get<erab_release_list_bearer_rel_comp_l>());
      break;
    case types::erab_failed_to_release_list:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_release_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_release_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_release_list_bearer_rel_comp_l& erab_release_resp_ies_o::value_c::erab_release_list_bearer_rel_comp()
{
  assert_choice_type(types::erab_release_list_bearer_rel_comp, type_, "Value");
  return c.get<erab_release_list_bearer_rel_comp_l>();
}
erab_list_l& erab_release_resp_ies_o::value_c::erab_failed_to_release_list()
{
  assert_choice_type(types::erab_failed_to_release_list, type_, "Value");
  return c.get<erab_list_l>();
}
crit_diagnostics_s& erab_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_s& erab_release_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
secondary_rat_data_usage_report_list_l& erab_release_resp_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const uint64_t& erab_release_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_release_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_release_list_bearer_rel_comp_l& erab_release_resp_ies_o::value_c::erab_release_list_bearer_rel_comp() const
{
  assert_choice_type(types::erab_release_list_bearer_rel_comp, type_, "Value");
  return c.get<erab_release_list_bearer_rel_comp_l>();
}
const erab_list_l& erab_release_resp_ies_o::value_c::erab_failed_to_release_list() const
{
  assert_choice_type(types::erab_failed_to_release_list, type_, "Value");
  return c.get<erab_list_l>();
}
const crit_diagnostics_s& erab_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_s& erab_release_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const secondary_rat_data_usage_report_list_l&
erab_release_resp_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
void erab_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_release_list_bearer_rel_comp:
      j.start_array("E-RABReleaseListBearerRelComp");
      for (const auto& e1 : c.get<erab_release_list_bearer_rel_comp_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_failed_to_release_list:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_release_list_bearer_rel_comp:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_release_list_bearer_rel_comp_l>(), 1, 256, true));
      break;
    case types::erab_failed_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_release_list_bearer_rel_comp:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_release_list_bearer_rel_comp_l>(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABReleaseListBearerRelComp",
                                  "E-RABList",
                                  "CriticalityDiagnostics",
                                  "UserLocationInformation",
                                  "SecondaryRATDataUsageReportList"};
  return convert_enum_idx(options, 7, value, "erab_release_resp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_release_resp_ies_o>;

erab_release_resp_ies_container::erab_release_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_release_list_bearer_rel_comp(69, crit_e::ignore),
  erab_failed_to_release_list(34, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  user_location_info(189, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore)
{}
SRSASN_CODE erab_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_release_list_bearer_rel_comp_present ? 1 : 0;
  nof_ies += erab_failed_to_release_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_release_list_bearer_rel_comp_present) {
    HANDLE_CODE(erab_release_list_bearer_rel_comp.pack(bref));
  }
  if (erab_failed_to_release_list_present) {
    HANDLE_CODE(erab_failed_to_release_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_release_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 69:
        erab_release_list_bearer_rel_comp_present = true;
        erab_release_list_bearer_rel_comp.id      = c.id;
        erab_release_list_bearer_rel_comp.crit    = c.crit;
        erab_release_list_bearer_rel_comp.value   = c.value.erab_release_list_bearer_rel_comp();
        break;
      case 34:
        erab_failed_to_release_list_present = true;
        erab_failed_to_release_list.id      = c.id;
        erab_failed_to_release_list.crit    = c.crit;
        erab_failed_to_release_list.value   = c.value.erab_failed_to_release_list();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_release_list_bearer_rel_comp_present) {
    j.write_fieldname("");
    erab_release_list_bearer_rel_comp.to_json(j);
  }
  if (erab_failed_to_release_list_present) {
    j.write_fieldname("");
    erab_failed_to_release_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  j.end_obj();
}

// E-RABReleaseResponse ::= SEQUENCE
SRSASN_CODE erab_release_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_release_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_release_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABSetupItemBearerSURes ::= SEQUENCE
SRSASN_CODE erab_setup_item_bearer_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_item_bearer_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_setup_item_bearer_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABSetupItemBearerSUResIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_setup_item_bearer_su_res_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {39};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_setup_item_bearer_su_res_ies_o::is_id_valid(const uint32_t& id)
{
  return 39 == id;
}
crit_e erab_setup_item_bearer_su_res_ies_o::get_crit(const uint32_t& id)
{
  if (id == 39) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_setup_item_bearer_su_res_ies_o::value_c erab_setup_item_bearer_su_res_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 39) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_setup_item_bearer_su_res_ies_o::get_presence(const uint32_t& id)
{
  if (id == 39) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_setup_item_bearer_su_res_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABSetupItemBearerSURes");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_setup_item_bearer_su_res_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_item_bearer_su_res_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_setup_item_bearer_su_res_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABSetupItemBearerSURes"};
  return convert_enum_idx(options, 1, value, "erab_setup_item_bearer_su_res_ies_o::value_c::types");
}

// E-RABSetupItemCtxtSURes ::= SEQUENCE
SRSASN_CODE erab_setup_item_ctxt_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_item_ctxt_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_setup_item_ctxt_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABSetupItemCtxtSUResIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_setup_item_ctxt_su_res_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {50};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_setup_item_ctxt_su_res_ies_o::is_id_valid(const uint32_t& id)
{
  return 50 == id;
}
crit_e erab_setup_item_ctxt_su_res_ies_o::get_crit(const uint32_t& id)
{
  if (id == 50) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_setup_item_ctxt_su_res_ies_o::value_c erab_setup_item_ctxt_su_res_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 50) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_setup_item_ctxt_su_res_ies_o::get_presence(const uint32_t& id)
{
  if (id == 50) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_setup_item_ctxt_su_res_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABSetupItemCtxtSURes");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_setup_item_ctxt_su_res_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_item_ctxt_su_res_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_setup_item_ctxt_su_res_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABSetupItemCtxtSURes"};
  return convert_enum_idx(options, 1, value, "erab_setup_item_ctxt_su_res_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_setup_item_bearer_su_res_ies_o>;

template struct asn1::s1ap::protocol_ie_single_container_s<erab_setup_item_ctxt_su_res_ies_o>;

// BearerType ::= ENUMERATED
const char* bearer_type_opts::to_string() const
{
  static const char* options[] = {"non-IP"};
  return convert_enum_idx(options, 1, value, "bearer_type_e");
}

// E-RABToBeSetupItemBearerSUReqExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t erab_to_be_setup_item_bearer_su_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {156, 183, 233};
  return map_enum_number(options, 3, idx, "id");
}
bool erab_to_be_setup_item_bearer_su_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {156, 183, 233};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_to_be_setup_item_bearer_su_req_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 156:
      return crit_e::ignore;
    case 183:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c
erab_to_be_setup_item_bearer_su_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 156:
      ret.set(ext_c::types::correlation_id);
      break;
    case 183:
      ret.set(ext_c::types::sipto_correlation_id);
      break;
    case 233:
      ret.set(ext_c::types::bearer_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_bearer_su_req_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 156:
      return presence_e::optional;
    case 183:
      return presence_e::optional;
    case 233:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::correlation_id:
      c.destroy<fixed_octstring<4, true> >();
      break;
    case types::sipto_correlation_id:
      c.destroy<fixed_octstring<4, true> >();
      break;
    default:
      break;
  }
}
void erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::correlation_id:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::sipto_correlation_id:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::bearer_type:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
  }
}
erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::ext_c(
    const erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::correlation_id:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::sipto_correlation_id:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::bearer_type:
      c.init(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
  }
}
erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::operator=(
    const erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::correlation_id:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::sipto_correlation_id:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::bearer_type:
      c.set(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
  }

  return *this;
}
fixed_octstring<4, true>& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::correlation_id()
{
  assert_choice_type(types::correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
fixed_octstring<4, true>& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::sipto_correlation_id()
{
  assert_choice_type(types::sipto_correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
bearer_type_e& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::bearer_type()
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
const fixed_octstring<4, true>& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::correlation_id() const
{
  assert_choice_type(types::correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
const fixed_octstring<4, true>& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::sipto_correlation_id() const
{
  assert_choice_type(types::sipto_correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
const bearer_type_e& erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::bearer_type() const
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
void erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::correlation_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    case types::sipto_correlation_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    case types::bearer_type:
      j.write_str("BearerType", "non-IP");
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    case types::sipto_correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    case types::sipto_correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"OCTET STRING", "OCTET STRING", "BearerType"};
  return convert_enum_idx(options, 3, value, "erab_to_be_setup_item_bearer_su_req_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<erab_to_be_setup_item_bearer_su_req_ext_ies_o>;

erab_to_be_setup_item_bearer_su_req_ext_ies_container::erab_to_be_setup_item_bearer_su_req_ext_ies_container() :
  correlation_id(156, crit_e::ignore), sipto_correlation_id(183, crit_e::ignore), bearer_type(233, crit_e::reject)
{}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += correlation_id_present ? 1 : 0;
  nof_ies += sipto_correlation_id_present ? 1 : 0;
  nof_ies += bearer_type_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (correlation_id_present) {
    HANDLE_CODE(correlation_id.pack(bref));
  }
  if (sipto_correlation_id_present) {
    HANDLE_CODE(sipto_correlation_id.pack(bref));
  }
  if (bearer_type_present) {
    HANDLE_CODE(bearer_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<erab_to_be_setup_item_bearer_su_req_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 156:
        correlation_id_present = true;
        correlation_id.id      = c.id;
        correlation_id.crit    = c.crit;
        correlation_id.ext     = c.ext_value.correlation_id();
        break;
      case 183:
        sipto_correlation_id_present = true;
        sipto_correlation_id.id      = c.id;
        sipto_correlation_id.crit    = c.crit;
        sipto_correlation_id.ext     = c.ext_value.sipto_correlation_id();
        break;
      case 233:
        bearer_type_present = true;
        bearer_type.id      = c.id;
        bearer_type.crit    = c.crit;
        bearer_type.ext     = c.ext_value.bearer_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_bearer_su_req_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (correlation_id_present) {
    j.write_fieldname("");
    correlation_id.to_json(j);
  }
  if (sipto_correlation_id_present) {
    j.write_fieldname("");
    sipto_correlation_id.to_json(j);
  }
  if (bearer_type_present) {
    j.write_fieldname("");
    bearer_type.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemBearerSUReq ::= SEQUENCE
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.pack(bref));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.unpack(bref));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  HANDLE_CODE(nas_pdu.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_bearer_su_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("e-RABlevelQoSParameters");
  erab_level_qos_params.to_json(j);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  j.write_str("nAS-PDU", nas_pdu.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemBearerSUReqIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_setup_item_bearer_su_req_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {17};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_setup_item_bearer_su_req_ies_o::is_id_valid(const uint32_t& id)
{
  return 17 == id;
}
crit_e erab_to_be_setup_item_bearer_su_req_ies_o::get_crit(const uint32_t& id)
{
  if (id == 17) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_setup_item_bearer_su_req_ies_o::value_c
erab_to_be_setup_item_bearer_su_req_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 17) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_bearer_su_req_ies_o::get_presence(const uint32_t& id)
{
  if (id == 17) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_setup_item_bearer_su_req_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeSetupItemBearerSUReq");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_bearer_su_req_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_bearer_su_req_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeSetupItemBearerSUReq"};
  return convert_enum_idx(options, 1, value, "erab_to_be_setup_item_bearer_su_req_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_to_be_setup_item_bearer_su_req_ies_o>;

// E-RABSetupRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 66, 16};
  return map_enum_number(options, 4, idx, "id");
}
bool erab_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 66, 16};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 16:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_setup_request_ies_o::value_c erab_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 16:
      ret.set(value_c::types::erab_to_be_setup_list_bearer_su_req);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 16:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      c.destroy<erab_to_be_setup_list_bearer_su_req_l>();
      break;
    default:
      break;
  }
}
void erab_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      c.init<erab_to_be_setup_list_bearer_su_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
  }
}
erab_setup_request_ies_o::value_c::value_c(const erab_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      c.init(other.c.get<erab_to_be_setup_list_bearer_su_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
  }
}
erab_setup_request_ies_o::value_c&
erab_setup_request_ies_o::value_c::operator=(const erab_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      c.set(other.c.get<erab_to_be_setup_list_bearer_su_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_setup_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_setup_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
ue_aggregate_maximum_bitrate_s& erab_setup_request_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_to_be_setup_list_bearer_su_req_l& erab_setup_request_ies_o::value_c::erab_to_be_setup_list_bearer_su_req()
{
  assert_choice_type(types::erab_to_be_setup_list_bearer_su_req, type_, "Value");
  return c.get<erab_to_be_setup_list_bearer_su_req_l>();
}
const uint64_t& erab_setup_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_setup_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const ue_aggregate_maximum_bitrate_s& erab_setup_request_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_to_be_setup_list_bearer_su_req_l&
erab_setup_request_ies_o::value_c::erab_to_be_setup_list_bearer_su_req() const
{
  assert_choice_type(types::erab_to_be_setup_list_bearer_su_req, type_, "Value");
  return c.get<erab_to_be_setup_list_bearer_su_req_l>();
}
void erab_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      j.start_array("E-RABToBeSetupListBearerSUReq");
      for (const auto& e1 : c.get<erab_to_be_setup_list_bearer_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_to_be_setup_list_bearer_su_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_setup_list_bearer_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_to_be_setup_list_bearer_su_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "UEAggregateMaximumBitrate", "E-RABToBeSetupListBearerSUReq"};
  return convert_enum_idx(options, 4, value, "erab_setup_request_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_setup_request_ies_o>;

erab_setup_request_ies_container::erab_setup_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  ueaggregate_maximum_bitrate(66, crit_e::reject),
  erab_to_be_setup_list_bearer_su_req(16, crit_e::reject)
{}
SRSASN_CODE erab_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ueaggregate_maximum_bitrate_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ueaggregate_maximum_bitrate_present) {
    HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  }
  HANDLE_CODE(erab_to_be_setup_list_bearer_su_req.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_setup_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 66:
        ueaggregate_maximum_bitrate_present = true;
        ueaggregate_maximum_bitrate.id      = c.id;
        ueaggregate_maximum_bitrate.crit    = c.crit;
        ueaggregate_maximum_bitrate.value   = c.value.ueaggregate_maximum_bitrate();
        break;
      case 16:
        nof_mandatory_ies--;
        erab_to_be_setup_list_bearer_su_req.id    = c.id;
        erab_to_be_setup_list_bearer_su_req.crit  = c.crit;
        erab_to_be_setup_list_bearer_su_req.value = c.value.erab_to_be_setup_list_bearer_su_req();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ueaggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ueaggregate_maximum_bitrate.to_json(j);
  }
  j.write_fieldname("");
  erab_to_be_setup_list_bearer_su_req.to_json(j);
  j.end_obj();
}

// E-RABSetupRequest ::= SEQUENCE
SRSASN_CODE erab_setup_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_setup_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABSetupResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 28, 29, 58};
  return map_enum_number(options, 5, idx, "id");
}
bool erab_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 28, 29, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 28:
      return crit_e::ignore;
    case 29:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_setup_resp_ies_o::value_c erab_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 28:
      ret.set(value_c::types::erab_setup_list_bearer_su_res);
      break;
    case 29:
      ret.set(value_c::types::erab_failed_to_setup_list_bearer_su_res);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 28:
      return presence_e::optional;
    case 29:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void erab_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_setup_list_bearer_su_res:
      c.destroy<erab_setup_list_bearer_su_res_l>();
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      c.destroy<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void erab_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_setup_list_bearer_su_res:
      c.init<erab_setup_list_bearer_su_res_l>();
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      c.init<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
  }
}
erab_setup_resp_ies_o::value_c::value_c(const erab_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_setup_list_bearer_su_res:
      c.init(other.c.get<erab_setup_list_bearer_su_res_l>());
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
  }
}
erab_setup_resp_ies_o::value_c& erab_setup_resp_ies_o::value_c::operator=(const erab_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_setup_list_bearer_su_res:
      c.set(other.c.get<erab_setup_list_bearer_su_res_l>());
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& erab_setup_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& erab_setup_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_setup_list_bearer_su_res_l& erab_setup_resp_ies_o::value_c::erab_setup_list_bearer_su_res()
{
  assert_choice_type(types::erab_setup_list_bearer_su_res, type_, "Value");
  return c.get<erab_setup_list_bearer_su_res_l>();
}
erab_list_l& erab_setup_resp_ies_o::value_c::erab_failed_to_setup_list_bearer_su_res()
{
  assert_choice_type(types::erab_failed_to_setup_list_bearer_su_res, type_, "Value");
  return c.get<erab_list_l>();
}
crit_diagnostics_s& erab_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& erab_setup_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& erab_setup_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_setup_list_bearer_su_res_l& erab_setup_resp_ies_o::value_c::erab_setup_list_bearer_su_res() const
{
  assert_choice_type(types::erab_setup_list_bearer_su_res, type_, "Value");
  return c.get<erab_setup_list_bearer_su_res_l>();
}
const erab_list_l& erab_setup_resp_ies_o::value_c::erab_failed_to_setup_list_bearer_su_res() const
{
  assert_choice_type(types::erab_failed_to_setup_list_bearer_su_res, type_, "Value");
  return c.get<erab_list_l>();
}
const crit_diagnostics_s& erab_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void erab_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_setup_list_bearer_su_res:
      j.start_array("E-RABSetupListBearerSURes");
      for (const auto& e1 : c.get<erab_setup_list_bearer_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_setup_list_bearer_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_setup_list_bearer_su_res_l>(), 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_setup_list_bearer_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_setup_list_bearer_su_res_l>(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_bearer_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABSetupListBearerSURes",
                                  "E-RABList",
                                  "CriticalityDiagnostics"};
  return convert_enum_idx(options, 5, value, "erab_setup_resp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<erab_setup_resp_ies_o>;

erab_setup_resp_ies_container::erab_setup_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_setup_list_bearer_su_res(28, crit_e::ignore),
  erab_failed_to_setup_list_bearer_su_res(29, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE erab_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_setup_list_bearer_su_res_present ? 1 : 0;
  nof_ies += erab_failed_to_setup_list_bearer_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_setup_list_bearer_su_res_present) {
    HANDLE_CODE(erab_setup_list_bearer_su_res.pack(bref));
  }
  if (erab_failed_to_setup_list_bearer_su_res_present) {
    HANDLE_CODE(erab_failed_to_setup_list_bearer_su_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<erab_setup_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 28:
        erab_setup_list_bearer_su_res_present = true;
        erab_setup_list_bearer_su_res.id      = c.id;
        erab_setup_list_bearer_su_res.crit    = c.crit;
        erab_setup_list_bearer_su_res.value   = c.value.erab_setup_list_bearer_su_res();
        break;
      case 29:
        erab_failed_to_setup_list_bearer_su_res_present = true;
        erab_failed_to_setup_list_bearer_su_res.id      = c.id;
        erab_failed_to_setup_list_bearer_su_res.crit    = c.crit;
        erab_failed_to_setup_list_bearer_su_res.value   = c.value.erab_failed_to_setup_list_bearer_su_res();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void erab_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_setup_list_bearer_su_res_present) {
    j.write_fieldname("");
    erab_setup_list_bearer_su_res.to_json(j);
  }
  if (erab_failed_to_setup_list_bearer_su_res_present) {
    j.write_fieldname("");
    erab_failed_to_setup_list_bearer_su_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// E-RABSetupResponse ::= SEQUENCE
SRSASN_CODE erab_setup_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_setup_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void erab_setup_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// E-RABToBeSetupItemCtxtSUReqExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t erab_to_be_setup_item_ctxt_su_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {156, 183, 233};
  return map_enum_number(options, 3, idx, "id");
}
bool erab_to_be_setup_item_ctxt_su_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {156, 183, 233};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_to_be_setup_item_ctxt_su_req_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 156:
      return crit_e::ignore;
    case 183:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c
erab_to_be_setup_item_ctxt_su_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 156:
      ret.set(ext_c::types::correlation_id);
      break;
    case 183:
      ret.set(ext_c::types::sipto_correlation_id);
      break;
    case 233:
      ret.set(ext_c::types::bearer_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_ctxt_su_req_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 156:
      return presence_e::optional;
    case 183:
      return presence_e::optional;
    case 233:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::correlation_id:
      c.destroy<fixed_octstring<4, true> >();
      break;
    case types::sipto_correlation_id:
      c.destroy<fixed_octstring<4, true> >();
      break;
    default:
      break;
  }
}
void erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::correlation_id:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::sipto_correlation_id:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::bearer_type:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
  }
}
erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::ext_c(
    const erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::correlation_id:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::sipto_correlation_id:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::bearer_type:
      c.init(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
  }
}
erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::operator=(
    const erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::correlation_id:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::sipto_correlation_id:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::bearer_type:
      c.set(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
  }

  return *this;
}
fixed_octstring<4, true>& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::correlation_id()
{
  assert_choice_type(types::correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
fixed_octstring<4, true>& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::sipto_correlation_id()
{
  assert_choice_type(types::sipto_correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
bearer_type_e& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::bearer_type()
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
const fixed_octstring<4, true>& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::correlation_id() const
{
  assert_choice_type(types::correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
const fixed_octstring<4, true>& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::sipto_correlation_id() const
{
  assert_choice_type(types::sipto_correlation_id, type_, "Extension");
  return c.get<fixed_octstring<4, true> >();
}
const bearer_type_e& erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::bearer_type() const
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
void erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::correlation_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    case types::sipto_correlation_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    case types::bearer_type:
      j.write_str("BearerType", "non-IP");
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    case types::sipto_correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    case types::sipto_correlation_id:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"OCTET STRING", "OCTET STRING", "BearerType"};
  return convert_enum_idx(options, 3, value, "erab_to_be_setup_item_ctxt_su_req_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<erab_to_be_setup_item_ctxt_su_req_ext_ies_o>;

erab_to_be_setup_item_ctxt_su_req_ext_ies_container::erab_to_be_setup_item_ctxt_su_req_ext_ies_container() :
  correlation_id(156, crit_e::ignore), sipto_correlation_id(183, crit_e::ignore), bearer_type(233, crit_e::reject)
{}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += correlation_id_present ? 1 : 0;
  nof_ies += sipto_correlation_id_present ? 1 : 0;
  nof_ies += bearer_type_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (correlation_id_present) {
    HANDLE_CODE(correlation_id.pack(bref));
  }
  if (sipto_correlation_id_present) {
    HANDLE_CODE(sipto_correlation_id.pack(bref));
  }
  if (bearer_type_present) {
    HANDLE_CODE(bearer_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<erab_to_be_setup_item_ctxt_su_req_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 156:
        correlation_id_present = true;
        correlation_id.id      = c.id;
        correlation_id.crit    = c.crit;
        correlation_id.ext     = c.ext_value.correlation_id();
        break;
      case 183:
        sipto_correlation_id_present = true;
        sipto_correlation_id.id      = c.id;
        sipto_correlation_id.crit    = c.crit;
        sipto_correlation_id.ext     = c.ext_value.sipto_correlation_id();
        break;
      case 233:
        bearer_type_present = true;
        bearer_type.id      = c.id;
        bearer_type.crit    = c.crit;
        bearer_type.ext     = c.ext_value.bearer_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_ctxt_su_req_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (correlation_id_present) {
    j.write_fieldname("");
    correlation_id.to_json(j);
  }
  if (sipto_correlation_id_present) {
    j.write_fieldname("");
    sipto_correlation_id.to_json(j);
  }
  if (bearer_type_present) {
    j.write_fieldname("");
    bearer_type.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemCtxtSUReq ::= SEQUENCE
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nas_pdu_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.pack(bref));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nas_pdu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(erab_level_qos_params.unpack(bref));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_ctxt_su_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("e-RABlevelQoSParameters");
  erab_level_qos_params.to_json(j);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (nas_pdu_present) {
    j.write_str("nAS-PDU", nas_pdu.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemCtxtSUReqIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_setup_item_ctxt_su_req_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {52};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_setup_item_ctxt_su_req_ies_o::is_id_valid(const uint32_t& id)
{
  return 52 == id;
}
crit_e erab_to_be_setup_item_ctxt_su_req_ies_o::get_crit(const uint32_t& id)
{
  if (id == 52) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_setup_item_ctxt_su_req_ies_o::value_c erab_to_be_setup_item_ctxt_su_req_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 52) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_ctxt_su_req_ies_o::get_presence(const uint32_t& id)
{
  if (id == 52) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_setup_item_ctxt_su_req_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeSetupItemCtxtSUReq");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ctxt_su_req_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_ctxt_su_req_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeSetupItemCtxtSUReq"};
  return convert_enum_idx(options, 1, value, "erab_to_be_setup_item_ctxt_su_req_ies_o::value_c::types");
}

// Data-Forwarding-Not-Possible ::= ENUMERATED
const char* data_forwarding_not_possible_opts::to_string() const
{
  static const char* options[] = {"data-Forwarding-not-Possible"};
  return convert_enum_idx(options, 1, value, "data_forwarding_not_possible_e");
}

// E-RABToBeSetupItemHOReq-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t erab_to_be_setup_item_ho_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {143, 233};
  return map_enum_number(options, 2, idx, "id");
}
bool erab_to_be_setup_item_ho_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {143, 233};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_to_be_setup_item_ho_req_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 143:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
erab_to_be_setup_item_ho_req_ext_ies_o::ext_c erab_to_be_setup_item_ho_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 143:
      ret.set(ext_c::types::data_forwarding_not_possible);
      break;
    case 233:
      ret.set(ext_c::types::bearer_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_ho_req_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 143:
      return presence_e::optional;
    case 233:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::destroy_() {}
void erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::ext_c(const erab_to_be_setup_item_ho_req_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::data_forwarding_not_possible:
      c.init(other.c.get<data_forwarding_not_possible_e>());
      break;
    case types::bearer_type:
      c.init(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c");
  }
}
erab_to_be_setup_item_ho_req_ext_ies_o::ext_c&
erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::operator=(const erab_to_be_setup_item_ho_req_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::data_forwarding_not_possible:
      c.set(other.c.get<data_forwarding_not_possible_e>());
      break;
    case types::bearer_type:
      c.set(other.c.get<bearer_type_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c");
  }

  return *this;
}
data_forwarding_not_possible_e& erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::data_forwarding_not_possible()
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Extension");
  return c.get<data_forwarding_not_possible_e>();
}
bearer_type_e& erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::bearer_type()
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
const data_forwarding_not_possible_e&
erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::data_forwarding_not_possible() const
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Extension");
  return c.get<data_forwarding_not_possible_e>();
}
const bearer_type_e& erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::bearer_type() const
{
  assert_choice_type(types::bearer_type, type_, "Extension");
  return c.get<bearer_type_e>();
}
void erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::data_forwarding_not_possible:
      j.write_str("Data-Forwarding-Not-Possible", "data-Forwarding-not-Possible");
      break;
    case types::bearer_type:
      j.write_str("BearerType", "non-IP");
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().pack(bref));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().unpack(bref));
      break;
    case types::bearer_type:
      HANDLE_CODE(c.get<bearer_type_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"Data-Forwarding-Not-Possible", "BearerType"};
  return convert_enum_idx(options, 2, value, "erab_to_be_setup_item_ho_req_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<erab_to_be_setup_item_ho_req_ext_ies_o>;

erab_to_be_setup_item_ho_req_ext_ies_container::erab_to_be_setup_item_ho_req_ext_ies_container() :
  data_forwarding_not_possible(143, crit_e::ignore), bearer_type(233, crit_e::reject)
{}
SRSASN_CODE erab_to_be_setup_item_ho_req_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += data_forwarding_not_possible_present ? 1 : 0;
  nof_ies += bearer_type_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (data_forwarding_not_possible_present) {
    HANDLE_CODE(data_forwarding_not_possible.pack(bref));
  }
  if (bearer_type_present) {
    HANDLE_CODE(bearer_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ho_req_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<erab_to_be_setup_item_ho_req_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 143:
        data_forwarding_not_possible_present = true;
        data_forwarding_not_possible.id      = c.id;
        data_forwarding_not_possible.crit    = c.crit;
        data_forwarding_not_possible.ext     = c.ext_value.data_forwarding_not_possible();
        break;
      case 233:
        bearer_type_present = true;
        bearer_type.id      = c.id;
        bearer_type.crit    = c.crit;
        bearer_type.ext     = c.ext_value.bearer_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_ho_req_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (data_forwarding_not_possible_present) {
    j.write_fieldname("");
    data_forwarding_not_possible.to_json(j);
  }
  if (bearer_type_present) {
    j.write_fieldname("");
    bearer_type.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemHOReq ::= SEQUENCE
SRSASN_CODE erab_to_be_setup_item_ho_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  HANDLE_CODE(erab_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ho_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  HANDLE_CODE(erab_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_setup_item_ho_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  j.write_fieldname("e-RABlevelQosParameters");
  erab_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSetupItemHOReqIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_setup_item_ho_req_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {27};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_setup_item_ho_req_ies_o::is_id_valid(const uint32_t& id)
{
  return 27 == id;
}
crit_e erab_to_be_setup_item_ho_req_ies_o::get_crit(const uint32_t& id)
{
  if (id == 27) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_setup_item_ho_req_ies_o::value_c erab_to_be_setup_item_ho_req_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 27) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_setup_item_ho_req_ies_o::get_presence(const uint32_t& id)
{
  if (id == 27) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_setup_item_ho_req_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeSetupItemHOReq");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_setup_item_ho_req_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_setup_item_ho_req_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_setup_item_ho_req_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeSetupItemHOReq"};
  return convert_enum_idx(options, 1, value, "erab_to_be_setup_item_ho_req_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<erab_to_be_setup_item_ctxt_su_req_ies_o>;

// E-RABToBeSwitchedDLItem ::= SEQUENCE
SRSASN_CODE erab_to_be_switched_dl_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_switched_dl_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_switched_dl_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSwitchedDLItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_switched_dl_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {23};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_switched_dl_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 23 == id;
}
crit_e erab_to_be_switched_dl_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 23) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_switched_dl_item_ies_o::value_c erab_to_be_switched_dl_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 23) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_switched_dl_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 23) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_switched_dl_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeSwitchedDLItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_switched_dl_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_switched_dl_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_switched_dl_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeSwitchedDLItem"};
  return convert_enum_idx(options, 1, value, "erab_to_be_switched_dl_item_ies_o::value_c::types");
}

// E-RABToBeSwitchedULItem ::= SEQUENCE
SRSASN_CODE erab_to_be_switched_ul_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_switched_ul_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_to_be_switched_ul_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-RABToBeSwitchedULItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t erab_to_be_switched_ul_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {94};
  return map_enum_number(options, 1, idx, "id");
}
bool erab_to_be_switched_ul_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 94 == id;
}
crit_e erab_to_be_switched_ul_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 94) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
erab_to_be_switched_ul_item_ies_o::value_c erab_to_be_switched_ul_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 94) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e erab_to_be_switched_ul_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 94) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void erab_to_be_switched_ul_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-RABToBeSwitchedULItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE erab_to_be_switched_ul_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_to_be_switched_ul_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* erab_to_be_switched_ul_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"E-RABToBeSwitchedULItem"};
  return convert_enum_idx(options, 1, value, "erab_to_be_switched_ul_item_ies_o::value_c::types");
}

// EHRPDMultiSectorLoadReportingResponseItem ::= SEQUENCE
SRSASN_CODE ehrpd_multi_sector_load_report_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(ehrpd_sector_id.pack(bref));
  HANDLE_CODE(ehrpd_sector_load_report_resp.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ehrpd_multi_sector_load_report_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(ehrpd_sector_id.unpack(bref));
  HANDLE_CODE(ehrpd_sector_load_report_resp.unpack(bref));

  return SRSASN_SUCCESS;
}
void ehrpd_multi_sector_load_report_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eHRPD-Sector-ID", ehrpd_sector_id.to_string());
  j.write_fieldname("eHRPDSectorLoadReportingResponse");
  ehrpd_sector_load_report_resp.to_json(j);
  j.end_obj();
}

// ENBX2ExtTLA ::= SEQUENCE
SRSASN_CODE enbx2_ext_tla_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ipsec_tla_present, 1));
  HANDLE_CODE(bref.pack(gtptl_aa_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ipsec_tla_present) {
    HANDLE_CODE(ipsec_tla.pack(bref));
  }
  if (gtptl_aa_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtptl_aa, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE enbx2_ext_tla_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ipsec_tla_present, 1));
  HANDLE_CODE(bref.unpack(gtptl_aa_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ipsec_tla_present) {
    HANDLE_CODE(ipsec_tla.unpack(bref));
  }
  if (gtptl_aa_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtptl_aa, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void enbx2_ext_tla_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ipsec_tla_present) {
    j.write_str("iPsecTLA", ipsec_tla.to_string());
  }
  if (gtptl_aa_present) {
    j.start_array("gTPTLAa");
    for (const auto& e1 : gtptl_aa) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MutingAvailabilityIndication ::= ENUMERATED
const char* muting_availability_ind_opts::to_string() const
{
  static const char* options[] = {"available", "unavailable"};
  return convert_enum_idx(options, 2, value, "muting_availability_ind_e");
}

// RLFReportInformation ::= SEQUENCE
SRSASN_CODE rlf_report_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_for_extended_bands_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.pack(bref));
  if (ue_rlf_report_container_for_extended_bands_present) {
    HANDLE_CODE(ue_rlf_report_container_for_extended_bands.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlf_report_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_for_extended_bands_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  if (ue_rlf_report_container_for_extended_bands_present) {
    HANDLE_CODE(ue_rlf_report_container_for_extended_bands.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlf_report_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uE-RLF-Report-Container", ue_rlf_report_container.to_string());
  if (ue_rlf_report_container_for_extended_bands_present) {
    j.write_str("uE-RLF-Report-Container-for-extended-bands", ue_rlf_report_container_for_extended_bands.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SynchronisationStatus ::= ENUMERATED
const char* synchronisation_status_opts::to_string() const
{
  static const char* options[] = {"synchronous", "asynchronous"};
  return convert_enum_idx(options, 2, value, "synchronisation_status_e");
}

// TimeSynchronisationInfo-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t time_synchronisation_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {207};
  return map_enum_number(options, 1, idx, "id");
}
bool time_synchronisation_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 207 == id;
}
crit_e time_synchronisation_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 207) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
time_synchronisation_info_ext_ies_o::ext_c time_synchronisation_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 207) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e time_synchronisation_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 207) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void time_synchronisation_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("MutingAvailabilityIndication", c.to_string());
  j.end_obj();
}
SRSASN_CODE time_synchronisation_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE time_synchronisation_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* time_synchronisation_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"MutingAvailabilityIndication"};
  return convert_enum_idx(options, 1, value, "time_synchronisation_info_ext_ies_o::ext_c::types");
}

// Global-en-gNB-ID ::= SEQUENCE
SRSASN_CODE global_en_g_nb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(en_g_nb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_en_g_nb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(en_g_nb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_en_g_nb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("en-gNB-ID", en_g_nb_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MutingPatternInformation ::= SEQUENCE
SRSASN_CODE muting_pattern_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(muting_pattern_offset_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern_period.pack(bref));
  if (muting_pattern_offset_present) {
    HANDLE_CODE(pack_integer(bref, muting_pattern_offset, (uint16_t)0u, (uint16_t)10239u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE muting_pattern_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(muting_pattern_offset_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern_period.unpack(bref));
  if (muting_pattern_offset_present) {
    HANDLE_CODE(unpack_integer(muting_pattern_offset, bref, (uint16_t)0u, (uint16_t)10239u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void muting_pattern_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("muting-pattern-period", muting_pattern_period.to_string());
  if (muting_pattern_offset_present) {
    j.write_int("muting-pattern-offset", muting_pattern_offset);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* muting_pattern_info_s::muting_pattern_period_opts::to_string() const
{
  static const char* options[] = {"ms0", "ms1280", "ms2560", "ms5120", "ms10240"};
  return convert_enum_idx(options, 5, value, "muting_pattern_info_s::muting_pattern_period_e_");
}
uint16_t muting_pattern_info_s::muting_pattern_period_opts::to_number() const
{
  static const uint16_t options[] = {0, 1280, 2560, 5120, 10240};
  return map_enum_number(options, 5, value, "muting_pattern_info_s::muting_pattern_period_e_");
}

// SONInformationReport ::= CHOICE
void son_info_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("rLFReportInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE son_info_report_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_report_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "son_info_report_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* son_info_report_c::types_opts::to_string() const
{
  static const char* options[] = {"rLFReportInformation"};
  return convert_enum_idx(options, 1, value, "son_info_report_c::types");
}

// TimeSynchronisationInfo ::= SEQUENCE
SRSASN_CODE time_synchronisation_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, stratum_level, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(synchronisation_status.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_synchronisation_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(stratum_level, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(synchronisation_status.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void time_synchronisation_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("stratumLevel", stratum_level);
  j.write_str("synchronisationStatus", synchronisation_status.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// X2TNLConfigurationInfo-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t x2_tnl_cfg_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {153, 193};
  return map_enum_number(options, 2, idx, "id");
}
bool x2_tnl_cfg_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {153, 193};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e x2_tnl_cfg_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 153:
      return crit_e::ignore;
    case 193:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
x2_tnl_cfg_info_ext_ies_o::ext_c x2_tnl_cfg_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 153:
      ret.set(ext_c::types::enbx2_extended_transport_layer_addresses);
      break;
    case 193:
      ret.set(ext_c::types::enb_indirect_x2_transport_layer_addresses);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e x2_tnl_cfg_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 153:
      return presence_e::optional;
    case 193:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void x2_tnl_cfg_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      c.destroy<enbx2_ext_tlas_l>();
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      c.destroy<enb_indirect_x2_transport_layer_addresses_l>();
      break;
    default:
      break;
  }
}
void x2_tnl_cfg_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      c.init<enbx2_ext_tlas_l>();
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      c.init<enb_indirect_x2_transport_layer_addresses_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
  }
}
x2_tnl_cfg_info_ext_ies_o::ext_c::ext_c(const x2_tnl_cfg_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      c.init(other.c.get<enbx2_ext_tlas_l>());
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      c.init(other.c.get<enb_indirect_x2_transport_layer_addresses_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
  }
}
x2_tnl_cfg_info_ext_ies_o::ext_c&
x2_tnl_cfg_info_ext_ies_o::ext_c::operator=(const x2_tnl_cfg_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      c.set(other.c.get<enbx2_ext_tlas_l>());
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      c.set(other.c.get<enb_indirect_x2_transport_layer_addresses_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
  }

  return *this;
}
enbx2_ext_tlas_l& x2_tnl_cfg_info_ext_ies_o::ext_c::enbx2_extended_transport_layer_addresses()
{
  assert_choice_type(types::enbx2_extended_transport_layer_addresses, type_, "Extension");
  return c.get<enbx2_ext_tlas_l>();
}
enb_indirect_x2_transport_layer_addresses_l&
x2_tnl_cfg_info_ext_ies_o::ext_c::enb_indirect_x2_transport_layer_addresses()
{
  assert_choice_type(types::enb_indirect_x2_transport_layer_addresses, type_, "Extension");
  return c.get<enb_indirect_x2_transport_layer_addresses_l>();
}
const enbx2_ext_tlas_l& x2_tnl_cfg_info_ext_ies_o::ext_c::enbx2_extended_transport_layer_addresses() const
{
  assert_choice_type(types::enbx2_extended_transport_layer_addresses, type_, "Extension");
  return c.get<enbx2_ext_tlas_l>();
}
const enb_indirect_x2_transport_layer_addresses_l&
x2_tnl_cfg_info_ext_ies_o::ext_c::enb_indirect_x2_transport_layer_addresses() const
{
  assert_choice_type(types::enb_indirect_x2_transport_layer_addresses, type_, "Extension");
  return c.get<enb_indirect_x2_transport_layer_addresses_l>();
}
void x2_tnl_cfg_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      j.start_array("ENBX2ExtTLAs");
      for (const auto& e1 : c.get<enbx2_ext_tlas_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      j.start_array("ENBIndirectX2TransportLayerAddresses");
      for (const auto& e1 : c.get<enb_indirect_x2_transport_layer_addresses_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE x2_tnl_cfg_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<enbx2_ext_tlas_l>(), 1, 16, true));
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<enb_indirect_x2_transport_layer_addresses_l>(), 1, 2, true));
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE x2_tnl_cfg_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enbx2_extended_transport_layer_addresses:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<enbx2_ext_tlas_l>(), bref, 1, 16, true));
      break;
    case types::enb_indirect_x2_transport_layer_addresses:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<enb_indirect_x2_transport_layer_addresses_l>(), bref, 1, 2, true));
      break;
    default:
      log_invalid_choice_id(type_, "x2_tnl_cfg_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* x2_tnl_cfg_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"ENBX2ExtTLAs", "ENBIndirectX2TransportLayerAddresses"};
  return convert_enum_idx(options, 2, value, "x2_tnl_cfg_info_ext_ies_o::ext_c::types");
}

// EN-DCSONeNBIdentification ::= SEQUENCE
SRSASN_CODE en_dcso_nenb_identif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(globalenbid.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dcso_nenb_identif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(globalenbid.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void en_dcso_nenb_identif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globaleNBID");
  globalenbid.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EN-DCSONengNBIdentification ::= SEQUENCE
SRSASN_CODE en_dcso_neng_nb_identif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(globaleng_nbid.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dcso_neng_nb_identif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(globaleng_nbid.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void en_dcso_neng_nb_identif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalengNBID");
  globaleng_nbid.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGSTAI ::= SEQUENCE
SRSASN_CODE five_gstai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(five_gstac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_gstai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(five_gstac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_gstai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("fiveGSTAC", five_gstac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONInformation-ExtensionIE ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t son_info_ext_ie_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {206};
  return map_enum_number(options, 1, idx, "id");
}
bool son_info_ext_ie_o::is_id_valid(const uint32_t& id)
{
  return 206 == id;
}
crit_e son_info_ext_ie_o::get_crit(const uint32_t& id)
{
  if (id == 206) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
son_info_ext_ie_o::value_c son_info_ext_ie_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 206) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e son_info_ext_ie_o::get_presence(const uint32_t& id)
{
  if (id == 206) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void son_info_ext_ie_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SONInformationReport");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE son_info_ext_ie_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_ext_ie_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* son_info_ext_ie_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"SONInformationReport"};
  return convert_enum_idx(options, 1, value, "son_info_ext_ie_o::value_c::types");
}

// SONInformationReply-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t son_info_reply_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {149};
  return map_enum_number(options, 1, idx, "id");
}
bool son_info_reply_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 149 == id;
}
crit_e son_info_reply_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 149) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
son_info_reply_ext_ies_o::ext_c son_info_reply_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 149) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e son_info_reply_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 149) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void son_info_reply_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TimeSynchronisationInfo");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE son_info_reply_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_reply_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* son_info_reply_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"TimeSynchronisationInfo"};
  return convert_enum_idx(options, 1, value, "son_info_reply_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<x2_tnl_cfg_info_ext_ies_o>;

x2_tnl_cfg_info_ext_ies_container::x2_tnl_cfg_info_ext_ies_container() :
  enbx2_extended_transport_layer_addresses(153, crit_e::ignore),
  enb_indirect_x2_transport_layer_addresses(193, crit_e::ignore)
{}
SRSASN_CODE x2_tnl_cfg_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += enbx2_extended_transport_layer_addresses_present ? 1 : 0;
  nof_ies += enb_indirect_x2_transport_layer_addresses_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (enbx2_extended_transport_layer_addresses_present) {
    HANDLE_CODE(enbx2_extended_transport_layer_addresses.pack(bref));
  }
  if (enb_indirect_x2_transport_layer_addresses_present) {
    HANDLE_CODE(enb_indirect_x2_transport_layer_addresses.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE x2_tnl_cfg_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<x2_tnl_cfg_info_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 153:
        enbx2_extended_transport_layer_addresses_present = true;
        enbx2_extended_transport_layer_addresses.id      = c.id;
        enbx2_extended_transport_layer_addresses.crit    = c.crit;
        enbx2_extended_transport_layer_addresses.ext     = c.ext_value.enbx2_extended_transport_layer_addresses();
        break;
      case 193:
        enb_indirect_x2_transport_layer_addresses_present = true;
        enb_indirect_x2_transport_layer_addresses.id      = c.id;
        enb_indirect_x2_transport_layer_addresses.crit    = c.crit;
        enb_indirect_x2_transport_layer_addresses.ext     = c.ext_value.enb_indirect_x2_transport_layer_addresses();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void x2_tnl_cfg_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (enbx2_extended_transport_layer_addresses_present) {
    j.write_fieldname("");
    enbx2_extended_transport_layer_addresses.to_json(j);
  }
  if (enb_indirect_x2_transport_layer_addresses_present) {
    j.write_fieldname("");
    enb_indirect_x2_transport_layer_addresses.to_json(j);
  }
  j.end_obj();
}

// X2TNLConfigurationInfo ::= SEQUENCE
SRSASN_CODE x2_tnl_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, enbx2_transport_layer_addresses, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE x2_tnl_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(enbx2_transport_layer_addresses, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void x2_tnl_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("eNBX2TransportLayerAddresses");
  for (const auto& e1 : enbx2_transport_layer_addresses) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EN-DCTransferTypeReply ::= SEQUENCE
SRSASN_CODE en_dc_transfer_type_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourceeng_nb.pack(bref));
  HANDLE_CODE(targetenb.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dc_transfer_type_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourceeng_nb.unpack(bref));
  HANDLE_CODE(targetenb.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void en_dc_transfer_type_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceengNB");
  sourceeng_nb.to_json(j);
  j.write_fieldname("targeteNB");
  targetenb.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EN-DCTransferTypeRequest ::= SEQUENCE
SRSASN_CODE en_dc_transfer_type_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(targetenb_present, 1));
  HANDLE_CODE(bref.pack(associated_tai_present, 1));
  HANDLE_CODE(bref.pack(broadcast5_gstai_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourceenb.pack(bref));
  HANDLE_CODE(targeteng_nb.pack(bref));
  if (targetenb_present) {
    HANDLE_CODE(targetenb.pack(bref));
  }
  if (associated_tai_present) {
    HANDLE_CODE(associated_tai.pack(bref));
  }
  if (broadcast5_gstai_present) {
    HANDLE_CODE(broadcast5_gstai.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dc_transfer_type_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(targetenb_present, 1));
  HANDLE_CODE(bref.unpack(associated_tai_present, 1));
  HANDLE_CODE(bref.unpack(broadcast5_gstai_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourceenb.unpack(bref));
  HANDLE_CODE(targeteng_nb.unpack(bref));
  if (targetenb_present) {
    HANDLE_CODE(targetenb.unpack(bref));
  }
  if (associated_tai_present) {
    HANDLE_CODE(associated_tai.unpack(bref));
  }
  if (broadcast5_gstai_present) {
    HANDLE_CODE(broadcast5_gstai.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void en_dc_transfer_type_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceeNB");
  sourceenb.to_json(j);
  j.write_fieldname("targetengNB");
  targeteng_nb.to_json(j);
  if (targetenb_present) {
    j.write_fieldname("targeteNB");
    targetenb.to_json(j);
  }
  if (associated_tai_present) {
    j.write_fieldname("associatedTAI");
    associated_tai.to_json(j);
  }
  if (broadcast5_gstai_present) {
    j.write_fieldname("broadcast5GSTAI");
    broadcast5_gstai.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_single_container_s<son_info_ext_ie_o>;

// SONInformationReply ::= SEQUENCE
SRSASN_CODE son_info_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(x2_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (x2_tnl_cfg_info_present) {
    HANDLE_CODE(x2_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(x2_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (x2_tnl_cfg_info_present) {
    HANDLE_CODE(x2_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void son_info_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (x2_tnl_cfg_info_present) {
    j.write_fieldname("x2TNLConfigurationInfo");
    x2_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SONInformationRequest ::= ENUMERATED
const char* son_info_request_opts::to_string() const
{
  static const char* options[] = {
      "x2TNL-Configuration-Info", "time-Synchronisation-Info", "activate-Muting", "deactivate-Muting"};
  return convert_enum_idx(options, 4, value, "son_info_request_e");
}
uint8_t son_info_request_opts::to_number() const
{
  static const uint8_t options[] = {2};
  return map_enum_number(options, 1, value, "son_info_request_e");
}

// EN-DCSONTransferType ::= CHOICE
void en_dcson_transfer_type_c::destroy_()
{
  switch (type_) {
    case types::request:
      c.destroy<en_dc_transfer_type_request_s>();
      break;
    case types::reply:
      c.destroy<en_dc_transfer_type_reply_s>();
      break;
    default:
      break;
  }
}
void en_dcson_transfer_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::request:
      c.init<en_dc_transfer_type_request_s>();
      break;
    case types::reply:
      c.init<en_dc_transfer_type_reply_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
  }
}
en_dcson_transfer_type_c::en_dcson_transfer_type_c(const en_dcson_transfer_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::request:
      c.init(other.c.get<en_dc_transfer_type_request_s>());
      break;
    case types::reply:
      c.init(other.c.get<en_dc_transfer_type_reply_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
  }
}
en_dcson_transfer_type_c& en_dcson_transfer_type_c::operator=(const en_dcson_transfer_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::request:
      c.set(other.c.get<en_dc_transfer_type_request_s>());
      break;
    case types::reply:
      c.set(other.c.get<en_dc_transfer_type_reply_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
  }

  return *this;
}
en_dc_transfer_type_request_s& en_dcson_transfer_type_c::set_request()
{
  set(types::request);
  return c.get<en_dc_transfer_type_request_s>();
}
en_dc_transfer_type_reply_s& en_dcson_transfer_type_c::set_reply()
{
  set(types::reply);
  return c.get<en_dc_transfer_type_reply_s>();
}
void en_dcson_transfer_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::request:
      j.write_fieldname("request");
      c.get<en_dc_transfer_type_request_s>().to_json(j);
      break;
    case types::reply:
      j.write_fieldname("reply");
      c.get<en_dc_transfer_type_reply_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
  }
  j.end_obj();
}
SRSASN_CODE en_dcson_transfer_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::request:
      HANDLE_CODE(c.get<en_dc_transfer_type_request_s>().pack(bref));
      break;
    case types::reply:
      HANDLE_CODE(c.get<en_dc_transfer_type_reply_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dcson_transfer_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::request:
      HANDLE_CODE(c.get<en_dc_transfer_type_request_s>().unpack(bref));
      break;
    case types::reply:
      HANDLE_CODE(c.get<en_dc_transfer_type_reply_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "en_dcson_transfer_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* en_dcson_transfer_type_c::types_opts::to_string() const
{
  static const char* options[] = {"request", "reply"};
  return convert_enum_idx(options, 2, value, "en_dcson_transfer_type_c::types");
}

// SONInformation ::= CHOICE
void son_info_c::destroy_()
{
  switch (type_) {
    case types::son_info_reply:
      c.destroy<son_info_reply_s>();
      break;
    case types::son_info_ext:
      c.destroy<protocol_ie_single_container_s<son_info_ext_ie_o> >();
      break;
    default:
      break;
  }
}
void son_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_info_request:
      break;
    case types::son_info_reply:
      c.init<son_info_reply_s>();
      break;
    case types::son_info_ext:
      c.init<protocol_ie_single_container_s<son_info_ext_ie_o> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c::son_info_c(const son_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_info_request:
      c.init(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.init(other.c.get<son_info_reply_s>());
      break;
    case types::son_info_ext:
      c.init(other.c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c& son_info_c::operator=(const son_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_info_request:
      c.set(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.set(other.c.get<son_info_reply_s>());
      break;
    case types::son_info_ext:
      c.set(other.c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }

  return *this;
}
son_info_request_e& son_info_c::set_son_info_request()
{
  set(types::son_info_request);
  return c.get<son_info_request_e>();
}
son_info_reply_s& son_info_c::set_son_info_reply()
{
  set(types::son_info_reply);
  return c.get<son_info_reply_s>();
}
protocol_ie_single_container_s<son_info_ext_ie_o>& son_info_c::set_son_info_ext()
{
  set(types::son_info_ext);
  return c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >();
}
void son_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_info_request:
      j.write_str("sONInformationRequest", c.get<son_info_request_e>().to_string());
      break;
    case types::son_info_reply:
      j.write_fieldname("sONInformationReply");
      c.get<son_info_reply_s>().to_json(j);
      break;
    case types::son_info_ext:
      j.write_fieldname("sONInformation-Extension");
      c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
  j.end_obj();
}
SRSASN_CODE son_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().pack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().pack(bref));
      break;
    case types::son_info_ext: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().unpack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().unpack(bref));
      break;
    case types::son_info_ext: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ie_o> >().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_info_c::types_opts::to_string() const
{
  static const char* options[] = {"sONInformationRequest", "sONInformationReply", "sONInformation-Extension"};
  return convert_enum_idx(options, 3, value, "son_info_c::types");
}

// EN-DCSONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE en_dcson_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(x2_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transfertype.pack(bref));
  HANDLE_CODE(son_info.pack(bref));
  if (x2_tnl_cfg_info_present) {
    HANDLE_CODE(x2_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE en_dcson_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(x2_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transfertype.unpack(bref));
  HANDLE_CODE(son_info.unpack(bref));
  if (x2_tnl_cfg_info_present) {
    HANDLE_CODE(x2_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void en_dcson_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("transfertype");
  transfertype.to_json(j);
  j.write_fieldname("sONInformation");
  son_info.to_json(j);
  if (x2_tnl_cfg_info_present) {
    j.write_fieldname("x2TNLConfigInfo");
    x2_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ENB-StatusTransfer-TransparentContainer ::= SEQUENCE
SRSASN_CODE enb_status_transfer_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, bearers_subject_to_status_transfer_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_status_transfer_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(bearers_subject_to_status_transfer_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void enb_status_transfer_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("bearers-SubjectToStatusTransferList");
  for (const auto& e1 : bearers_subject_to_status_transfer_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// S-TMSI ::= SEQUENCE
SRSASN_CODE s_tmsi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mmec.pack(bref));
  HANDLE_CODE(m_tmsi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s_tmsi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mmec.unpack(bref));
  HANDLE_CODE(m_tmsi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void s_tmsi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mMEC", mmec.to_string());
  j.write_str("m-TMSI", m_tmsi.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE ul_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.pack(bref));
  HANDLE_CODE(ul_nas_count.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.unpack(bref));
  HANDLE_CODE(ul_nas_count.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ul-NAS-MAC", ul_nas_mac.to_string());
  j.write_str("ul-NAS-Count", ul_nas_count.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ENBCPRelocationIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enbcp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {8, 96, 100, 67, 254};
  return map_enum_number(options, 5, idx, "id");
}
bool enbcp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {8, 96, 100, 67, 254};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e enbcp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 8:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 67:
      return crit_e::ignore;
    case 254:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
enbcp_relocation_ind_ies_o::value_c enbcp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 96:
      ret.set(value_c::types::s_tmsi);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 254:
      ret.set(value_c::types::ul_cp_security_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enbcp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 8:
      return presence_e::mandatory;
    case 96:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 254:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void enbcp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s_tmsi:
      c.destroy<s_tmsi_s>();
      break;
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.destroy<ul_cp_security_info_s>();
      break;
    default:
      break;
  }
}
void enbcp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enb_ue_s1ap_id:
      break;
    case types::s_tmsi:
      c.init<s_tmsi_s>();
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.init<ul_cp_security_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
  }
}
enbcp_relocation_ind_ies_o::value_c::value_c(const enbcp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::s_tmsi:
      c.init(other.c.get<s_tmsi_s>());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.init(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
  }
}
enbcp_relocation_ind_ies_o::value_c&
enbcp_relocation_ind_ies_o::value_c::operator=(const enbcp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::s_tmsi:
      c.set(other.c.get<s_tmsi_s>());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.set(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint32_t& enbcp_relocation_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
s_tmsi_s& enbcp_relocation_ind_ies_o::value_c::s_tmsi()
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
eutran_cgi_s& enbcp_relocation_ind_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
tai_s& enbcp_relocation_ind_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ul_cp_security_info_s& enbcp_relocation_ind_ies_o::value_c::ul_cp_security_info()
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
const uint32_t& enbcp_relocation_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const s_tmsi_s& enbcp_relocation_ind_ies_o::value_c::s_tmsi() const
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
const eutran_cgi_s& enbcp_relocation_ind_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const tai_s& enbcp_relocation_ind_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ul_cp_security_info_s& enbcp_relocation_ind_ies_o::value_c::ul_cp_security_info() const
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
void enbcp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::s_tmsi:
      j.write_fieldname("S-TMSI");
      c.get<s_tmsi_s>().to_json(j);
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ul_cp_security_info:
      j.write_fieldname("UL-CP-SecurityInformation");
      c.get<ul_cp_security_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE enbcp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().pack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enbcp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().unpack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enbcp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enbcp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..16777215)", "S-TMSI", "EUTRAN-CGI", "TAI", "UL-CP-SecurityInformation"};
  return convert_enum_idx(options, 5, value, "enbcp_relocation_ind_ies_o::value_c::types");
}
uint8_t enbcp_relocation_ind_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {0};
  return map_enum_number(options, 1, value, "enbcp_relocation_ind_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<enbcp_relocation_ind_ies_o>;

enbcp_relocation_ind_ies_container::enbcp_relocation_ind_ies_container() :
  enb_ue_s1ap_id(8, crit_e::reject),
  s_tmsi(96, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  tai(67, crit_e::ignore),
  ul_cp_security_info(254, crit_e::reject)
{}
SRSASN_CODE enbcp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(s_tmsi.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(ul_cp_security_info.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enbcp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<enbcp_relocation_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 96:
        nof_mandatory_ies--;
        s_tmsi.id    = c.id;
        s_tmsi.crit  = c.crit;
        s_tmsi.value = c.value.s_tmsi();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 254:
        nof_mandatory_ies--;
        ul_cp_security_info.id    = c.id;
        ul_cp_security_info.crit  = c.crit;
        ul_cp_security_info.value = c.value.ul_cp_security_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void enbcp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  s_tmsi.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  ul_cp_security_info.to_json(j);
  j.end_obj();
}

// ENBCPRelocationIndication ::= SEQUENCE
SRSASN_CODE enbcp_relocation_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enbcp_relocation_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void enbcp_relocation_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// ListeningSubframePattern ::= SEQUENCE
SRSASN_CODE listening_sf_pattern_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pattern_period.pack(bref));
  HANDLE_CODE(pack_integer(bref, pattern_offset, (uint16_t)0u, (uint16_t)10239u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE listening_sf_pattern_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pattern_period.unpack(bref));
  HANDLE_CODE(unpack_integer(pattern_offset, bref, (uint16_t)0u, (uint16_t)10239u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void listening_sf_pattern_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pattern-period", pattern_period.to_string());
  j.write_int("pattern-offset", pattern_offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* listening_sf_pattern_s::pattern_period_opts::to_string() const
{
  static const char* options[] = {"ms1280", "ms2560", "ms5120", "ms10240"};
  return convert_enum_idx(options, 4, value, "listening_sf_pattern_s::pattern_period_e_");
}
uint16_t listening_sf_pattern_s::pattern_period_opts::to_number() const
{
  static const uint16_t options[] = {1280, 2560, 5120, 10240};
  return map_enum_number(options, 4, value, "listening_sf_pattern_s::pattern_period_e_");
}

// SynchronisationInformation ::= SEQUENCE
SRSASN_CODE synchronisation_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(source_stratum_level_present, 1));
  HANDLE_CODE(bref.pack(listening_sf_pattern_present, 1));
  HANDLE_CODE(bref.pack(aggressore_cgi_list_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (source_stratum_level_present) {
    HANDLE_CODE(pack_integer(bref, source_stratum_level, (uint8_t)0u, (uint8_t)3u, true, true));
  }
  if (listening_sf_pattern_present) {
    HANDLE_CODE(listening_sf_pattern.pack(bref));
  }
  if (aggressore_cgi_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, aggressore_cgi_list, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE synchronisation_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(source_stratum_level_present, 1));
  HANDLE_CODE(bref.unpack(listening_sf_pattern_present, 1));
  HANDLE_CODE(bref.unpack(aggressore_cgi_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (source_stratum_level_present) {
    HANDLE_CODE(unpack_integer(source_stratum_level, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  }
  if (listening_sf_pattern_present) {
    HANDLE_CODE(listening_sf_pattern.unpack(bref));
  }
  if (aggressore_cgi_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(aggressore_cgi_list, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void synchronisation_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (source_stratum_level_present) {
    j.write_int("sourceStratumLevel", source_stratum_level);
  }
  if (listening_sf_pattern_present) {
    j.write_fieldname("listeningSubframePattern");
    listening_sf_pattern.to_json(j);
  }
  if (aggressore_cgi_list_present) {
    j.start_array("aggressoreCGI-List");
    for (const auto& e1 : aggressore_cgi_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONConfigurationTransfer-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t son_cfg_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {152, 209};
  return map_enum_number(options, 2, idx, "id");
}
bool son_cfg_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {152, 209};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e son_cfg_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 152:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
son_cfg_transfer_ext_ies_o::ext_c son_cfg_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 152:
      ret.set(ext_c::types::x2_tnl_cfg_info);
      break;
    case 209:
      ret.set(ext_c::types::synchronisation_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e son_cfg_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 152:
      return presence_e::conditional;
    case 209:
      return presence_e::conditional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void son_cfg_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::x2_tnl_cfg_info:
      c.destroy<x2_tnl_cfg_info_s>();
      break;
    case types::synchronisation_info:
      c.destroy<synchronisation_info_s>();
      break;
    default:
      break;
  }
}
void son_cfg_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::x2_tnl_cfg_info:
      c.init<x2_tnl_cfg_info_s>();
      break;
    case types::synchronisation_info:
      c.init<synchronisation_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
  }
}
son_cfg_transfer_ext_ies_o::ext_c::ext_c(const son_cfg_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::x2_tnl_cfg_info:
      c.init(other.c.get<x2_tnl_cfg_info_s>());
      break;
    case types::synchronisation_info:
      c.init(other.c.get<synchronisation_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
  }
}
son_cfg_transfer_ext_ies_o::ext_c&
son_cfg_transfer_ext_ies_o::ext_c::operator=(const son_cfg_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::x2_tnl_cfg_info:
      c.set(other.c.get<x2_tnl_cfg_info_s>());
      break;
    case types::synchronisation_info:
      c.set(other.c.get<synchronisation_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
x2_tnl_cfg_info_s& son_cfg_transfer_ext_ies_o::ext_c::x2_tnl_cfg_info()
{
  assert_choice_type(types::x2_tnl_cfg_info, type_, "Extension");
  return c.get<x2_tnl_cfg_info_s>();
}
synchronisation_info_s& son_cfg_transfer_ext_ies_o::ext_c::synchronisation_info()
{
  assert_choice_type(types::synchronisation_info, type_, "Extension");
  return c.get<synchronisation_info_s>();
}
const x2_tnl_cfg_info_s& son_cfg_transfer_ext_ies_o::ext_c::x2_tnl_cfg_info() const
{
  assert_choice_type(types::x2_tnl_cfg_info, type_, "Extension");
  return c.get<x2_tnl_cfg_info_s>();
}
const synchronisation_info_s& son_cfg_transfer_ext_ies_o::ext_c::synchronisation_info() const
{
  assert_choice_type(types::synchronisation_info, type_, "Extension");
  return c.get<synchronisation_info_s>();
}
void son_cfg_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::x2_tnl_cfg_info:
      j.write_fieldname("X2TNLConfigurationInfo");
      c.get<x2_tnl_cfg_info_s>().to_json(j);
      break;
    case types::synchronisation_info:
      j.write_fieldname("SynchronisationInformation");
      c.get<synchronisation_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE son_cfg_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::x2_tnl_cfg_info:
      HANDLE_CODE(c.get<x2_tnl_cfg_info_s>().pack(bref));
      break;
    case types::synchronisation_info:
      HANDLE_CODE(c.get<synchronisation_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_cfg_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::x2_tnl_cfg_info:
      HANDLE_CODE(c.get<x2_tnl_cfg_info_s>().unpack(bref));
      break;
    case types::synchronisation_info:
      HANDLE_CODE(c.get<synchronisation_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_cfg_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_cfg_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"X2TNLConfigurationInfo", "SynchronisationInformation"};
  return convert_enum_idx(options, 2, value, "son_cfg_transfer_ext_ies_o::ext_c::types");
}
uint8_t son_cfg_transfer_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t options[] = {2};
  return map_enum_number(options, 1, value, "son_cfg_transfer_ext_ies_o::ext_c::types");
}

// SourceeNB-ID ::= SEQUENCE
SRSASN_CODE sourceenb_id_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sourceenb_id_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sourceenb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-ENB-ID");
  global_enb_id.to_json(j);
  j.write_fieldname("selected-TAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargeteNB-ID ::= SEQUENCE
SRSASN_CODE targetenb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE targetenb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void targetenb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-ENB-ID");
  global_enb_id.to_json(j);
  j.write_fieldname("selected-TAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ext_field_s<son_cfg_transfer_ext_ies_o>;

son_cfg_transfer_ext_ies_container::son_cfg_transfer_ext_ies_container() :
  x2_tnl_cfg_info(152, crit_e::ignore), synchronisation_info(209, crit_e::ignore)
{}
SRSASN_CODE son_cfg_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += x2_tnl_cfg_info_present ? 1 : 0;
  nof_ies += synchronisation_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (x2_tnl_cfg_info_present) {
    HANDLE_CODE(x2_tnl_cfg_info.pack(bref));
  }
  if (synchronisation_info_present) {
    HANDLE_CODE(synchronisation_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_cfg_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<son_cfg_transfer_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 152:
        x2_tnl_cfg_info_present = true;
        x2_tnl_cfg_info.id      = c.id;
        x2_tnl_cfg_info.crit    = c.crit;
        x2_tnl_cfg_info.ext     = c.ext_value.x2_tnl_cfg_info();
        break;
      case 209:
        synchronisation_info_present = true;
        synchronisation_info.id      = c.id;
        synchronisation_info.crit    = c.crit;
        synchronisation_info.ext     = c.ext_value.synchronisation_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void son_cfg_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (x2_tnl_cfg_info_present) {
    j.write_fieldname("");
    x2_tnl_cfg_info.to_json(j);
  }
  if (synchronisation_info_present) {
    j.write_fieldname("");
    synchronisation_info.to_json(j);
  }
  j.end_obj();
}

// SONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE son_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(targetenb_id.pack(bref));
  HANDLE_CODE(sourceenb_id.pack(bref));
  HANDLE_CODE(son_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(targetenb_id.unpack(bref));
  HANDLE_CODE(sourceenb_id.unpack(bref));
  HANDLE_CODE(son_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void son_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("targeteNB-ID");
  targetenb_id.to_json(j);
  j.write_fieldname("sourceeNB-ID");
  sourceenb_id.to_json(j);
  j.write_fieldname("sONInformation");
  son_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ENBConfigurationTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {129, 294};
  return map_enum_number(options, 2, idx, "id");
}
bool enb_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {129, 294};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e enb_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 129:
      return crit_e::ignore;
    case 294:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
enb_cfg_transfer_ies_o::value_c enb_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 129:
      ret.set(value_c::types::son_cfg_transfer_ect);
      break;
    case 294:
      ret.set(value_c::types::en_dcson_cfg_transfer_ect);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 129:
      return presence_e::optional;
    case 294:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void enb_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_ect:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::en_dcson_cfg_transfer_ect:
      c.destroy<en_dcson_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void enb_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_ect:
      c.init<son_cfg_transfer_s>();
      break;
    case types::en_dcson_cfg_transfer_ect:
      c.init<en_dcson_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
  }
}
enb_cfg_transfer_ies_o::value_c::value_c(const enb_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_ect:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::en_dcson_cfg_transfer_ect:
      c.init(other.c.get<en_dcson_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
  }
}
enb_cfg_transfer_ies_o::value_c&
enb_cfg_transfer_ies_o::value_c::operator=(const enb_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_ect:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::en_dcson_cfg_transfer_ect:
      c.set(other.c.get<en_dcson_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& enb_cfg_transfer_ies_o::value_c::son_cfg_transfer_ect()
{
  assert_choice_type(types::son_cfg_transfer_ect, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
en_dcson_cfg_transfer_s& enb_cfg_transfer_ies_o::value_c::en_dcson_cfg_transfer_ect()
{
  assert_choice_type(types::en_dcson_cfg_transfer_ect, type_, "Value");
  return c.get<en_dcson_cfg_transfer_s>();
}
const son_cfg_transfer_s& enb_cfg_transfer_ies_o::value_c::son_cfg_transfer_ect() const
{
  assert_choice_type(types::son_cfg_transfer_ect, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const en_dcson_cfg_transfer_s& enb_cfg_transfer_ies_o::value_c::en_dcson_cfg_transfer_ect() const
{
  assert_choice_type(types::en_dcson_cfg_transfer_ect, type_, "Value");
  return c.get<en_dcson_cfg_transfer_s>();
}
void enb_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_ect:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::en_dcson_cfg_transfer_ect:
      j.write_fieldname("EN-DCSONConfigurationTransfer");
      c.get<en_dcson_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ect:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::en_dcson_cfg_transfer_ect:
      HANDLE_CODE(c.get<en_dcson_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ect:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::en_dcson_cfg_transfer_ect:
      HANDLE_CODE(c.get<en_dcson_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"SONConfigurationTransfer", "EN-DCSONConfigurationTransfer"};
  return convert_enum_idx(options, 2, value, "enb_cfg_transfer_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<enb_cfg_transfer_ies_o>;

enb_cfg_transfer_ies_container::enb_cfg_transfer_ies_container() :
  son_cfg_transfer_ect(129, crit_e::ignore), en_dcson_cfg_transfer_ect(294, crit_e::ignore)
{}
SRSASN_CODE enb_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_ect_present ? 1 : 0;
  nof_ies += en_dcson_cfg_transfer_ect_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_ect_present) {
    HANDLE_CODE(son_cfg_transfer_ect.pack(bref));
  }
  if (en_dcson_cfg_transfer_ect_present) {
    HANDLE_CODE(en_dcson_cfg_transfer_ect.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<enb_cfg_transfer_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 129:
        son_cfg_transfer_ect_present = true;
        son_cfg_transfer_ect.id      = c.id;
        son_cfg_transfer_ect.crit    = c.crit;
        son_cfg_transfer_ect.value   = c.value.son_cfg_transfer_ect();
        break;
      case 294:
        en_dcson_cfg_transfer_ect_present = true;
        en_dcson_cfg_transfer_ect.id      = c.id;
        en_dcson_cfg_transfer_ect.crit    = c.crit;
        en_dcson_cfg_transfer_ect.value   = c.value.en_dcson_cfg_transfer_ect();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void enb_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_ect_present) {
    j.write_fieldname("");
    son_cfg_transfer_ect.to_json(j);
  }
  if (en_dcson_cfg_transfer_ect_present) {
    j.write_fieldname("");
    en_dcson_cfg_transfer_ect.to_json(j);
  }
  j.end_obj();
}

// ENBConfigurationTransfer ::= SEQUENCE
SRSASN_CODE enb_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void enb_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// NB-IoT-DefaultPagingDRX ::= ENUMERATED
const char* nb_io_t_default_paging_drx_opts::to_string() const
{
  static const char* options[] = {"v128", "v256", "v512", "v1024"};
  return convert_enum_idx(options, 4, value, "nb_io_t_default_paging_drx_e");
}
uint16_t nb_io_t_default_paging_drx_opts::to_number() const
{
  static const uint16_t options[] = {128, 256, 512, 1024};
  return map_enum_number(options, 4, value, "nb_io_t_default_paging_drx_e");
}

// PagingDRX ::= ENUMERATED
const char* paging_drx_opts::to_string() const
{
  static const char* options[] = {"v32", "v64", "v128", "v256"};
  return convert_enum_idx(options, 4, value, "paging_drx_e");
}
uint16_t paging_drx_opts::to_number() const
{
  static const uint16_t options[] = {32, 64, 128, 256};
  return map_enum_number(options, 4, value, "paging_drx_e");
}

// ENBConfigurationUpdateIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {60, 64, 128, 137, 234, 292, 293};
  return map_enum_number(options, 7, idx, "id");
}
bool enb_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {60, 64, 128, 137, 234, 292, 293};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e enb_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 60:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    case 128:
      return crit_e::reject;
    case 137:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 292:
      return crit_e::ignore;
    case 293:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
enb_cfg_upd_ies_o::value_c enb_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 60:
      ret.set(value_c::types::enbname);
      break;
    case 64:
      ret.set(value_c::types::supported_tas);
      break;
    case 128:
      ret.set(value_c::types::csg_id_list);
      break;
    case 137:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 234:
      ret.set(value_c::types::nb_io_t_default_paging_drx);
      break;
    case 292:
      ret.set(value_c::types::connectedeng_nb_to_add_list);
      break;
    case 293:
      ret.set(value_c::types::connectedeng_nb_to_rem_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 60:
      return presence_e::optional;
    case 64:
      return presence_e::optional;
    case 128:
      return presence_e::optional;
    case 137:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 292:
      return presence_e::optional;
    case 293:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void enb_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::enbname:
      c.destroy<printable_string<1, 150, true, true> >();
      break;
    case types::supported_tas:
      c.destroy<supported_tas_l>();
      break;
    case types::csg_id_list:
      c.destroy<csg_id_list_l>();
      break;
    case types::connectedeng_nb_to_add_list:
      c.destroy<connectedeng_nb_list_l>();
      break;
    case types::connectedeng_nb_to_rem_list:
      c.destroy<connectedeng_nb_list_l>();
      break;
    default:
      break;
  }
}
void enb_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enbname:
      c.init<printable_string<1, 150, true, true> >();
      break;
    case types::supported_tas:
      c.init<supported_tas_l>();
      break;
    case types::csg_id_list:
      c.init<csg_id_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::nb_io_t_default_paging_drx:
      break;
    case types::connectedeng_nb_to_add_list:
      c.init<connectedeng_nb_list_l>();
      break;
    case types::connectedeng_nb_to_rem_list:
      c.init<connectedeng_nb_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
  }
}
enb_cfg_upd_ies_o::value_c::value_c(const enb_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enbname:
      c.init(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::supported_tas:
      c.init(other.c.get<supported_tas_l>());
      break;
    case types::csg_id_list:
      c.init(other.c.get<csg_id_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::nb_io_t_default_paging_drx:
      c.init(other.c.get<nb_io_t_default_paging_drx_e>());
      break;
    case types::connectedeng_nb_to_add_list:
      c.init(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::connectedeng_nb_to_rem_list:
      c.init(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
  }
}
enb_cfg_upd_ies_o::value_c& enb_cfg_upd_ies_o::value_c::operator=(const enb_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enbname:
      c.set(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::supported_tas:
      c.set(other.c.get<supported_tas_l>());
      break;
    case types::csg_id_list:
      c.set(other.c.get<csg_id_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::nb_io_t_default_paging_drx:
      c.set(other.c.get<nb_io_t_default_paging_drx_e>());
      break;
    case types::connectedeng_nb_to_add_list:
      c.set(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::connectedeng_nb_to_rem_list:
      c.set(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& enb_cfg_upd_ies_o::value_c::enbname()
{
  assert_choice_type(types::enbname, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
supported_tas_l& enb_cfg_upd_ies_o::value_c::supported_tas()
{
  assert_choice_type(types::supported_tas, type_, "Value");
  return c.get<supported_tas_l>();
}
csg_id_list_l& enb_cfg_upd_ies_o::value_c::csg_id_list()
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
paging_drx_e& enb_cfg_upd_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
nb_io_t_default_paging_drx_e& enb_cfg_upd_ies_o::value_c::nb_io_t_default_paging_drx()
{
  assert_choice_type(types::nb_io_t_default_paging_drx, type_, "Value");
  return c.get<nb_io_t_default_paging_drx_e>();
}
connectedeng_nb_list_l& enb_cfg_upd_ies_o::value_c::connectedeng_nb_to_add_list()
{
  assert_choice_type(types::connectedeng_nb_to_add_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
connectedeng_nb_list_l& enb_cfg_upd_ies_o::value_c::connectedeng_nb_to_rem_list()
{
  assert_choice_type(types::connectedeng_nb_to_rem_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
const printable_string<1, 150, true, true>& enb_cfg_upd_ies_o::value_c::enbname() const
{
  assert_choice_type(types::enbname, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
const supported_tas_l& enb_cfg_upd_ies_o::value_c::supported_tas() const
{
  assert_choice_type(types::supported_tas, type_, "Value");
  return c.get<supported_tas_l>();
}
const csg_id_list_l& enb_cfg_upd_ies_o::value_c::csg_id_list() const
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
const paging_drx_e& enb_cfg_upd_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const nb_io_t_default_paging_drx_e& enb_cfg_upd_ies_o::value_c::nb_io_t_default_paging_drx() const
{
  assert_choice_type(types::nb_io_t_default_paging_drx, type_, "Value");
  return c.get<nb_io_t_default_paging_drx_e>();
}
const connectedeng_nb_list_l& enb_cfg_upd_ies_o::value_c::connectedeng_nb_to_add_list() const
{
  assert_choice_type(types::connectedeng_nb_to_add_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
const connectedeng_nb_list_l& enb_cfg_upd_ies_o::value_c::connectedeng_nb_to_rem_list() const
{
  assert_choice_type(types::connectedeng_nb_to_rem_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
void enb_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enbname:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true> >().to_string());
      break;
    case types::supported_tas:
      j.start_array("SupportedTAs");
      for (const auto& e1 : c.get<supported_tas_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::csg_id_list:
      j.start_array("CSG-IdList");
      for (const auto& e1 : c.get<csg_id_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::nb_io_t_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_io_t_default_paging_drx_e>().to_string());
      break;
    case types::connectedeng_nb_to_add_list:
      j.start_array("ConnectedengNBList");
      for (const auto& e1 : c.get<connectedeng_nb_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::connectedeng_nb_to_rem_list:
      j.start_array("ConnectedengNBList");
      for (const auto& e1 : c.get<connectedeng_nb_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enbname:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().pack(bref)));
      break;
    case types::supported_tas:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_tas_l>(), 1, 256, true));
      break;
    case types::csg_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<csg_id_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::nb_io_t_default_paging_drx:
      HANDLE_CODE(c.get<nb_io_t_default_paging_drx_e>().pack(bref));
      break;
    case types::connectedeng_nb_to_add_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<connectedeng_nb_list_l>(), 1, 256, true));
      break;
    case types::connectedeng_nb_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<connectedeng_nb_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enbname:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().unpack(bref)));
      break;
    case types::supported_tas:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_tas_l>(), bref, 1, 256, true));
      break;
    case types::csg_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<csg_id_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::nb_io_t_default_paging_drx:
      HANDLE_CODE(c.get<nb_io_t_default_paging_drx_e>().unpack(bref));
      break;
    case types::connectedeng_nb_to_add_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<connectedeng_nb_list_l>(), bref, 1, 256, true));
      break;
    case types::connectedeng_nb_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<connectedeng_nb_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"PrintableString",
                                  "SupportedTAs",
                                  "CSG-IdList",
                                  "PagingDRX",
                                  "NB-IoT-DefaultPagingDRX",
                                  "ConnectedengNBList",
                                  "ConnectedengNBList"};
  return convert_enum_idx(options, 7, value, "enb_cfg_upd_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<enb_cfg_upd_ies_o>;

enb_cfg_upd_ies_container::enb_cfg_upd_ies_container() :
  enbname(60, crit_e::ignore),
  supported_tas(64, crit_e::reject),
  csg_id_list(128, crit_e::reject),
  default_paging_drx(137, crit_e::ignore),
  nb_io_t_default_paging_drx(234, crit_e::ignore),
  connectedeng_nb_to_add_list(292, crit_e::ignore),
  connectedeng_nb_to_rem_list(293, crit_e::ignore)
{}
SRSASN_CODE enb_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += enbname_present ? 1 : 0;
  nof_ies += supported_tas_present ? 1 : 0;
  nof_ies += csg_id_list_present ? 1 : 0;
  nof_ies += default_paging_drx_present ? 1 : 0;
  nof_ies += nb_io_t_default_paging_drx_present ? 1 : 0;
  nof_ies += connectedeng_nb_to_add_list_present ? 1 : 0;
  nof_ies += connectedeng_nb_to_rem_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (enbname_present) {
    HANDLE_CODE(enbname.pack(bref));
  }
  if (supported_tas_present) {
    HANDLE_CODE(supported_tas.pack(bref));
  }
  if (csg_id_list_present) {
    HANDLE_CODE(csg_id_list.pack(bref));
  }
  if (default_paging_drx_present) {
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (nb_io_t_default_paging_drx_present) {
    HANDLE_CODE(nb_io_t_default_paging_drx.pack(bref));
  }
  if (connectedeng_nb_to_add_list_present) {
    HANDLE_CODE(connectedeng_nb_to_add_list.pack(bref));
  }
  if (connectedeng_nb_to_rem_list_present) {
    HANDLE_CODE(connectedeng_nb_to_rem_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<enb_cfg_upd_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 60:
        enbname_present = true;
        enbname.id      = c.id;
        enbname.crit    = c.crit;
        enbname.value   = c.value.enbname();
        break;
      case 64:
        supported_tas_present = true;
        supported_tas.id      = c.id;
        supported_tas.crit    = c.crit;
        supported_tas.value   = c.value.supported_tas();
        break;
      case 128:
        csg_id_list_present = true;
        csg_id_list.id      = c.id;
        csg_id_list.crit    = c.crit;
        csg_id_list.value   = c.value.csg_id_list();
        break;
      case 137:
        default_paging_drx_present = true;
        default_paging_drx.id      = c.id;
        default_paging_drx.crit    = c.crit;
        default_paging_drx.value   = c.value.default_paging_drx();
        break;
      case 234:
        nb_io_t_default_paging_drx_present = true;
        nb_io_t_default_paging_drx.id      = c.id;
        nb_io_t_default_paging_drx.crit    = c.crit;
        nb_io_t_default_paging_drx.value   = c.value.nb_io_t_default_paging_drx();
        break;
      case 292:
        connectedeng_nb_to_add_list_present = true;
        connectedeng_nb_to_add_list.id      = c.id;
        connectedeng_nb_to_add_list.crit    = c.crit;
        connectedeng_nb_to_add_list.value   = c.value.connectedeng_nb_to_add_list();
        break;
      case 293:
        connectedeng_nb_to_rem_list_present = true;
        connectedeng_nb_to_rem_list.id      = c.id;
        connectedeng_nb_to_rem_list.crit    = c.crit;
        connectedeng_nb_to_rem_list.value   = c.value.connectedeng_nb_to_rem_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void enb_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (enbname_present) {
    j.write_fieldname("");
    enbname.to_json(j);
  }
  if (supported_tas_present) {
    j.write_fieldname("");
    supported_tas.to_json(j);
  }
  if (csg_id_list_present) {
    j.write_fieldname("");
    csg_id_list.to_json(j);
  }
  if (default_paging_drx_present) {
    j.write_fieldname("");
    default_paging_drx.to_json(j);
  }
  if (nb_io_t_default_paging_drx_present) {
    j.write_fieldname("");
    nb_io_t_default_paging_drx.to_json(j);
  }
  if (connectedeng_nb_to_add_list_present) {
    j.write_fieldname("");
    connectedeng_nb_to_add_list.to_json(j);
  }
  if (connectedeng_nb_to_rem_list_present) {
    j.write_fieldname("");
    connectedeng_nb_to_rem_list.to_json(j);
  }
  j.end_obj();
}

// ENBConfigurationUpdate ::= SEQUENCE
SRSASN_CODE enb_cfg_upd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void enb_cfg_upd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// ENBConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {58};
  return map_enum_number(options, 1, idx, "id");
}
bool enb_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 58 == id;
}
crit_e enb_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 58) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
enb_cfg_upd_ack_ies_o::value_c enb_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 58) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 58) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void enb_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE enb_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* enb_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"CriticalityDiagnostics"};
  return convert_enum_idx(options, 1, value, "enb_cfg_upd_ack_ies_o::value_c::types");
}

// ENBConfigurationUpdateAcknowledge ::= SEQUENCE
SRSASN_CODE enb_cfg_upd_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void enb_cfg_upd_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

// TimeToWait ::= ENUMERATED
const char* time_to_wait_opts::to_string() const
{
  static const char* options[] = {"v1s", "v2s", "v5s", "v10s", "v20s", "v60s"};
  return convert_enum_idx(options, 6, value, "time_to_wait_e");
}
uint8_t time_to_wait_opts::to_number() const
{
  static const uint8_t options[] = {1, 2, 5, 10, 20, 60};
  return map_enum_number(options, 6, value, "time_to_wait_e");
}

// ENBConfigurationUpdateFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {2, 65, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool enb_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {2, 65, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e enb_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
enb_cfg_upd_fail_ies_o::value_c enb_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 65:
      ret.set(value_c::types::time_to_wait);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void enb_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void enb_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
  }
}
enb_cfg_upd_fail_ies_o::value_c::value_c(const enb_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
  }
}
enb_cfg_upd_fail_ies_o::value_c&
enb_cfg_upd_fail_ies_o::value_c::operator=(const enb_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& enb_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& enb_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& enb_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& enb_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& enb_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& enb_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void enb_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "enb_cfg_upd_fail_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<enb_cfg_upd_fail_ies_o>;

enb_cfg_upd_fail_ies_container::enb_cfg_upd_fail_ies_container() :
  cause(2, crit_e::ignore), time_to_wait(65, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE enb_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<enb_cfg_upd_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 65:
        time_to_wait_present = true;
        time_to_wait.id      = c.id;
        time_to_wait.crit    = c.crit;
        time_to_wait.value   = c.value.time_to_wait();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void enb_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// ENBConfigurationUpdateFailure ::= SEQUENCE
SRSASN_CODE enb_cfg_upd_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_cfg_upd_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void enb_cfg_upd_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// LAI ::= SEQUENCE
SRSASN_CODE lai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.pack(bref));
  HANDLE_CODE(lac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plm_nid.unpack(bref));
  HANDLE_CODE(lac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plm_nid.to_string());
  j.write_str("lAC", lac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GERAN-Cell-ID ::= SEQUENCE
SRSASN_CODE geran_cell_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(lai.pack(bref));
  HANDLE_CODE(rac.pack(bref));
  HANDLE_CODE(ci.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE geran_cell_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(lai.unpack(bref));
  HANDLE_CODE(rac.unpack(bref));
  HANDLE_CODE(ci.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void geran_cell_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lAI");
  lai.to_json(j);
  j.write_str("rAC", rac.to_string());
  j.write_str("cI", ci.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetRNC-ID ::= SEQUENCE
SRSASN_CODE target_rnc_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rac_present, 1));
  HANDLE_CODE(bref.pack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(lai.pack(bref));
  if (rac_present) {
    HANDLE_CODE(rac.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, rnc_id, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(pack_integer(bref, extended_rnc_id, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_rnc_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rac_present, 1));
  HANDLE_CODE(bref.unpack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(lai.unpack(bref));
  if (rac_present) {
    HANDLE_CODE(rac.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(rnc_id, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(unpack_integer(extended_rnc_id, bref, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_rnc_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lAI");
  lai.to_json(j);
  if (rac_present) {
    j.write_str("rAC", rac.to_string());
  }
  j.write_int("rNC-ID", rnc_id);
  if (extended_rnc_id_present) {
    j.write_int("extendedRNC-ID", extended_rnc_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RIMRoutingAddress ::= CHOICE
void rim_routing_address_c::destroy_()
{
  switch (type_) {
    case types::geran_cell_id:
      c.destroy<geran_cell_id_s>();
      break;
    case types::target_rnc_id:
      c.destroy<target_rnc_id_s>();
      break;
    case types::ehrpd_sector_id:
      c.destroy<fixed_octstring<16, true> >();
      break;
    default:
      break;
  }
}
void rim_routing_address_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::geran_cell_id:
      c.init<geran_cell_id_s>();
      break;
    case types::target_rnc_id:
      c.init<target_rnc_id_s>();
      break;
    case types::ehrpd_sector_id:
      c.init<fixed_octstring<16, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
  }
}
rim_routing_address_c::rim_routing_address_c(const rim_routing_address_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::geran_cell_id:
      c.init(other.c.get<geran_cell_id_s>());
      break;
    case types::target_rnc_id:
      c.init(other.c.get<target_rnc_id_s>());
      break;
    case types::ehrpd_sector_id:
      c.init(other.c.get<fixed_octstring<16, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
  }
}
rim_routing_address_c& rim_routing_address_c::operator=(const rim_routing_address_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::geran_cell_id:
      c.set(other.c.get<geran_cell_id_s>());
      break;
    case types::target_rnc_id:
      c.set(other.c.get<target_rnc_id_s>());
      break;
    case types::ehrpd_sector_id:
      c.set(other.c.get<fixed_octstring<16, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
  }

  return *this;
}
geran_cell_id_s& rim_routing_address_c::set_geran_cell_id()
{
  set(types::geran_cell_id);
  return c.get<geran_cell_id_s>();
}
target_rnc_id_s& rim_routing_address_c::set_target_rnc_id()
{
  set(types::target_rnc_id);
  return c.get<target_rnc_id_s>();
}
fixed_octstring<16, true>& rim_routing_address_c::set_ehrpd_sector_id()
{
  set(types::ehrpd_sector_id);
  return c.get<fixed_octstring<16, true> >();
}
void rim_routing_address_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::geran_cell_id:
      j.write_fieldname("gERAN-Cell-ID");
      c.get<geran_cell_id_s>().to_json(j);
      break;
    case types::target_rnc_id:
      j.write_fieldname("targetRNC-ID");
      c.get<target_rnc_id_s>().to_json(j);
      break;
    case types::ehrpd_sector_id:
      j.write_str("eHRPD-Sector-ID", c.get<fixed_octstring<16, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
  }
  j.end_obj();
}
SRSASN_CODE rim_routing_address_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::geran_cell_id:
      HANDLE_CODE(c.get<geran_cell_id_s>().pack(bref));
      break;
    case types::target_rnc_id: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<target_rnc_id_s>().pack(bref));
    } break;
    case types::ehrpd_sector_id: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_octstring<16, true> >().pack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_routing_address_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::geran_cell_id:
      HANDLE_CODE(c.get<geran_cell_id_s>().unpack(bref));
      break;
    case types::target_rnc_id: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<target_rnc_id_s>().unpack(bref));
    } break;
    case types::ehrpd_sector_id: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE((c.get<fixed_octstring<16, true> >().unpack(bref)));
    } break;
    default:
      log_invalid_choice_id(type_, "rim_routing_address_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rim_routing_address_c::types_opts::to_string() const
{
  static const char* options[] = {"gERAN-Cell-ID", "targetRNC-ID", "eHRPD-Sector-ID"};
  return convert_enum_idx(options, 3, value, "rim_routing_address_c::types");
}

// RIMTransfer ::= SEQUENCE
SRSASN_CODE rim_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(rim_routing_address_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rim_info.pack(bref));
  if (rim_routing_address_present) {
    HANDLE_CODE(rim_routing_address.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(rim_routing_address_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rim_info.unpack(bref));
  if (rim_routing_address_present) {
    HANDLE_CODE(rim_routing_address.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rim_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rIMInformation", rim_info.to_string());
  if (rim_routing_address_present) {
    j.write_fieldname("rIMRoutingAddress");
    rim_routing_address.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Inter-SystemInformationTransferType ::= CHOICE
void inter_sys_info_transfer_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("rIMTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE inter_sys_info_transfer_type_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_info_transfer_type_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "inter_sys_info_transfer_type_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* inter_sys_info_transfer_type_c::types_opts::to_string() const
{
  static const char* options[] = {"rIMTransfer"};
  return convert_enum_idx(options, 1, value, "inter_sys_info_transfer_type_c::types");
}

// ENBDirectInformationTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_direct_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {121};
  return map_enum_number(options, 1, idx, "id");
}
bool enb_direct_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 121 == id;
}
crit_e enb_direct_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 121) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
enb_direct_info_transfer_ies_o::value_c enb_direct_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 121) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_direct_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 121) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void enb_direct_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("Inter-SystemInformationTransferType");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE enb_direct_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_direct_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* enb_direct_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Inter-SystemInformationTransferType"};
  return convert_enum_idx(options, 1, value, "enb_direct_info_transfer_ies_o::value_c::types");
}

// ENBDirectInformationTransfer ::= SEQUENCE
SRSASN_CODE enb_direct_info_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_direct_info_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void enb_direct_info_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

// ENBStatusTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t enb_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 90};
  return map_enum_number(options, 3, idx, "id");
}
bool enb_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 90};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e enb_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 90:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
enb_status_transfer_ies_o::value_c enb_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 90:
      ret.set(value_c::types::enb_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e enb_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void enb_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::enb_status_transfer_transparent_container:
      c.destroy<enb_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void enb_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::enb_status_transfer_transparent_container:
      c.init<enb_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
  }
}
enb_status_transfer_ies_o::value_c::value_c(const enb_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      c.init(other.c.get<enb_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
  }
}
enb_status_transfer_ies_o::value_c&
enb_status_transfer_ies_o::value_c::operator=(const enb_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      c.set(other.c.get<enb_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& enb_status_transfer_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& enb_status_transfer_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
enb_status_transfer_transparent_container_s&
enb_status_transfer_ies_o::value_c::enb_status_transfer_transparent_container()
{
  assert_choice_type(types::enb_status_transfer_transparent_container, type_, "Value");
  return c.get<enb_status_transfer_transparent_container_s>();
}
const uint64_t& enb_status_transfer_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& enb_status_transfer_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const enb_status_transfer_transparent_container_s&
enb_status_transfer_ies_o::value_c::enb_status_transfer_transparent_container() const
{
  assert_choice_type(types::enb_status_transfer_transparent_container, type_, "Value");
  return c.get<enb_status_transfer_transparent_container_s>();
}
void enb_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      j.write_fieldname("ENB-StatusTransfer-TransparentContainer");
      c.get<enb_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::enb_status_transfer_transparent_container:
      HANDLE_CODE(c.get<enb_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::enb_status_transfer_transparent_container:
      HANDLE_CODE(c.get<enb_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "ENB-StatusTransfer-TransparentContainer"};
  return convert_enum_idx(options, 3, value, "enb_status_transfer_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<enb_status_transfer_ies_o>;

enb_status_transfer_ies_container::enb_status_transfer_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  enb_status_transfer_transparent_container(90, crit_e::reject)
{}
SRSASN_CODE enb_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<enb_status_transfer_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 90:
        nof_mandatory_ies--;
        enb_status_transfer_transparent_container.id    = c.id;
        enb_status_transfer_transparent_container.crit  = c.crit;
        enb_status_transfer_transparent_container.value = c.value.enb_status_transfer_transparent_container();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void enb_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// ENBStatusTransfer ::= SEQUENCE
SRSASN_CODE enb_status_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_status_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void enb_status_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// EUTRANResponse ::= SEQUENCE
SRSASN_CODE eutran_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(cell_id.pack(bref));
  HANDLE_CODE(eutra_ncell_load_report_resp.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(cell_id.unpack(bref));
  HANDLE_CODE(eutra_ncell_load_report_resp.unpack(bref));

  return SRSASN_SUCCESS;
}
void eutran_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cell-ID", cell_id.to_string());
  j.write_fieldname("eUTRANcellLoadReportingResponse");
  eutra_ncell_load_report_resp.to_json(j);
  j.end_obj();
}

// ErrorIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t error_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58, 96};
  return map_enum_number(options, 5, idx, "id");
}
bool error_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58, 96};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e error_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 96:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
error_ind_ies_o::value_c error_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 96:
      ret.set(value_c::types::s_tmsi);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e error_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::optional;
    case 8:
      return presence_e::optional;
    case 2:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 96:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void error_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::s_tmsi:
      c.destroy<s_tmsi_s>();
      break;
    default:
      break;
  }
}
void error_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::s_tmsi:
      c.init<s_tmsi_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c::value_c(const error_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::s_tmsi:
      c.init(other.c.get<s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c& error_ind_ies_o::value_c::operator=(const error_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::s_tmsi:
      c.set(other.c.get<s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& error_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& error_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& error_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
s_tmsi_s& error_ind_ies_o::value_c::s_tmsi()
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
const uint64_t& error_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& error_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& error_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const s_tmsi_s& error_ind_ies_o::value_c::s_tmsi() const
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
void error_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::s_tmsi:
      j.write_fieldname("S-TMSI");
      c.get<s_tmsi_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE error_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* error_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics", "S-TMSI"};
  return convert_enum_idx(options, 5, value, "error_ind_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<error_ind_ies_o>;

error_ind_ies_container::error_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  s_tmsi(96, crit_e::ignore)
{}
SRSASN_CODE error_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mme_ue_s1ap_id_present ? 1 : 0;
  nof_ies += enb_ue_s1ap_id_present ? 1 : 0;
  nof_ies += cause_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += s_tmsi_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (mme_ue_s1ap_id_present) {
    HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  }
  if (enb_ue_s1ap_id_present) {
    HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  }
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (s_tmsi_present) {
    HANDLE_CODE(s_tmsi.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<error_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        mme_ue_s1ap_id_present = true;
        mme_ue_s1ap_id.id      = c.id;
        mme_ue_s1ap_id.crit    = c.crit;
        mme_ue_s1ap_id.value   = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        enb_ue_s1ap_id_present = true;
        enb_ue_s1ap_id.id      = c.id;
        enb_ue_s1ap_id.crit    = c.crit;
        enb_ue_s1ap_id.value   = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        cause_present = true;
        cause.id      = c.id;
        cause.crit    = c.crit;
        cause.value   = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 96:
        s_tmsi_present = true;
        s_tmsi.id      = c.id;
        s_tmsi.crit    = c.crit;
        s_tmsi.value   = c.value.s_tmsi();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void error_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mme_ue_s1ap_id_present) {
    j.write_fieldname("");
    mme_ue_s1ap_id.to_json(j);
  }
  if (enb_ue_s1ap_id_present) {
    j.write_fieldname("");
    enb_ue_s1ap_id.to_json(j);
  }
  if (cause_present) {
    j.write_fieldname("");
    cause.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (s_tmsi_present) {
    j.write_fieldname("");
    s_tmsi.to_json(j);
  }
  j.end_obj();
}

// ErrorIndication ::= SEQUENCE
SRSASN_CODE error_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void error_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// NumberOfMeasurementReportingLevels ::= ENUMERATED
const char* nof_meas_report_levels_opts::to_string() const
{
  static const char* options[] = {"rl2", "rl3", "rl4", "rl5", "rl10"};
  return convert_enum_idx(options, 5, value, "nof_meas_report_levels_e");
}
uint8_t nof_meas_report_levels_opts::to_number() const
{
  static const uint8_t options[] = {2, 3, 4, 5, 10};
  return map_enum_number(options, 5, value, "nof_meas_report_levels_e");
}

// EventTriggeredCellLoadReportingRequest ::= SEQUENCE
SRSASN_CODE event_triggered_cell_load_report_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(nof_meas_report_levels.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_triggered_cell_load_report_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(nof_meas_report_levels.unpack(bref));

  return SRSASN_SUCCESS;
}
void event_triggered_cell_load_report_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("numberOfMeasurementReportingLevels", nof_meas_report_levels.to_string());
  j.end_obj();
}

// OverloadFlag ::= ENUMERATED
const char* overload_flag_opts::to_string() const
{
  static const char* options[] = {"overload"};
  return convert_enum_idx(options, 1, value, "overload_flag_e");
}

// EventTriggeredCellLoadReportingResponse ::= SEQUENCE
SRSASN_CODE event_triggered_cell_load_report_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(overload_flag_present, 1));

  HANDLE_CODE(cell_load_report_resp.pack(bref));
  if (overload_flag_present) {
    HANDLE_CODE(overload_flag.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_triggered_cell_load_report_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(overload_flag_present, 1));

  HANDLE_CODE(cell_load_report_resp.unpack(bref));
  if (overload_flag_present) {
    HANDLE_CODE(overload_flag.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_triggered_cell_load_report_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cellLoadReportingResponse");
  cell_load_report_resp.to_json(j);
  if (overload_flag_present) {
    j.write_str("overloadFlag", "overload");
  }
  j.end_obj();
}

// SourceOfUEActivityBehaviourInformation ::= ENUMERATED
const char* source_of_ue_activity_behaviour_info_opts::to_string() const
{
  static const char* options[] = {"subscription-information", "statistics"};
  return convert_enum_idx(options, 2, value, "source_of_ue_activity_behaviour_info_e");
}

// ExpectedUEActivityBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_activity_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.pack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.pack(sourceof_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_activity_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_idle_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (sourceof_ue_activity_behaviour_info_present) {
    HANDLE_CODE(sourceof_ue_activity_behaviour_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_activity_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.unpack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.unpack(sourceof_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(unpack_integer(expected_activity_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(unpack_integer(expected_idle_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (sourceof_ue_activity_behaviour_info_present) {
    HANDLE_CODE(sourceof_ue_activity_behaviour_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_activity_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_activity_period_present) {
    j.write_int("expectedActivityPeriod", expected_activity_period);
  }
  if (expected_idle_period_present) {
    j.write_int("expectedIdlePeriod", expected_idle_period);
  }
  if (sourceof_ue_activity_behaviour_info_present) {
    j.write_str("sourceofUEActivityBehaviourInformation", sourceof_ue_activity_behaviour_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExpectedHOInterval ::= ENUMERATED
const char* expected_ho_interv_opts::to_string() const
{
  static const char* options[] = {"sec15", "sec30", "sec60", "sec90", "sec120", "sec180", "long-time"};
  return convert_enum_idx(options, 7, value, "expected_ho_interv_e");
}
uint8_t expected_ho_interv_opts::to_number() const
{
  static const uint8_t options[] = {15, 30, 60, 90, 120, 180};
  return map_enum_number(options, 6, value, "expected_ho_interv_e");
}

// ExpectedUEBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_activity_present, 1));
  HANDLE_CODE(bref.pack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_activity_present) {
    HANDLE_CODE(expected_activity.pack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_activity_present, 1));
  HANDLE_CODE(bref.unpack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_activity_present) {
    HANDLE_CODE(expected_activity.unpack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_activity_present) {
    j.write_fieldname("expectedActivity");
    expected_activity.to_json(j);
  }
  if (expected_ho_interv_present) {
    j.write_str("expectedHOInterval", expected_ho_interv.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TooEarlyInterRATHOReportReportFromEUTRAN ::= SEQUENCE
SRSASN_CODE too_early_inter_ratho_report_report_from_eutran_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mob_info_present, 1));

  HANDLE_CODE(uerlf_report_container.pack(bref));
  if (mob_info_present) {
    HANDLE_CODE(mob_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE too_early_inter_ratho_report_report_from_eutran_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mob_info_present, 1));

  HANDLE_CODE(uerlf_report_container.unpack(bref));
  if (mob_info_present) {
    HANDLE_CODE(mob_info.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void too_early_inter_ratho_report_report_from_eutran_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uERLFReportContainer", uerlf_report_container.to_string());
  if (mob_info_present) {
    j.write_str("mobilityInformation", mob_info.to_string());
  }
  j.end_obj();
}

// FailureEventReport ::= CHOICE
void fail_event_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tooEarlyInterRATHOReportFromEUTRAN");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE fail_event_report_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE fail_event_report_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "fail_event_report_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* fail_event_report_c::types_opts::to_string() const
{
  static const char* options[] = {"tooEarlyInterRATHOReportFromEUTRAN"};
  return convert_enum_idx(options, 1, value, "fail_event_report_c::types");
}

// HoReportType ::= ENUMERATED
const char* ho_report_type_opts::to_string() const
{
  static const char* options[] = {"unnecessaryhotoanotherrat", "earlyirathandover"};
  return convert_enum_idx(options, 2, value, "ho_report_type_e");
}

// HoType ::= ENUMERATED
const char* ho_type_opts::to_string() const
{
  static const char* options[] = {"ltetoutran", "ltetogeran"};
  return convert_enum_idx(options, 2, value, "ho_type_e");
}

// HOReport ::= SEQUENCE
SRSASN_CODE ho_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(ho_type.pack(bref));
  HANDLE_CODE(ho_report_type.pack(bref));
  HANDLE_CODE(hosource_id.pack(bref));
  HANDLE_CODE(ho_target_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_cell_list, 1, 16, true));

  if (ext) {
    HANDLE_CODE(bref.pack(candidate_pci_list.is_present(), 1));

    if (candidate_pci_list.is_present()) {
      HANDLE_CODE(pack_dyn_seq_of(bref, *candidate_pci_list, 1, 16, true));
    }
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(ho_type.unpack(bref));
  HANDLE_CODE(ho_report_type.unpack(bref));
  HANDLE_CODE(hosource_id.unpack(bref));
  HANDLE_CODE(ho_target_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(candidate_cell_list, bref, 1, 16, true));

  if (ext) {
    bool candidate_pci_list_present;
    HANDLE_CODE(bref.unpack(candidate_pci_list_present, 1));
    candidate_pci_list.set_present(candidate_pci_list_present);

    if (candidate_pci_list.is_present()) {
      HANDLE_CODE(unpack_dyn_seq_of(*candidate_pci_list, bref, 1, 16, true));
    }
  }
  return SRSASN_SUCCESS;
}
void ho_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("hoType", ho_type.to_string());
  j.write_str("hoReportType", ho_report_type.to_string());
  j.write_fieldname("hosourceID");
  hosource_id.to_json(j);
  j.write_fieldname("hoTargetID");
  ho_target_id.to_json(j);
  j.start_array("candidateCellList");
  for (const auto& e1 : candidate_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ext) {
    if (candidate_pci_list.is_present()) {
      j.start_array("candidatePCIList");
      for (const auto& e1 : *candidate_pci_list) {
        e1.to_json(j);
      }
      j.end_array();
    }
  }
  j.end_obj();
}

// HandoverCancelIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_cancel_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2};
  return map_enum_number(options, 3, idx, "id");
}
bool ho_cancel_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_cancel_ies_o::value_c ho_cancel_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ho_cancel_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c::value_c(const ho_cancel_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c& ho_cancel_ies_o::value_c::operator=(const ho_cancel_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_cancel_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& ho_cancel_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ho_cancel_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_cancel_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& ho_cancel_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ho_cancel_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause"};
  return convert_enum_idx(options, 3, value, "ho_cancel_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_cancel_ies_o>;

ho_cancel_ies_container::ho_cancel_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), cause(2, crit_e::ignore)
{}
SRSASN_CODE ho_cancel_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_cancel_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// HandoverCancel ::= SEQUENCE
SRSASN_CODE ho_cancel_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_cancel_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// HandoverCancelAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_cancel_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool ho_cancel_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_cancel_ack_ies_o::value_c ho_cancel_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cancel_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c::value_c(const ho_cancel_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c& ho_cancel_ack_ies_o::value_c::operator=(const ho_cancel_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ack_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_cancel_ack_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_cancel_ack_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cancel_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "ho_cancel_ack_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_cancel_ack_ies_o>;

ho_cancel_ack_ies_container::ho_cancel_ack_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore), enb_ue_s1ap_id(8, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ho_cancel_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_cancel_ack_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverCancelAcknowledge ::= SEQUENCE
SRSASN_CODE ho_cancel_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_cancel_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// HandoverType ::= ENUMERATED
const char* handov_type_opts::to_string() const
{
  static const char* options[] = {
      "intralte", "ltetoutran", "ltetogeran", "utrantolte", "gerantolte", "eps-to-5gs", "fivegs-to-eps"};
  return convert_enum_idx(options, 7, value, "handov_type_e");
}
int8_t handov_type_opts::to_number() const
{
  switch (value) {
    case eps_to_minus5gs:
      return -5;
    case fivegs_to_eps:
      return 5;
    default:
      invalid_enum_number(value, "handov_type_e");
  }
  return 0;
}

// HandoverCommandIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 1, 135, 12, 13, 123, 139, 58};
  return map_enum_number(options, 9, idx, "id");
}
bool ho_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 1, 135, 12, 13, 123, 139, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 1:
      return crit_e::reject;
    case 135:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 13:
      return crit_e::ignore;
    case 123:
      return crit_e::reject;
    case 139:
      return crit_e::reject;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_cmd_ies_o::value_c ho_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 1:
      ret.set(value_c::types::handov_type);
      break;
    case 135:
      ret.set(value_c::types::nas_security_paramsfrom_e_utran);
      break;
    case 12:
      ret.set(value_c::types::erab_subjectto_data_forwarding_list);
      break;
    case 13:
      ret.set(value_c::types::erab_to_release_list_ho_cmd);
      break;
    case 123:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 139:
      ret.set(value_c::types::target_to_source_transparent_container_secondary);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 1:
      return presence_e::mandatory;
    case 135:
      return presence_e::conditional;
    case 12:
      return presence_e::optional;
    case 13:
      return presence_e::optional;
    case 123:
      return presence_e::mandatory;
    case 139:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_security_paramsfrom_e_utran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.destroy<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
      break;
    case types::erab_to_release_list_ho_cmd:
      c.destroy<erab_list_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::target_to_source_transparent_container_secondary:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::handov_type:
      break;
    case types::nas_security_paramsfrom_e_utran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.init<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
      break;
    case types::erab_to_release_list_ho_cmd:
      c.init<erab_list_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true> >();
      break;
    case types::target_to_source_transparent_container_secondary:
      c.init<unbounded_octstring<true> >();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c::value_c(const ho_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::nas_security_paramsfrom_e_utran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.init(other.c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >());
      break;
    case types::erab_to_release_list_ho_cmd:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::target_to_source_transparent_container_secondary:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c& ho_cmd_ies_o::value_c::operator=(const ho_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::nas_security_paramsfrom_e_utran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::erab_subjectto_data_forwarding_list:
      c.set(other.c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >());
      break;
    case types::erab_to_release_list_ho_cmd:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::target_to_source_transparent_container_secondary:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cmd_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_cmd_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
handov_type_e& ho_cmd_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_paramsfrom_e_utran()
{
  assert_choice_type(types::nas_security_paramsfrom_e_utran, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
erab_ie_container_list_l<erab_data_forwarding_item_ies_o>& ho_cmd_ies_o::value_c::erab_subjectto_data_forwarding_list()
{
  assert_choice_type(types::erab_subjectto_data_forwarding_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
}
erab_list_l& ho_cmd_ies_o::value_c::erab_to_release_list_ho_cmd()
{
  assert_choice_type(types::erab_to_release_list_ho_cmd, type_, "Value");
  return c.get<erab_list_l>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container_secondary()
{
  assert_choice_type(types::target_to_source_transparent_container_secondary, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cmd_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_cmd_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const handov_type_e& ho_cmd_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_paramsfrom_e_utran() const
{
  assert_choice_type(types::nas_security_paramsfrom_e_utran, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const erab_ie_container_list_l<erab_data_forwarding_item_ies_o>&
ho_cmd_ies_o::value_c::erab_subjectto_data_forwarding_list() const
{
  assert_choice_type(types::erab_subjectto_data_forwarding_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >();
}
const erab_list_l& ho_cmd_ies_o::value_c::erab_to_release_list_ho_cmd() const
{
  assert_choice_type(types::erab_to_release_list_ho_cmd, type_, "Value");
  return c.get<erab_list_l>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container_secondary() const
{
  assert_choice_type(types::target_to_source_transparent_container_secondary, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::nas_security_paramsfrom_e_utran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::erab_subjectto_data_forwarding_list:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABDataForwardingItemIEs}}");
      break;
    case types::erab_to_release_list_ho_cmd:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::target_to_source_transparent_container_secondary:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::nas_security_paramsfrom_e_utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::erab_subjectto_data_forwarding_list:
      HANDLE_CODE(
          pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >(), 1, 256, true));
      break;
    case types::erab_to_release_list_ho_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::target_to_source_transparent_container_secondary:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::nas_security_paramsfrom_e_utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::erab_subjectto_data_forwarding_list:
      HANDLE_CODE(
          unpack_dyn_seq_of(c.get<erab_ie_container_list_l<erab_data_forwarding_item_ies_o> >(), bref, 1, 256, true));
      break;
    case types::erab_to_release_list_ho_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::target_to_source_transparent_container_secondary:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "HandoverType",
                                  "OCTET STRING",
                                  "E-RAB-IE-ContainerList{{E-RABDataForwardingItemIEs}}",
                                  "E-RABList",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "CriticalityDiagnostics"};
  return convert_enum_idx(options, 9, value, "ho_cmd_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_cmd_ies_o>;

ho_cmd_ies_container::ho_cmd_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  handov_type(1, crit_e::reject),
  nas_security_paramsfrom_e_utran(135, crit_e::reject),
  erab_subjectto_data_forwarding_list(12, crit_e::ignore),
  erab_to_release_list_ho_cmd(13, crit_e::ignore),
  target_to_source_transparent_container(123, crit_e::reject),
  target_to_source_transparent_container_secondary(139, crit_e::reject),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ho_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += nas_security_paramsfrom_e_utran_present ? 1 : 0;
  nof_ies += erab_subjectto_data_forwarding_list_present ? 1 : 0;
  nof_ies += erab_to_release_list_ho_cmd_present ? 1 : 0;
  nof_ies += target_to_source_transparent_container_secondary_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  if (nas_security_paramsfrom_e_utran_present) {
    HANDLE_CODE(nas_security_paramsfrom_e_utran.pack(bref));
  }
  if (erab_subjectto_data_forwarding_list_present) {
    HANDLE_CODE(erab_subjectto_data_forwarding_list.pack(bref));
  }
  if (erab_to_release_list_ho_cmd_present) {
    HANDLE_CODE(erab_to_release_list_ho_cmd.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (target_to_source_transparent_container_secondary_present) {
    HANDLE_CODE(target_to_source_transparent_container_secondary.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_cmd_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 1:
        nof_mandatory_ies--;
        handov_type.id    = c.id;
        handov_type.crit  = c.crit;
        handov_type.value = c.value.handov_type();
        break;
      case 135:
        nas_security_paramsfrom_e_utran_present = true;
        nas_security_paramsfrom_e_utran.id      = c.id;
        nas_security_paramsfrom_e_utran.crit    = c.crit;
        nas_security_paramsfrom_e_utran.value   = c.value.nas_security_paramsfrom_e_utran();
        break;
      case 12:
        erab_subjectto_data_forwarding_list_present = true;
        erab_subjectto_data_forwarding_list.id      = c.id;
        erab_subjectto_data_forwarding_list.crit    = c.crit;
        erab_subjectto_data_forwarding_list.value   = c.value.erab_subjectto_data_forwarding_list();
        break;
      case 13:
        erab_to_release_list_ho_cmd_present = true;
        erab_to_release_list_ho_cmd.id      = c.id;
        erab_to_release_list_ho_cmd.crit    = c.crit;
        erab_to_release_list_ho_cmd.value   = c.value.erab_to_release_list_ho_cmd();
        break;
      case 123:
        nof_mandatory_ies--;
        target_to_source_transparent_container.id    = c.id;
        target_to_source_transparent_container.crit  = c.crit;
        target_to_source_transparent_container.value = c.value.target_to_source_transparent_container();
        break;
      case 139:
        target_to_source_transparent_container_secondary_present = true;
        target_to_source_transparent_container_secondary.id      = c.id;
        target_to_source_transparent_container_secondary.crit    = c.crit;
        target_to_source_transparent_container_secondary.value =
            c.value.target_to_source_transparent_container_secondary();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  if (nas_security_paramsfrom_e_utran_present) {
    j.write_fieldname("");
    nas_security_paramsfrom_e_utran.to_json(j);
  }
  if (erab_subjectto_data_forwarding_list_present) {
    j.write_fieldname("");
    erab_subjectto_data_forwarding_list.to_json(j);
  }
  if (erab_to_release_list_ho_cmd_present) {
    j.write_fieldname("");
    erab_to_release_list_ho_cmd.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (target_to_source_transparent_container_secondary_present) {
    j.write_fieldname("");
    target_to_source_transparent_container_secondary.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverCommand ::= SEQUENCE
SRSASN_CODE ho_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// HandoverFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 2, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool ho_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_fail_ies_o::value_c ho_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c::value_c(const ho_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c& ho_fail_ies_o::value_c::operator=(const ho_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "ho_fail_ies_o::value_c::types");
}
uint8_t ho_fail_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {0};
  return map_enum_number(options, 1, value, "ho_fail_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_fail_ies_o>;

ho_fail_ies_container::ho_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore), cause(2, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ho_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverFailure ::= SEQUENCE
SRSASN_CODE ho_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// HandoverNotifyIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 100, 67, 176, 186, 288};
  return map_enum_number(options, 7, idx, "id");
}
bool ho_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 100, 67, 176, 186, 288};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 67:
      return crit_e::ignore;
    case 176:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_notify_ies_o::value_c ho_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 176:
      ret.set(value_c::types::tunnel_info_for_bbf);
      break;
    case 186:
      ret.set(value_c::types::lhn_id);
      break;
    case 288:
      ret.set(value_c::types::ps_cell_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 176:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 288:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::tunnel_info_for_bbf:
      c.destroy<tunnel_info_s>();
      break;
    case types::lhn_id:
      c.destroy<bounded_octstring<32, 256, true> >();
      break;
    case types::ps_cell_info:
      c.destroy<ps_cell_info_s>();
      break;
    default:
      break;
  }
}
void ho_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::tunnel_info_for_bbf:
      c.init<tunnel_info_s>();
      break;
    case types::lhn_id:
      c.init<bounded_octstring<32, 256, true> >();
      break;
    case types::ps_cell_info:
      c.init<ps_cell_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c::value_c(const ho_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::tunnel_info_for_bbf:
      c.init(other.c.get<tunnel_info_s>());
      break;
    case types::lhn_id:
      c.init(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::ps_cell_info:
      c.init(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c& ho_notify_ies_o::value_c::operator=(const ho_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::tunnel_info_for_bbf:
      c.set(other.c.get<tunnel_info_s>());
      break;
    case types::lhn_id:
      c.set(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::ps_cell_info:
      c.set(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_notify_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_notify_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
eutran_cgi_s& ho_notify_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
tai_s& ho_notify_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
tunnel_info_s& ho_notify_ies_o::value_c::tunnel_info_for_bbf()
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
bounded_octstring<32, 256, true>& ho_notify_ies_o::value_c::lhn_id()
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
ps_cell_info_s& ho_notify_ies_o::value_c::ps_cell_info()
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
const uint64_t& ho_notify_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_notify_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const eutran_cgi_s& ho_notify_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const tai_s& ho_notify_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const tunnel_info_s& ho_notify_ies_o::value_c::tunnel_info_for_bbf() const
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
const bounded_octstring<32, 256, true>& ho_notify_ies_o::value_c::lhn_id() const
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
const ps_cell_info_s& ho_notify_ies_o::value_c::ps_cell_info() const
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
void ho_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::tunnel_info_for_bbf:
      j.write_fieldname("TunnelInformation");
      c.get<tunnel_info_s>().to_json(j);
      break;
    case types::lhn_id:
      j.write_str("OCTET STRING", c.get<bounded_octstring<32, 256, true> >().to_string());
      break;
    case types::ps_cell_info:
      j.write_fieldname("PSCellInformation");
      c.get<ps_cell_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().pack(bref));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().pack(bref)));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().unpack(bref));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().unpack(bref)));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_notify_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "EUTRAN-CGI",
                                  "TAI",
                                  "TunnelInformation",
                                  "OCTET STRING",
                                  "PSCellInformation"};
  return convert_enum_idx(options, 7, value, "ho_notify_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_notify_ies_o>;

ho_notify_ies_container::ho_notify_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  tai(67, crit_e::ignore),
  tunnel_info_for_bbf(176, crit_e::ignore),
  lhn_id(186, crit_e::ignore),
  ps_cell_info(288, crit_e::ignore)
{}
SRSASN_CODE ho_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += tunnel_info_for_bbf_present ? 1 : 0;
  nof_ies += lhn_id_present ? 1 : 0;
  nof_ies += ps_cell_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (tunnel_info_for_bbf_present) {
    HANDLE_CODE(tunnel_info_for_bbf.pack(bref));
  }
  if (lhn_id_present) {
    HANDLE_CODE(lhn_id.pack(bref));
  }
  if (ps_cell_info_present) {
    HANDLE_CODE(ps_cell_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_notify_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 176:
        tunnel_info_for_bbf_present = true;
        tunnel_info_for_bbf.id      = c.id;
        tunnel_info_for_bbf.crit    = c.crit;
        tunnel_info_for_bbf.value   = c.value.tunnel_info_for_bbf();
        break;
      case 186:
        lhn_id_present = true;
        lhn_id.id      = c.id;
        lhn_id.crit    = c.crit;
        lhn_id.value   = c.value.lhn_id();
        break;
      case 288:
        ps_cell_info_present = true;
        ps_cell_info.id      = c.id;
        ps_cell_info.crit    = c.crit;
        ps_cell_info.value   = c.value.ps_cell_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  if (tunnel_info_for_bbf_present) {
    j.write_fieldname("");
    tunnel_info_for_bbf.to_json(j);
  }
  if (lhn_id_present) {
    j.write_fieldname("");
    lhn_id.to_json(j);
  }
  if (ps_cell_info_present) {
    j.write_fieldname("");
    ps_cell_info.to_json(j);
  }
  j.end_obj();
}

// HandoverNotify ::= SEQUENCE
SRSASN_CODE ho_notify_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_notify_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// HandoverPreparationFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_prep_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool ho_prep_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_prep_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_prep_fail_ies_o::value_c ho_prep_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_prep_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_prep_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_prep_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c::value_c(const ho_prep_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c& ho_prep_fail_ies_o::value_c::operator=(const ho_prep_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_prep_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_prep_fail_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& ho_prep_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_prep_fail_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& ho_prep_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_prep_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_prep_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "ho_prep_fail_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_prep_fail_ies_o>;

ho_prep_fail_ies_container::ho_prep_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ho_prep_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_prep_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_prep_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverPreparationFailure ::= SEQUENCE
SRSASN_CODE ho_prep_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_prep_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// MBSFN-ResultToLogInfo ::= SEQUENCE
SRSASN_CODE mbsfn_result_to_log_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbsfn_area_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbsfn_area_id_present) {
    HANDLE_CODE(pack_integer(bref, mbsfn_area_id, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, carrier_freq, (uint32_t)0u, (uint32_t)262143u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbsfn_result_to_log_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbsfn_area_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbsfn_area_id_present) {
    HANDLE_CODE(unpack_integer(mbsfn_area_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(unpack_integer(carrier_freq, bref, (uint32_t)0u, (uint32_t)262143u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbsfn_result_to_log_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbsfn_area_id_present) {
    j.write_int("mBSFN-AreaId", mbsfn_area_id);
  }
  j.write_int("carrierFreq", carrier_freq);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Links-to-log ::= ENUMERATED
const char* links_to_log_opts::to_string() const
{
  static const char* options[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(options, 3, value, "links_to_log_e");
}

// LoggingDuration ::= ENUMERATED
const char* logging_dur_opts::to_string() const
{
  static const char* options[] = {"m10", "m20", "m40", "m60", "m90", "m120"};
  return convert_enum_idx(options, 6, value, "logging_dur_e");
}
uint8_t logging_dur_opts::to_number() const
{
  static const uint8_t options[] = {10, 20, 40, 60, 90, 120};
  return map_enum_number(options, 6, value, "logging_dur_e");
}

// LoggingInterval ::= ENUMERATED
const char* logging_interv_opts::to_string() const
{
  static const char* options[] = {"ms128", "ms256", "ms512", "ms1024", "ms2048", "ms3072", "ms4096", "ms6144"};
  return convert_enum_idx(options, 8, value, "logging_interv_e");
}
uint16_t logging_interv_opts::to_number() const
{
  static const uint16_t options[] = {128, 256, 512, 1024, 2048, 3072, 4096, 6144};
  return map_enum_number(options, 8, value, "logging_interv_e");
}

// M3period ::= ENUMERATED
const char* m3period_opts::to_string() const
{
  static const char* options[] = {
      "ms100", "ms1000", "ms10000", "ms1024", "ms1280", "ms2048", "ms2560", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(options, 10, value, "m3period_e");
}
uint16_t m3period_opts::to_number() const
{
  static const uint16_t options[] = {100, 1000, 10000, 1024, 1280, 2048, 2560, 5120, 10240, 1};
  return map_enum_number(options, 10, value, "m3period_e");
}

// M4period ::= ENUMERATED
const char* m4period_opts::to_string() const
{
  static const char* options[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(options, 5, value, "m4period_e");
}
uint16_t m4period_opts::to_number() const
{
  static const uint16_t options[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(options, 5, value, "m4period_e");
}

// M5period ::= ENUMERATED
const char* m5period_opts::to_string() const
{
  static const char* options[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(options, 5, value, "m5period_e");
}
uint16_t m5period_opts::to_number() const
{
  static const uint16_t options[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(options, 5, value, "m5period_e");
}

// M6delay-threshold ::= ENUMERATED
const char* m6delay_thres_opts::to_string() const
{
  static const char* options[] = {
      "ms30", "ms40", "ms50", "ms60", "ms70", "ms80", "ms90", "ms100", "ms150", "ms300", "ms500", "ms750"};
  return convert_enum_idx(options, 12, value, "m6delay_thres_e");
}
uint16_t m6delay_thres_opts::to_number() const
{
  static const uint16_t options[] = {30, 40, 50, 60, 70, 80, 90, 100, 150, 300, 500, 750};
  return map_enum_number(options, 12, value, "m6delay_thres_e");
}

// M6report-Interval ::= ENUMERATED
const char* m6report_interv_opts::to_string() const
{
  static const char* options[] = {"ms1024", "ms2048", "ms5120", "ms10240"};
  return convert_enum_idx(options, 4, value, "m6report_interv_e");
}
uint16_t m6report_interv_opts::to_number() const
{
  static const uint16_t options[] = {1024, 2048, 5120, 10240};
  return map_enum_number(options, 4, value, "m6report_interv_e");
}

// WLANMeasConfig ::= ENUMERATED
const char* wlan_meas_cfg_opts::to_string() const
{
  static const char* options[] = {"setup"};
  return convert_enum_idx(options, 1, value, "wlan_meas_cfg_e");
}

// LoggedMBSFNMDT ::= SEQUENCE
SRSASN_CODE logged_mbsfnmdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbsfn_result_to_log_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.pack(bref));
  HANDLE_CODE(logging_dur.pack(bref));
  if (mbsfn_result_to_log_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbsfn_result_to_log, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mbsfnmdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbsfn_result_to_log_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.unpack(bref));
  HANDLE_CODE(logging_dur.unpack(bref));
  if (mbsfn_result_to_log_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbsfn_result_to_log, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void logged_mbsfnmdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("loggingInterval", logging_interv.to_string());
  j.write_str("loggingDuration", logging_dur.to_string());
  if (mbsfn_result_to_log_present) {
    j.start_array("mBSFN-ResultToLog");
    for (const auto& e1 : mbsfn_result_to_log) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M3Configuration ::= SEQUENCE
SRSASN_CODE m3_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m3period.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m3_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m3period.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m3_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m3period", m3period.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration ::= SEQUENCE
SRSASN_CODE m4_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m4period.pack(bref));
  HANDLE_CODE(m4_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m4period.unpack(bref));
  HANDLE_CODE(m4_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m4_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m4period", m4period.to_string());
  j.write_str("m4-links-to-log", m4_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M5Configuration ::= SEQUENCE
SRSASN_CODE m5_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m5period.pack(bref));
  HANDLE_CODE(m5_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m5period.unpack(bref));
  HANDLE_CODE(m5_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m5_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m5period", m5period.to_string());
  j.write_str("m5-links-to-log", m5_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M6Configuration ::= SEQUENCE
SRSASN_CODE m6_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m6delay_thres_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.pack(bref));
  if (m6delay_thres_present) {
    HANDLE_CODE(m6delay_thres.pack(bref));
  }
  HANDLE_CODE(m6_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m6delay_thres_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.unpack(bref));
  if (m6delay_thres_present) {
    HANDLE_CODE(m6delay_thres.unpack(bref));
  }
  HANDLE_CODE(m6_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m6report-Interval", m6report_interv.to_string());
  if (m6delay_thres_present) {
    j.write_str("m6delay-threshold", m6delay_thres.to_string());
  }
  j.write_str("m6-links-to-log", m6_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M7Configuration ::= SEQUENCE
SRSASN_CODE m7_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, m7period, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(m7period, bref, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m7_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("m7period", m7period);
  j.write_str("m7-links-to-log", m7_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MeasurementThresholdA2 ::= CHOICE
void meas_thres_a2_c::destroy_() {}
void meas_thres_a2_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
meas_thres_a2_c::meas_thres_a2_c(const meas_thres_a2_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }
}
meas_thres_a2_c& meas_thres_a2_c::operator=(const meas_thres_a2_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }

  return *this;
}
uint8_t& meas_thres_a2_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_a2_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
void meas_thres_a2_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
  }
  j.end_obj();
}
SRSASN_CODE meas_thres_a2_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)97u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)34u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_thres_a2_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)97u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)34u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_a2_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* meas_thres_a2_c::types_opts::to_string() const
{
  static const char* options[] = {"threshold-RSRP", "threshold-RSRQ"};
  return convert_enum_idx(options, 2, value, "meas_thres_a2_c::types");
}

// ReportAmountMDT ::= ENUMERATED
const char* report_amount_mdt_opts::to_string() const
{
  static const char* options[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "rinfinity"};
  return convert_enum_idx(options, 8, value, "report_amount_mdt_e");
}
int8_t report_amount_mdt_opts::to_number() const
{
  static const int8_t options[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(options, 8, value, "report_amount_mdt_e");
}

// ReportIntervalMDT ::= ENUMERATED
const char* report_interv_mdt_opts::to_string() const
{
  static const char* options[] = {"ms120",
                                  "ms240",
                                  "ms480",
                                  "ms640",
                                  "ms1024",
                                  "ms2048",
                                  "ms5120",
                                  "ms10240",
                                  "min1",
                                  "min6",
                                  "min12",
                                  "min30",
                                  "min60"};
  return convert_enum_idx(options, 13, value, "report_interv_mdt_e");
}
uint16_t report_interv_mdt_opts::to_number() const
{
  static const uint16_t options[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 1, 6, 12, 30, 60};
  return map_enum_number(options, 13, value, "report_interv_mdt_e");
}

// WLANMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(wlan_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.pack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.pack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.pack(bref));
  if (wlan_meas_cfg_name_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, wlan_meas_cfg_name_list, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.pack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  if (wlan_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(wlan_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.unpack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wlanMeasConfig", "setup");
  if (wlan_meas_cfg_name_list_present) {
    j.start_array("wlanMeasConfigNameList");
    for (const auto& e1 : wlan_meas_cfg_name_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (wlan_rssi_present) {
    j.write_str("wlan-rssi", "true");
  }
  if (wlan_rtt_present) {
    j.write_str("wlan-rtt", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* wlan_meas_cfg_s::wlan_rssi_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "wlan_meas_cfg_s::wlan_rssi_e_");
}

const char* wlan_meas_cfg_s::wlan_rtt_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "wlan_meas_cfg_s::wlan_rtt_e_");
}

// ImmediateMDT-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t immediate_mdt_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {171, 172, 173, 174, 220, 221, 284, 285};
  return map_enum_number(options, 8, idx, "id");
}
bool immediate_mdt_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {171, 172, 173, 174, 220, 221, 284, 285};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e immediate_mdt_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 171:
      return crit_e::ignore;
    case 172:
      return crit_e::ignore;
    case 173:
      return crit_e::ignore;
    case 174:
      return crit_e::ignore;
    case 220:
      return crit_e::ignore;
    case 221:
      return crit_e::ignore;
    case 284:
      return crit_e::ignore;
    case 285:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
immediate_mdt_ext_ies_o::ext_c immediate_mdt_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 171:
      ret.set(ext_c::types::m3_cfg);
      break;
    case 172:
      ret.set(ext_c::types::m4_cfg);
      break;
    case 173:
      ret.set(ext_c::types::m5_cfg);
      break;
    case 174:
      ret.set(ext_c::types::mdt_location_info);
      break;
    case 220:
      ret.set(ext_c::types::m6_cfg);
      break;
    case 221:
      ret.set(ext_c::types::m7_cfg);
      break;
    case 284:
      ret.set(ext_c::types::bluetooth_meas_cfg);
      break;
    case 285:
      ret.set(ext_c::types::wlan_meas_cfg);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e immediate_mdt_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 171:
      return presence_e::conditional;
    case 172:
      return presence_e::conditional;
    case 173:
      return presence_e::conditional;
    case 174:
      return presence_e::optional;
    case 220:
      return presence_e::conditional;
    case 221:
      return presence_e::conditional;
    case 284:
      return presence_e::optional;
    case 285:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void immediate_mdt_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::m3_cfg:
      c.destroy<m3_cfg_s>();
      break;
    case types::m4_cfg:
      c.destroy<m4_cfg_s>();
      break;
    case types::m5_cfg:
      c.destroy<m5_cfg_s>();
      break;
    case types::mdt_location_info:
      c.destroy<fixed_bitstring<8, false, true> >();
      break;
    case types::m6_cfg:
      c.destroy<m6_cfg_s>();
      break;
    case types::m7_cfg:
      c.destroy<m7_cfg_s>();
      break;
    case types::bluetooth_meas_cfg:
      c.destroy<bluetooth_meas_cfg_s>();
      break;
    case types::wlan_meas_cfg:
      c.destroy<wlan_meas_cfg_s>();
      break;
    default:
      break;
  }
}
void immediate_mdt_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::m3_cfg:
      c.init<m3_cfg_s>();
      break;
    case types::m4_cfg:
      c.init<m4_cfg_s>();
      break;
    case types::m5_cfg:
      c.init<m5_cfg_s>();
      break;
    case types::mdt_location_info:
      c.init<fixed_bitstring<8, false, true> >();
      break;
    case types::m6_cfg:
      c.init<m6_cfg_s>();
      break;
    case types::m7_cfg:
      c.init<m7_cfg_s>();
      break;
    case types::bluetooth_meas_cfg:
      c.init<bluetooth_meas_cfg_s>();
      break;
    case types::wlan_meas_cfg:
      c.init<wlan_meas_cfg_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
  }
}
immediate_mdt_ext_ies_o::ext_c::ext_c(const immediate_mdt_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::m3_cfg:
      c.init(other.c.get<m3_cfg_s>());
      break;
    case types::m4_cfg:
      c.init(other.c.get<m4_cfg_s>());
      break;
    case types::m5_cfg:
      c.init(other.c.get<m5_cfg_s>());
      break;
    case types::mdt_location_info:
      c.init(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::m6_cfg:
      c.init(other.c.get<m6_cfg_s>());
      break;
    case types::m7_cfg:
      c.init(other.c.get<m7_cfg_s>());
      break;
    case types::bluetooth_meas_cfg:
      c.init(other.c.get<bluetooth_meas_cfg_s>());
      break;
    case types::wlan_meas_cfg:
      c.init(other.c.get<wlan_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
  }
}
immediate_mdt_ext_ies_o::ext_c& immediate_mdt_ext_ies_o::ext_c::operator=(const immediate_mdt_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::m3_cfg:
      c.set(other.c.get<m3_cfg_s>());
      break;
    case types::m4_cfg:
      c.set(other.c.get<m4_cfg_s>());
      break;
    case types::m5_cfg:
      c.set(other.c.get<m5_cfg_s>());
      break;
    case types::mdt_location_info:
      c.set(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::m6_cfg:
      c.set(other.c.get<m6_cfg_s>());
      break;
    case types::m7_cfg:
      c.set(other.c.get<m7_cfg_s>());
      break;
    case types::bluetooth_meas_cfg:
      c.set(other.c.get<bluetooth_meas_cfg_s>());
      break;
    case types::wlan_meas_cfg:
      c.set(other.c.get<wlan_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
  }

  return *this;
}
m3_cfg_s& immediate_mdt_ext_ies_o::ext_c::m3_cfg()
{
  assert_choice_type(types::m3_cfg, type_, "Extension");
  return c.get<m3_cfg_s>();
}
m4_cfg_s& immediate_mdt_ext_ies_o::ext_c::m4_cfg()
{
  assert_choice_type(types::m4_cfg, type_, "Extension");
  return c.get<m4_cfg_s>();
}
m5_cfg_s& immediate_mdt_ext_ies_o::ext_c::m5_cfg()
{
  assert_choice_type(types::m5_cfg, type_, "Extension");
  return c.get<m5_cfg_s>();
}
fixed_bitstring<8, false, true>& immediate_mdt_ext_ies_o::ext_c::mdt_location_info()
{
  assert_choice_type(types::mdt_location_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true> >();
}
m6_cfg_s& immediate_mdt_ext_ies_o::ext_c::m6_cfg()
{
  assert_choice_type(types::m6_cfg, type_, "Extension");
  return c.get<m6_cfg_s>();
}
m7_cfg_s& immediate_mdt_ext_ies_o::ext_c::m7_cfg()
{
  assert_choice_type(types::m7_cfg, type_, "Extension");
  return c.get<m7_cfg_s>();
}
bluetooth_meas_cfg_s& immediate_mdt_ext_ies_o::ext_c::bluetooth_meas_cfg()
{
  assert_choice_type(types::bluetooth_meas_cfg, type_, "Extension");
  return c.get<bluetooth_meas_cfg_s>();
}
wlan_meas_cfg_s& immediate_mdt_ext_ies_o::ext_c::wlan_meas_cfg()
{
  assert_choice_type(types::wlan_meas_cfg, type_, "Extension");
  return c.get<wlan_meas_cfg_s>();
}
const m3_cfg_s& immediate_mdt_ext_ies_o::ext_c::m3_cfg() const
{
  assert_choice_type(types::m3_cfg, type_, "Extension");
  return c.get<m3_cfg_s>();
}
const m4_cfg_s& immediate_mdt_ext_ies_o::ext_c::m4_cfg() const
{
  assert_choice_type(types::m4_cfg, type_, "Extension");
  return c.get<m4_cfg_s>();
}
const m5_cfg_s& immediate_mdt_ext_ies_o::ext_c::m5_cfg() const
{
  assert_choice_type(types::m5_cfg, type_, "Extension");
  return c.get<m5_cfg_s>();
}
const fixed_bitstring<8, false, true>& immediate_mdt_ext_ies_o::ext_c::mdt_location_info() const
{
  assert_choice_type(types::mdt_location_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true> >();
}
const m6_cfg_s& immediate_mdt_ext_ies_o::ext_c::m6_cfg() const
{
  assert_choice_type(types::m6_cfg, type_, "Extension");
  return c.get<m6_cfg_s>();
}
const m7_cfg_s& immediate_mdt_ext_ies_o::ext_c::m7_cfg() const
{
  assert_choice_type(types::m7_cfg, type_, "Extension");
  return c.get<m7_cfg_s>();
}
const bluetooth_meas_cfg_s& immediate_mdt_ext_ies_o::ext_c::bluetooth_meas_cfg() const
{
  assert_choice_type(types::bluetooth_meas_cfg, type_, "Extension");
  return c.get<bluetooth_meas_cfg_s>();
}
const wlan_meas_cfg_s& immediate_mdt_ext_ies_o::ext_c::wlan_meas_cfg() const
{
  assert_choice_type(types::wlan_meas_cfg, type_, "Extension");
  return c.get<wlan_meas_cfg_s>();
}
void immediate_mdt_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::m3_cfg:
      j.write_fieldname("M3Configuration");
      c.get<m3_cfg_s>().to_json(j);
      break;
    case types::m4_cfg:
      j.write_fieldname("M4Configuration");
      c.get<m4_cfg_s>().to_json(j);
      break;
    case types::m5_cfg:
      j.write_fieldname("M5Configuration");
      c.get<m5_cfg_s>().to_json(j);
      break;
    case types::mdt_location_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true> >().to_string());
      break;
    case types::m6_cfg:
      j.write_fieldname("M6Configuration");
      c.get<m6_cfg_s>().to_json(j);
      break;
    case types::m7_cfg:
      j.write_fieldname("M7Configuration");
      c.get<m7_cfg_s>().to_json(j);
      break;
    case types::bluetooth_meas_cfg:
      j.write_fieldname("BluetoothMeasurementConfiguration");
      c.get<bluetooth_meas_cfg_s>().to_json(j);
      break;
    case types::wlan_meas_cfg:
      j.write_fieldname("WLANMeasurementConfiguration");
      c.get<wlan_meas_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE immediate_mdt_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m3_cfg:
      HANDLE_CODE(c.get<m3_cfg_s>().pack(bref));
      break;
    case types::m4_cfg:
      HANDLE_CODE(c.get<m4_cfg_s>().pack(bref));
      break;
    case types::m5_cfg:
      HANDLE_CODE(c.get<m5_cfg_s>().pack(bref));
      break;
    case types::mdt_location_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().pack(bref)));
      break;
    case types::m6_cfg:
      HANDLE_CODE(c.get<m6_cfg_s>().pack(bref));
      break;
    case types::m7_cfg:
      HANDLE_CODE(c.get<m7_cfg_s>().pack(bref));
      break;
    case types::bluetooth_meas_cfg:
      HANDLE_CODE(c.get<bluetooth_meas_cfg_s>().pack(bref));
      break;
    case types::wlan_meas_cfg:
      HANDLE_CODE(c.get<wlan_meas_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m3_cfg:
      HANDLE_CODE(c.get<m3_cfg_s>().unpack(bref));
      break;
    case types::m4_cfg:
      HANDLE_CODE(c.get<m4_cfg_s>().unpack(bref));
      break;
    case types::m5_cfg:
      HANDLE_CODE(c.get<m5_cfg_s>().unpack(bref));
      break;
    case types::mdt_location_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().unpack(bref)));
      break;
    case types::m6_cfg:
      HANDLE_CODE(c.get<m6_cfg_s>().unpack(bref));
      break;
    case types::m7_cfg:
      HANDLE_CODE(c.get<m7_cfg_s>().unpack(bref));
      break;
    case types::bluetooth_meas_cfg:
      HANDLE_CODE(c.get<bluetooth_meas_cfg_s>().unpack(bref));
      break;
    case types::wlan_meas_cfg:
      HANDLE_CODE(c.get<wlan_meas_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "immediate_mdt_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* immediate_mdt_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"M3Configuration",
                                  "M4Configuration",
                                  "M5Configuration",
                                  "BIT STRING",
                                  "M6Configuration",
                                  "M7Configuration",
                                  "BluetoothMeasurementConfiguration",
                                  "WLANMeasurementConfiguration"};
  return convert_enum_idx(options, 8, value, "immediate_mdt_ext_ies_o::ext_c::types");
}
uint8_t immediate_mdt_ext_ies_o::ext_c::types_opts::to_number() const
{
  switch (value) {
    case m3_cfg:
      return 3;
    case m4_cfg:
      return 4;
    case m5_cfg:
      return 5;
    case m6_cfg:
      return 6;
    case m7_cfg:
      return 7;
    default:
      invalid_enum_number(value, "immediate_mdt_ext_ies_o::ext_c::types");
  }
  return 0;
}

// LoggedMDT-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t logged_mdt_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {284, 285};
  return map_enum_number(options, 2, idx, "id");
}
bool logged_mdt_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {284, 285};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e logged_mdt_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 284:
      return crit_e::ignore;
    case 285:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
logged_mdt_ext_ies_o::ext_c logged_mdt_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 284:
      ret.set(ext_c::types::bluetooth_meas_cfg);
      break;
    case 285:
      ret.set(ext_c::types::wlan_meas_cfg);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e logged_mdt_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 284:
      return presence_e::optional;
    case 285:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void logged_mdt_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::bluetooth_meas_cfg:
      c.destroy<bluetooth_meas_cfg_s>();
      break;
    case types::wlan_meas_cfg:
      c.destroy<wlan_meas_cfg_s>();
      break;
    default:
      break;
  }
}
void logged_mdt_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::bluetooth_meas_cfg:
      c.init<bluetooth_meas_cfg_s>();
      break;
    case types::wlan_meas_cfg:
      c.init<wlan_meas_cfg_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
  }
}
logged_mdt_ext_ies_o::ext_c::ext_c(const logged_mdt_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::bluetooth_meas_cfg:
      c.init(other.c.get<bluetooth_meas_cfg_s>());
      break;
    case types::wlan_meas_cfg:
      c.init(other.c.get<wlan_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
  }
}
logged_mdt_ext_ies_o::ext_c& logged_mdt_ext_ies_o::ext_c::operator=(const logged_mdt_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::bluetooth_meas_cfg:
      c.set(other.c.get<bluetooth_meas_cfg_s>());
      break;
    case types::wlan_meas_cfg:
      c.set(other.c.get<wlan_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
  }

  return *this;
}
bluetooth_meas_cfg_s& logged_mdt_ext_ies_o::ext_c::bluetooth_meas_cfg()
{
  assert_choice_type(types::bluetooth_meas_cfg, type_, "Extension");
  return c.get<bluetooth_meas_cfg_s>();
}
wlan_meas_cfg_s& logged_mdt_ext_ies_o::ext_c::wlan_meas_cfg()
{
  assert_choice_type(types::wlan_meas_cfg, type_, "Extension");
  return c.get<wlan_meas_cfg_s>();
}
const bluetooth_meas_cfg_s& logged_mdt_ext_ies_o::ext_c::bluetooth_meas_cfg() const
{
  assert_choice_type(types::bluetooth_meas_cfg, type_, "Extension");
  return c.get<bluetooth_meas_cfg_s>();
}
const wlan_meas_cfg_s& logged_mdt_ext_ies_o::ext_c::wlan_meas_cfg() const
{
  assert_choice_type(types::wlan_meas_cfg, type_, "Extension");
  return c.get<wlan_meas_cfg_s>();
}
void logged_mdt_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::bluetooth_meas_cfg:
      j.write_fieldname("BluetoothMeasurementConfiguration");
      c.get<bluetooth_meas_cfg_s>().to_json(j);
      break;
    case types::wlan_meas_cfg:
      j.write_fieldname("WLANMeasurementConfiguration");
      c.get<wlan_meas_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE logged_mdt_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bluetooth_meas_cfg:
      HANDLE_CODE(c.get<bluetooth_meas_cfg_s>().pack(bref));
      break;
    case types::wlan_meas_cfg:
      HANDLE_CODE(c.get<wlan_meas_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bluetooth_meas_cfg:
      HANDLE_CODE(c.get<bluetooth_meas_cfg_s>().unpack(bref));
      break;
    case types::wlan_meas_cfg:
      HANDLE_CODE(c.get<wlan_meas_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* logged_mdt_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"BluetoothMeasurementConfiguration", "WLANMeasurementConfiguration"};
  return convert_enum_idx(options, 2, value, "logged_mdt_ext_ies_o::ext_c::types");
}

// M1PeriodicReporting ::= SEQUENCE
SRSASN_CODE m1_periodic_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_interv.pack(bref));
  HANDLE_CODE(report_amount.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_interv.unpack(bref));
  HANDLE_CODE(report_amount.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_periodic_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportInterval", report_interv.to_string());
  j.write_str("reportAmount", report_amount.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M1ReportingTrigger ::= ENUMERATED
const char* m1_report_trigger_opts::to_string() const
{
  static const char* options[] = {"periodic", "a2eventtriggered", "a2eventtriggered-periodic"};
  return convert_enum_idx(options, 3, value, "m1_report_trigger_e");
}

// M1ThresholdEventA2 ::= SEQUENCE
SRSASN_CODE m1_thres_event_a2_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meas_thres.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_event_a2_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meas_thres.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_thres_event_a2_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("measurementThreshold");
  meas_thres.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDTMode-ExtensionIE ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mdt_mode_ext_ie_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {197};
  return map_enum_number(options, 1, idx, "id");
}
bool mdt_mode_ext_ie_o::is_id_valid(const uint32_t& id)
{
  return 197 == id;
}
crit_e mdt_mode_ext_ie_o::get_crit(const uint32_t& id)
{
  if (id == 197) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
mdt_mode_ext_ie_o::value_c mdt_mode_ext_ie_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 197) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mdt_mode_ext_ie_o::get_presence(const uint32_t& id)
{
  if (id == 197) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void mdt_mode_ext_ie_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("LoggedMBSFNMDT");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE mdt_mode_ext_ie_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_mode_ext_ie_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* mdt_mode_ext_ie_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"LoggedMBSFNMDT"};
  return convert_enum_idx(options, 1, value, "mdt_mode_ext_ie_o::value_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<immediate_mdt_ext_ies_o>;

immediate_mdt_ext_ies_container::immediate_mdt_ext_ies_container() :
  m3_cfg(171, crit_e::ignore),
  m4_cfg(172, crit_e::ignore),
  m5_cfg(173, crit_e::ignore),
  mdt_location_info(174, crit_e::ignore),
  m6_cfg(220, crit_e::ignore),
  m7_cfg(221, crit_e::ignore),
  bluetooth_meas_cfg(284, crit_e::ignore),
  wlan_meas_cfg(285, crit_e::ignore)
{}
SRSASN_CODE immediate_mdt_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += m3_cfg_present ? 1 : 0;
  nof_ies += m4_cfg_present ? 1 : 0;
  nof_ies += m5_cfg_present ? 1 : 0;
  nof_ies += mdt_location_info_present ? 1 : 0;
  nof_ies += m6_cfg_present ? 1 : 0;
  nof_ies += m7_cfg_present ? 1 : 0;
  nof_ies += bluetooth_meas_cfg_present ? 1 : 0;
  nof_ies += wlan_meas_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (m3_cfg_present) {
    HANDLE_CODE(m3_cfg.pack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.pack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.pack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.pack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.pack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.pack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<immediate_mdt_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 171:
        m3_cfg_present = true;
        m3_cfg.id      = c.id;
        m3_cfg.crit    = c.crit;
        m3_cfg.ext     = c.ext_value.m3_cfg();
        break;
      case 172:
        m4_cfg_present = true;
        m4_cfg.id      = c.id;
        m4_cfg.crit    = c.crit;
        m4_cfg.ext     = c.ext_value.m4_cfg();
        break;
      case 173:
        m5_cfg_present = true;
        m5_cfg.id      = c.id;
        m5_cfg.crit    = c.crit;
        m5_cfg.ext     = c.ext_value.m5_cfg();
        break;
      case 174:
        mdt_location_info_present = true;
        mdt_location_info.id      = c.id;
        mdt_location_info.crit    = c.crit;
        mdt_location_info.ext     = c.ext_value.mdt_location_info();
        break;
      case 220:
        m6_cfg_present = true;
        m6_cfg.id      = c.id;
        m6_cfg.crit    = c.crit;
        m6_cfg.ext     = c.ext_value.m6_cfg();
        break;
      case 221:
        m7_cfg_present = true;
        m7_cfg.id      = c.id;
        m7_cfg.crit    = c.crit;
        m7_cfg.ext     = c.ext_value.m7_cfg();
        break;
      case 284:
        bluetooth_meas_cfg_present = true;
        bluetooth_meas_cfg.id      = c.id;
        bluetooth_meas_cfg.crit    = c.crit;
        bluetooth_meas_cfg.ext     = c.ext_value.bluetooth_meas_cfg();
        break;
      case 285:
        wlan_meas_cfg_present = true;
        wlan_meas_cfg.id      = c.id;
        wlan_meas_cfg.crit    = c.crit;
        wlan_meas_cfg.ext     = c.ext_value.wlan_meas_cfg();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void immediate_mdt_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (m3_cfg_present) {
    j.write_fieldname("");
    m3_cfg.to_json(j);
  }
  if (m4_cfg_present) {
    j.write_fieldname("");
    m4_cfg.to_json(j);
  }
  if (m5_cfg_present) {
    j.write_fieldname("");
    m5_cfg.to_json(j);
  }
  if (mdt_location_info_present) {
    j.write_fieldname("");
    mdt_location_info.to_json(j);
  }
  if (m6_cfg_present) {
    j.write_fieldname("");
    m6_cfg.to_json(j);
  }
  if (m7_cfg_present) {
    j.write_fieldname("");
    m7_cfg.to_json(j);
  }
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("");
    wlan_meas_cfg.to_json(j);
  }
  j.end_obj();
}

// ImmediateMDT ::= SEQUENCE
SRSASN_CODE immediate_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1thresevent_a2_present, 1));
  HANDLE_CODE(bref.pack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.pack(bref));
  HANDLE_CODE(m1report_trigger.pack(bref));
  if (m1thresevent_a2_present) {
    HANDLE_CODE(m1thresevent_a2.pack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1thresevent_a2_present, 1));
  HANDLE_CODE(bref.unpack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.unpack(bref));
  HANDLE_CODE(m1report_trigger.unpack(bref));
  if (m1thresevent_a2_present) {
    HANDLE_CODE(m1thresevent_a2.unpack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void immediate_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("measurementsToActivate", meass_to_activ.to_string());
  j.write_str("m1reportingTrigger", m1report_trigger.to_string());
  if (m1thresevent_a2_present) {
    j.write_fieldname("m1thresholdeventA2");
    m1thresevent_a2.to_json(j);
  }
  if (m1periodic_report_present) {
    j.write_fieldname("m1periodicReporting");
    m1periodic_report.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ext_field_s<logged_mdt_ext_ies_o>;

logged_mdt_ext_ies_container::logged_mdt_ext_ies_container() :
  bluetooth_meas_cfg(284, crit_e::ignore), wlan_meas_cfg(285, crit_e::ignore)
{}
SRSASN_CODE logged_mdt_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += bluetooth_meas_cfg_present ? 1 : 0;
  nof_ies += wlan_meas_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<logged_mdt_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 284:
        bluetooth_meas_cfg_present = true;
        bluetooth_meas_cfg.id      = c.id;
        bluetooth_meas_cfg.crit    = c.crit;
        bluetooth_meas_cfg.ext     = c.ext_value.bluetooth_meas_cfg();
        break;
      case 285:
        wlan_meas_cfg_present = true;
        wlan_meas_cfg.id      = c.id;
        wlan_meas_cfg.crit    = c.crit;
        wlan_meas_cfg.ext     = c.ext_value.wlan_meas_cfg();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void logged_mdt_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("");
    wlan_meas_cfg.to_json(j);
  }
  j.end_obj();
}

// LoggedMDT ::= SEQUENCE
SRSASN_CODE logged_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.pack(bref));
  HANDLE_CODE(logging_dur.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.unpack(bref));
  HANDLE_CODE(logging_dur.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void logged_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("loggingInterval", logging_interv.to_string());
  j.write_str("loggingDuration", logging_dur.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_single_container_s<mdt_mode_ext_ie_o>;

// ServiceType ::= ENUMERATED
const char* service_type_opts::to_string() const
{
  static const char* options[] = {"qMC-for-streaming-service", "qMC-for-MTSI-service"};
  return convert_enum_idx(options, 2, value, "service_type_e");
}

// MDT-Activation ::= ENUMERATED
const char* mdt_activation_opts::to_string() const
{
  static const char* options[] = {
      "immediate-MDT-only", "immediate-MDT-and-Trace", "logged-MDT-only", "logged-MBSFN-MDT"};
  return convert_enum_idx(options, 4, value, "mdt_activation_e");
}

// MDT-Configuration-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t mdt_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {178};
  return map_enum_number(options, 1, idx, "id");
}
bool mdt_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 178 == id;
}
crit_e mdt_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 178) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
mdt_cfg_ext_ies_o::ext_c mdt_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 178) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mdt_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 178) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void mdt_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("MDTPLMNList");
  for (const auto& e1 : c) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE mdt_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16, true));
  return SRSASN_SUCCESS;
}

const char* mdt_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"MDTPLMNList"};
  return convert_enum_idx(options, 1, value, "mdt_cfg_ext_ies_o::ext_c::types");
}

// MDTMode ::= CHOICE
void mdt_mode_c::destroy_()
{
  switch (type_) {
    case types::immediate_mdt:
      c.destroy<immediate_mdt_s>();
      break;
    case types::logged_mdt:
      c.destroy<logged_mdt_s>();
      break;
    case types::mdt_mode_ext:
      c.destroy<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >();
      break;
    default:
      break;
  }
}
void mdt_mode_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::immediate_mdt:
      c.init<immediate_mdt_s>();
      break;
    case types::logged_mdt:
      c.init<logged_mdt_s>();
      break;
    case types::mdt_mode_ext:
      c.init<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
  }
}
mdt_mode_c::mdt_mode_c(const mdt_mode_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::immediate_mdt:
      c.init(other.c.get<immediate_mdt_s>());
      break;
    case types::logged_mdt:
      c.init(other.c.get<logged_mdt_s>());
      break;
    case types::mdt_mode_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
  }
}
mdt_mode_c& mdt_mode_c::operator=(const mdt_mode_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::immediate_mdt:
      c.set(other.c.get<immediate_mdt_s>());
      break;
    case types::logged_mdt:
      c.set(other.c.get<logged_mdt_s>());
      break;
    case types::mdt_mode_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
  }

  return *this;
}
immediate_mdt_s& mdt_mode_c::set_immediate_mdt()
{
  set(types::immediate_mdt);
  return c.get<immediate_mdt_s>();
}
logged_mdt_s& mdt_mode_c::set_logged_mdt()
{
  set(types::logged_mdt);
  return c.get<logged_mdt_s>();
}
protocol_ie_single_container_s<mdt_mode_ext_ie_o>& mdt_mode_c::set_mdt_mode_ext()
{
  set(types::mdt_mode_ext);
  return c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >();
}
void mdt_mode_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::immediate_mdt:
      j.write_fieldname("immediateMDT");
      c.get<immediate_mdt_s>().to_json(j);
      break;
    case types::logged_mdt:
      j.write_fieldname("loggedMDT");
      c.get<logged_mdt_s>().to_json(j);
      break;
    case types::mdt_mode_ext:
      j.write_fieldname("mDTMode-Extension");
      c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_mode_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::immediate_mdt:
      HANDLE_CODE(c.get<immediate_mdt_s>().pack(bref));
      break;
    case types::logged_mdt:
      HANDLE_CODE(c.get<logged_mdt_s>().pack(bref));
      break;
    case types::mdt_mode_ext: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_mode_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::immediate_mdt:
      HANDLE_CODE(c.get<immediate_mdt_s>().unpack(bref));
      break;
    case types::logged_mdt:
      HANDLE_CODE(c.get<logged_mdt_s>().unpack(bref));
      break;
    case types::mdt_mode_ext: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_ext_ie_o> >().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_mode_c::types_opts::to_string() const
{
  static const char* options[] = {"immediateMDT", "loggedMDT", "mDTMode-Extension"};
  return convert_enum_idx(options, 3, value, "mdt_mode_c::types");
}

// UEAppLayerMeasConfig-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t ue_app_layer_meas_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {276};
  return map_enum_number(options, 1, idx, "id");
}
bool ue_app_layer_meas_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 276 == id;
}
crit_e ue_app_layer_meas_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 276) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
ue_app_layer_meas_cfg_ext_ies_o::ext_c ue_app_layer_meas_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 276) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_app_layer_meas_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 276) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_app_layer_meas_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ServiceType", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_app_layer_meas_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_app_layer_meas_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"ServiceType"};
  return convert_enum_idx(options, 1, value, "ue_app_layer_meas_cfg_ext_ies_o::ext_c::types");
}

// MDT-Configuration ::= SEQUENCE
SRSASN_CODE mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(area_scope_of_mdt.pack(bref));
  HANDLE_CODE(mdt_mode.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(area_scope_of_mdt.unpack(bref));
  HANDLE_CODE(mdt_mode.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_fieldname("areaScopeOfMDT");
  area_scope_of_mdt.to_json(j);
  j.write_fieldname("mDTMode");
  mdt_mode.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ProSeUEtoNetworkRelaying ::= ENUMERATED
const char* pro_se_ueto_network_relaying_opts::to_string() const
{
  static const char* options[] = {"authorized", "not-authorized"};
  return convert_enum_idx(options, 2, value, "pro_se_ueto_network_relaying_e");
}

// RequestTypeAdditionalInfo ::= ENUMERATED
const char* request_type_add_info_opts::to_string() const
{
  static const char* options[] = {"includePSCell"};
  return convert_enum_idx(options, 1, value, "request_type_add_info_e");
}

// UEAppLayerMeasConfig ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(container_for_app_layer_meas_cfg.pack(bref));
  HANDLE_CODE(area_scope_of_qmc.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(container_for_app_layer_meas_cfg.unpack(bref));
  HANDLE_CODE(area_scope_of_qmc.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("containerForAppLayerMeasConfig", container_for_app_layer_meas_cfg.to_string());
  j.write_fieldname("areaScopeOfQMC");
  area_scope_of_qmc.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// EventType ::= ENUMERATED
const char* event_type_opts::to_string() const
{
  static const char* options[] = {"direct", "change-of-serve-cell", "stop-change-of-serve-cell"};
  return convert_enum_idx(options, 3, value, "event_type_e");
}

// PedestrianUE ::= ENUMERATED
const char* pedestrian_ue_opts::to_string() const
{
  static const char* options[] = {"authorized", "not-authorized"};
  return convert_enum_idx(options, 2, value, "pedestrian_ue_e");
}

// ProSeAuthorized-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t pro_se_authorized_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {216};
  return map_enum_number(options, 1, idx, "id");
}
bool pro_se_authorized_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 216 == id;
}
crit_e pro_se_authorized_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 216) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
pro_se_authorized_ext_ies_o::ext_c pro_se_authorized_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 216) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e pro_se_authorized_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 216) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pro_se_authorized_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ProSeUEtoNetworkRelaying", c.to_string());
  j.end_obj();
}
SRSASN_CODE pro_se_authorized_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pro_se_authorized_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pro_se_authorized_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"ProSeUEtoNetworkRelaying"};
  return convert_enum_idx(options, 1, value, "pro_se_authorized_ext_ies_o::ext_c::types");
}
uint8_t pro_se_authorized_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t options[] = {2};
  return map_enum_number(options, 1, value, "pro_se_authorized_ext_ies_o::ext_c::types");
}

// ProSeDirectCommunication ::= ENUMERATED
const char* pro_se_direct_communication_opts::to_string() const
{
  static const char* options[] = {"authorized", "not-authorized"};
  return convert_enum_idx(options, 2, value, "pro_se_direct_communication_e");
}

// ProSeDirectDiscovery ::= ENUMERATED
const char* pro_se_direct_discovery_opts::to_string() const
{
  static const char* options[] = {"authorized", "not-authorized"};
  return convert_enum_idx(options, 2, value, "pro_se_direct_discovery_e");
}

// ReportArea ::= ENUMERATED
const char* report_area_opts::to_string() const
{
  static const char* options[] = {"ecgi"};
  return convert_enum_idx(options, 1, value, "report_area_e");
}

// RequestType-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t request_type_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {298};
  return map_enum_number(options, 1, idx, "id");
}
bool request_type_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 298 == id;
}
crit_e request_type_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 298) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
request_type_ext_ies_o::ext_c request_type_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 298) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e request_type_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 298) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void request_type_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("RequestTypeAdditionalInfo", "includePSCell");
  j.end_obj();
}
SRSASN_CODE request_type_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE request_type_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* request_type_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"RequestTypeAdditionalInfo"};
  return convert_enum_idx(options, 1, value, "request_type_ext_ies_o::ext_c::types");
}

// TraceActivation-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t trace_activation_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {162, 262};
  return map_enum_number(options, 2, idx, "id");
}
bool trace_activation_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {162, 262};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_activation_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 162:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
trace_activation_ext_ies_o::ext_c trace_activation_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 162:
      ret.set(ext_c::types::mdt_cfg);
      break;
    case 262:
      ret.set(ext_c::types::ue_app_layer_meas_cfg);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e trace_activation_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 162:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trace_activation_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::mdt_cfg:
      c.destroy<mdt_cfg_s>();
      break;
    case types::ue_app_layer_meas_cfg:
      c.destroy<ue_app_layer_meas_cfg_s>();
      break;
    default:
      break;
  }
}
void trace_activation_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mdt_cfg:
      c.init<mdt_cfg_s>();
      break;
    case types::ue_app_layer_meas_cfg:
      c.init<ue_app_layer_meas_cfg_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c::ext_c(const trace_activation_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mdt_cfg:
      c.init(other.c.get<mdt_cfg_s>());
      break;
    case types::ue_app_layer_meas_cfg:
      c.init(other.c.get<ue_app_layer_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c&
trace_activation_ext_ies_o::ext_c::operator=(const trace_activation_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mdt_cfg:
      c.set(other.c.get<mdt_cfg_s>());
      break;
    case types::ue_app_layer_meas_cfg:
      c.set(other.c.get<ue_app_layer_meas_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }

  return *this;
}
mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg()
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
ue_app_layer_meas_cfg_s& trace_activation_ext_ies_o::ext_c::ue_app_layer_meas_cfg()
{
  assert_choice_type(types::ue_app_layer_meas_cfg, type_, "Extension");
  return c.get<ue_app_layer_meas_cfg_s>();
}
const mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg() const
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
const ue_app_layer_meas_cfg_s& trace_activation_ext_ies_o::ext_c::ue_app_layer_meas_cfg() const
{
  assert_choice_type(types::ue_app_layer_meas_cfg, type_, "Extension");
  return c.get<ue_app_layer_meas_cfg_s>();
}
void trace_activation_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mdt_cfg:
      j.write_fieldname("MDT-Configuration");
      c.get<mdt_cfg_s>().to_json(j);
      break;
    case types::ue_app_layer_meas_cfg:
      j.write_fieldname("UEAppLayerMeasConfig");
      c.get<ue_app_layer_meas_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().pack(bref));
      break;
    case types::ue_app_layer_meas_cfg:
      HANDLE_CODE(c.get<ue_app_layer_meas_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().unpack(bref));
      break;
    case types::ue_app_layer_meas_cfg:
      HANDLE_CODE(c.get<ue_app_layer_meas_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_activation_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"MDT-Configuration", "UEAppLayerMeasConfig"};
  return convert_enum_idx(options, 2, value, "trace_activation_ext_ies_o::ext_c::types");
}

// TraceDepth ::= ENUMERATED
const char* trace_depth_opts::to_string() const
{
  static const char* options[] = {"minimum",
                                  "medium",
                                  "maximum",
                                  "minimumWithoutVendorSpecificExtension",
                                  "mediumWithoutVendorSpecificExtension",
                                  "maximumWithoutVendorSpecificExtension"};
  return convert_enum_idx(options, 6, value, "trace_depth_e");
}

// VehicleUE ::= ENUMERATED
const char* vehicle_ue_opts::to_string() const
{
  static const char* options[] = {"authorized", "not-authorized"};
  return convert_enum_idx(options, 2, value, "vehicle_ue_e");
}

// AerialUEsubscriptionInformation ::= ENUMERATED
const char* aerial_uesubscription_info_opts::to_string() const
{
  static const char* options[] = {"allowed", "not-allowed"};
  return convert_enum_idx(options, 2, value, "aerial_uesubscription_info_e");
}

// ManagementBasedMDTAllowed ::= ENUMERATED
const char* management_based_mdt_allowed_opts::to_string() const
{
  static const char* options[] = {"allowed"};
  return convert_enum_idx(options, 1, value, "management_based_mdt_allowed_e");
}

// ProSeAuthorized ::= SEQUENCE
SRSASN_CODE pro_se_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.pack(pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (pro_se_direct_discovery_present) {
    HANDLE_CODE(pro_se_direct_discovery.pack(bref));
  }
  if (pro_se_direct_communication_present) {
    HANDLE_CODE(pro_se_direct_communication.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pro_se_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.unpack(pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (pro_se_direct_discovery_present) {
    HANDLE_CODE(pro_se_direct_discovery.unpack(bref));
  }
  if (pro_se_direct_communication_present) {
    HANDLE_CODE(pro_se_direct_communication.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pro_se_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pro_se_direct_discovery_present) {
    j.write_str("proSeDirectDiscovery", pro_se_direct_discovery.to_string());
  }
  if (pro_se_direct_communication_present) {
    j.write_str("proSeDirectCommunication", pro_se_direct_communication.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RequestType ::= SEQUENCE
SRSASN_CODE request_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(event_type.pack(bref));
  HANDLE_CODE(report_area.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE request_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type.unpack(bref));
  HANDLE_CODE(report_area.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void request_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eventType", event_type.to_string());
  j.write_str("reportArea", "ecgi");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SecurityContext ::= SEQUENCE
SRSASN_CODE security_context_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, next_hop_chaining_count, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_param.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_context_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(next_hop_chaining_count, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_param.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_context_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nextHopChainingCount", next_hop_chaining_count);
  j.write_str("nextHopParameter", next_hop_param.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::s1ap::protocol_ext_field_s<trace_activation_ext_ies_o>;

trace_activation_ext_ies_container::trace_activation_ext_ies_container() :
  mdt_cfg(162, crit_e::ignore), ue_app_layer_meas_cfg(262, crit_e::ignore)
{}
SRSASN_CODE trace_activation_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mdt_cfg_present ? 1 : 0;
  nof_ies += ue_app_layer_meas_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (mdt_cfg_present) {
    HANDLE_CODE(mdt_cfg.pack(bref));
  }
  if (ue_app_layer_meas_cfg_present) {
    HANDLE_CODE(ue_app_layer_meas_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<trace_activation_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 162:
        mdt_cfg_present = true;
        mdt_cfg.id      = c.id;
        mdt_cfg.crit    = c.crit;
        mdt_cfg.ext     = c.ext_value.mdt_cfg();
        break;
      case 262:
        ue_app_layer_meas_cfg_present = true;
        ue_app_layer_meas_cfg.id      = c.id;
        ue_app_layer_meas_cfg.crit    = c.crit;
        ue_app_layer_meas_cfg.ext     = c.ext_value.ue_app_layer_meas_cfg();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trace_activation_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_present) {
    j.write_fieldname("");
    mdt_cfg.to_json(j);
  }
  if (ue_app_layer_meas_cfg_present) {
    j.write_fieldname("");
    ue_app_layer_meas_cfg.to_json(j);
  }
  j.end_obj();
}

// TraceActivation ::= SEQUENCE
SRSASN_CODE trace_activation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(e_utran_trace_id.pack(bref));
  HANDLE_CODE(interfaces_to_trace.pack(bref));
  HANDLE_CODE(trace_depth.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(e_utran_trace_id.unpack(bref));
  HANDLE_CODE(interfaces_to_trace.unpack(bref));
  HANDLE_CODE(trace_depth.unpack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trace_activation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("e-UTRAN-Trace-ID", e_utran_trace_id.to_string());
  j.write_str("interfacesToTrace", interfaces_to_trace.to_string());
  j.write_str("traceDepth", trace_depth.to_string());
  j.write_str("traceCollectionEntityIPAddress", trace_collection_entity_ip_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UESecurityCapabilities ::= SEQUENCE
SRSASN_CODE ue_security_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(encryption_algorithms.pack(bref));
  HANDLE_CODE(integrity_protection_algorithms.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_security_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(encryption_algorithms.unpack(bref));
  HANDLE_CODE(integrity_protection_algorithms.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_security_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("encryptionAlgorithms", encryption_algorithms.to_string());
  j.write_str("integrityProtectionAlgorithms", integrity_protection_algorithms.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE ue_sidelink_aggregate_maximum_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(
      pack_integer(bref, uesidelink_aggregate_maximum_bit_rate, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_sidelink_aggregate_maximum_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(uesidelink_aggregate_maximum_bit_rate, bref, (uint64_t)0u, (uint64_t)10000000000u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_sidelink_aggregate_maximum_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", uesidelink_aggregate_maximum_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEUserPlaneCIoTSupportIndicator ::= ENUMERATED
const char* ueuser_plane_cio_tsupport_ind_opts::to_string() const
{
  static const char* options[] = {"supported"};
  return convert_enum_idx(options, 1, value, "ueuser_plane_cio_tsupport_ind_e");
}

// V2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE v2xservices_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE v2xservices_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void v2xservices_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0,   1,   2,   66,  53,  104, 107, 41,  25,  98,  124, 40,  136, 127, 146, 75,
                                     158, 165, 177, 192, 196, 195, 241, 240, 248, 251, 269, 271, 277, 283, 278, 299};
  return map_enum_number(options, 32, idx, "id");
}
bool ho_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0,   1,   2,   66,  53,  104, 107, 41,  25,  98,  124, 40,  136, 127, 146, 75,
                                     158, 165, 177, 192, 196, 195, 241, 240, 248, 251, 269, 271, 277, 283, 278, 299};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 1:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    case 66:
      return crit_e::reject;
    case 53:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 107:
      return crit_e::reject;
    case 41:
      return crit_e::ignore;
    case 25:
      return crit_e::ignore;
    case 98:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 40:
      return crit_e::reject;
    case 136:
      return crit_e::reject;
    case 127:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 196:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 241:
      return crit_e::ignore;
    case 240:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_request_ies_o::value_c ho_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 1:
      ret.set(value_c::types::handov_type);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 53:
      ret.set(value_c::types::erab_to_be_setup_list_ho_req);
      break;
    case 104:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 107:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 41:
      ret.set(value_c::types::ho_restrict_list);
      break;
    case 25:
      ret.set(value_c::types::trace_activation);
      break;
    case 98:
      ret.set(value_c::types::request_type);
      break;
    case 124:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 40:
      ret.set(value_c::types::security_context);
      break;
    case 136:
      ret.set(value_c::types::nas_security_paramsto_e_utran);
      break;
    case 127:
      ret.set(value_c::types::csg_id);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 75:
      ret.set(value_c::types::gummei_id);
      break;
    case 158:
      ret.set(value_c::types::mme_ue_s1ap_id_minus2);
      break;
    case 165:
      ret.set(value_c::types::management_based_mdt_allowed);
      break;
    case 177:
      ret.set(value_c::types::management_based_mdtplmn_list);
      break;
    case 192:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 196:
      ret.set(value_c::types::expected_ue_behaviour);
      break;
    case 195:
      ret.set(value_c::types::pro_se_authorized);
      break;
    case 241:
      ret.set(value_c::types::ueuser_plane_cio_tsupport_ind);
      break;
    case 240:
      ret.set(value_c::types::v2xservices_authorized);
      break;
    case 248:
      ret.set(value_c::types::ue_sidelink_aggregate_maximum_bitrate);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 277:
      ret.set(value_c::types::aerial_uesubscription_info);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 299:
      ret.set(value_c::types::add_rrm_prio_idx);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 1:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 66:
      return presence_e::mandatory;
    case 53:
      return presence_e::mandatory;
    case 104:
      return presence_e::mandatory;
    case 107:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 25:
      return presence_e::optional;
    case 98:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 40:
      return presence_e::mandatory;
    case 136:
      return presence_e::conditional;
    case 127:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 75:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 196:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 241:
      return presence_e::optional;
    case 240:
      return presence_e::optional;
    case 248:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_ho_req:
      c.destroy<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::ho_restrict_list:
      c.destroy<ho_restrict_list_s>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::request_type:
      c.destroy<request_type_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::nas_security_paramsto_e_utran:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.destroy<fixed_bitstring<27, false, true> >();
      break;
    case types::gummei_id:
      c.destroy<gummei_s>();
      break;
    case types::management_based_mdtplmn_list:
      c.destroy<mdtplmn_list_l>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true> >();
      break;
    case types::expected_ue_behaviour:
      c.destroy<expected_ue_behaviour_s>();
      break;
    case types::pro_se_authorized:
      c.destroy<pro_se_authorized_s>();
      break;
    case types::v2xservices_authorized:
      c.destroy<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.destroy<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    default:
      break;
  }
}
void ho_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_ho_req:
      c.init<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::ho_restrict_list:
      c.init<ho_restrict_list_s>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::request_type:
      c.init<request_type_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::nas_security_paramsto_e_utran:
      c.init<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.init<fixed_bitstring<27, false, true> >();
      break;
    case types::csg_membership_status:
      break;
    case types::gummei_id:
      c.init<gummei_s>();
      break;
    case types::mme_ue_s1ap_id_minus2:
      break;
    case types::management_based_mdt_allowed:
      break;
    case types::management_based_mdtplmn_list:
      c.init<mdtplmn_list_l>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true> >();
      break;
    case types::expected_ue_behaviour:
      c.init<expected_ue_behaviour_s>();
      break;
    case types::pro_se_authorized:
      c.init<pro_se_authorized_s>();
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      break;
    case types::v2xservices_authorized:
      c.init<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::aerial_uesubscription_info:
      break;
    case types::pending_data_ind:
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c::value_c(const ho_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_ho_req:
      c.init(other.c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::ho_restrict_list:
      c.init(other.c.get<ho_restrict_list_s>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::request_type:
      c.init(other.c.get<request_type_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::nas_security_paramsto_e_utran:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.init(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::gummei_id:
      c.init(other.c.get<gummei_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.init(other.c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      c.init(other.c.get<management_based_mdt_allowed_e>());
      break;
    case types::management_based_mdtplmn_list:
      c.init(other.c.get<mdtplmn_list_l>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true> >());
      break;
    case types::expected_ue_behaviour:
      c.init(other.c.get<expected_ue_behaviour_s>());
      break;
    case types::pro_se_authorized:
      c.init(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.init(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.init(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.init(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c& ho_request_ies_o::value_c::operator=(const ho_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_ho_req:
      c.set(other.c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::ho_restrict_list:
      c.set(other.c.get<ho_restrict_list_s>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::request_type:
      c.set(other.c.get<request_type_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::nas_security_paramsto_e_utran:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.set(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::gummei_id:
      c.set(other.c.get<gummei_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.set(other.c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      c.set(other.c.get<management_based_mdt_allowed_e>());
      break;
    case types::management_based_mdtplmn_list:
      c.set(other.c.get<mdtplmn_list_l>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true> >());
      break;
    case types::expected_ue_behaviour:
      c.set(other.c.get<expected_ue_behaviour_s>());
      break;
    case types::pro_se_authorized:
      c.set(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.set(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.set(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.set(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.set(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_request_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
ue_aggregate_maximum_bitrate_s& ho_request_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o>& ho_request_ies_o::value_c::erab_to_be_setup_list_ho_req()
{
  assert_choice_type(types::erab_to_be_setup_list_ho_req, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
ho_restrict_list_s& ho_request_ies_o::value_c::ho_restrict_list()
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
trace_activation_s& ho_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
request_type_s& ho_request_ies_o::value_c::request_type()
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
security_context_s& ho_request_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::nas_security_paramsto_e_utran()
{
  assert_choice_type(types::nas_security_paramsto_e_utran, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
fixed_bitstring<27, false, true>& ho_request_ies_o::value_c::csg_id()
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
csg_membership_status_e& ho_request_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
gummei_s& ho_request_ies_o::value_c::gummei_id()
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
uint64_t& ho_request_ies_o::value_c::mme_ue_s1ap_id_minus2()
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
management_based_mdt_allowed_e& ho_request_ies_o::value_c::management_based_mdt_allowed()
{
  assert_choice_type(types::management_based_mdt_allowed, type_, "Value");
  return c.get<management_based_mdt_allowed_e>();
}
mdtplmn_list_l& ho_request_ies_o::value_c::management_based_mdtplmn_list()
{
  assert_choice_type(types::management_based_mdtplmn_list, type_, "Value");
  return c.get<mdtplmn_list_l>();
}
fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true> >();
}
expected_ue_behaviour_s& ho_request_ies_o::value_c::expected_ue_behaviour()
{
  assert_choice_type(types::expected_ue_behaviour, type_, "Value");
  return c.get<expected_ue_behaviour_s>();
}
pro_se_authorized_s& ho_request_ies_o::value_c::pro_se_authorized()
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
ueuser_plane_cio_tsupport_ind_e& ho_request_ies_o::value_c::ueuser_plane_cio_tsupport_ind()
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
v2xservices_authorized_s& ho_request_ies_o::value_c::v2xservices_authorized()
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
ue_sidelink_aggregate_maximum_bitrate_s& ho_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate()
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
enhanced_coverage_restricted_e& ho_request_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
nrue_security_cap_s& ho_request_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
aerial_uesubscription_info_e& ho_request_ies_o::value_c::aerial_uesubscription_info()
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
pending_data_ind_e& ho_request_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
subscription_based_ue_differentiation_info_s& ho_request_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
fixed_bitstring<32, false, true>& ho_request_ies_o::value_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
const uint64_t& ho_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_request_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_aggregate_maximum_bitrate_s& ho_request_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o>&
ho_request_ies_o::value_c::erab_to_be_setup_list_ho_req() const
{
  assert_choice_type(types::erab_to_be_setup_list_ho_req, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const ho_restrict_list_s& ho_request_ies_o::value_c::ho_restrict_list() const
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
const trace_activation_s& ho_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const request_type_s& ho_request_ies_o::value_c::request_type() const
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
const srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const security_context_s& ho_request_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::nas_security_paramsto_e_utran() const
{
  assert_choice_type(types::nas_security_paramsto_e_utran, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const fixed_bitstring<27, false, true>& ho_request_ies_o::value_c::csg_id() const
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
const csg_membership_status_e& ho_request_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const gummei_s& ho_request_ies_o::value_c::gummei_id() const
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
const uint64_t& ho_request_ies_o::value_c::mme_ue_s1ap_id_minus2() const
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
const management_based_mdt_allowed_e& ho_request_ies_o::value_c::management_based_mdt_allowed() const
{
  assert_choice_type(types::management_based_mdt_allowed, type_, "Value");
  return c.get<management_based_mdt_allowed_e>();
}
const mdtplmn_list_l& ho_request_ies_o::value_c::management_based_mdtplmn_list() const
{
  assert_choice_type(types::management_based_mdtplmn_list, type_, "Value");
  return c.get<mdtplmn_list_l>();
}
const fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true> >();
}
const expected_ue_behaviour_s& ho_request_ies_o::value_c::expected_ue_behaviour() const
{
  assert_choice_type(types::expected_ue_behaviour, type_, "Value");
  return c.get<expected_ue_behaviour_s>();
}
const pro_se_authorized_s& ho_request_ies_o::value_c::pro_se_authorized() const
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
const ueuser_plane_cio_tsupport_ind_e& ho_request_ies_o::value_c::ueuser_plane_cio_tsupport_ind() const
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
const v2xservices_authorized_s& ho_request_ies_o::value_c::v2xservices_authorized() const
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
const ue_sidelink_aggregate_maximum_bitrate_s& ho_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate() const
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
const enhanced_coverage_restricted_e& ho_request_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const nrue_security_cap_s& ho_request_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const aerial_uesubscription_info_e& ho_request_ies_o::value_c::aerial_uesubscription_info() const
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
const pending_data_ind_e& ho_request_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const subscription_based_ue_differentiation_info_s&
ho_request_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const fixed_bitstring<32, false, true>& ho_request_ies_o::value_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
void ho_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_setup_list_ho_req:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABToBeSetupItemHOReqIEs}}");
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::ho_restrict_list:
      j.write_fieldname("HandoverRestrictionList");
      c.get<ho_restrict_list_s>().to_json(j);
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::request_type:
      j.write_fieldname("RequestType");
      c.get<request_type_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", "possible");
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::nas_security_paramsto_e_utran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::csg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<27, false, true> >().to_string());
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::gummei_id:
      j.write_fieldname("GUMMEI");
      c.get<gummei_s>().to_json(j);
      break;
    case types::mme_ue_s1ap_id_minus2:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      j.write_str("ManagementBasedMDTAllowed", "allowed");
      break;
    case types::management_based_mdtplmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdtplmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true> >().to_string());
      break;
    case types::expected_ue_behaviour:
      j.write_fieldname("ExpectedUEBehaviour");
      c.get<expected_ue_behaviour_s>().to_json(j);
      break;
    case types::pro_se_authorized:
      j.write_fieldname("ProSeAuthorized");
      c.get<pro_se_authorized_s>().to_json(j);
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      j.write_str("UEUserPlaneCIoTSupportIndicator", "supported");
      break;
    case types::v2xservices_authorized:
      j.write_fieldname("V2XServicesAuthorized");
      c.get<v2xservices_authorized_s>().to_json(j);
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      j.write_fieldname("UESidelinkAggregateMaximumBitrate");
      c.get<ue_sidelink_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::aerial_uesubscription_info:
      j.write_str("AerialUEsubscriptionInformation", c.get<aerial_uesubscription_info_e>().to_string());
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_setup_list_ho_req:
      HANDLE_CODE(
          pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >(), 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().pack(bref));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::nas_security_paramsto_e_utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().pack(bref)));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().pack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::management_based_mdt_allowed:
      HANDLE_CODE(c.get<management_based_mdt_allowed_e>().pack(bref));
      break;
    case types::management_based_mdtplmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdtplmn_list_l>(), 1, 16, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true> >().pack(bref)));
      break;
    case types::expected_ue_behaviour:
      HANDLE_CODE(c.get<expected_ue_behaviour_s>().pack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().pack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().pack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().pack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_setup_list_ho_req:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_to_be_setup_item_ho_req_ies_o> >(), bref, 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().unpack(bref));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::nas_security_paramsto_e_utran:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().unpack(bref)));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().unpack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::management_based_mdt_allowed:
      HANDLE_CODE(c.get<management_based_mdt_allowed_e>().unpack(bref));
      break;
    case types::management_based_mdtplmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdtplmn_list_l>(), bref, 1, 16, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true> >().unpack(bref)));
      break;
    case types::expected_ue_behaviour:
      HANDLE_CODE(c.get<expected_ue_behaviour_s>().unpack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().unpack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().unpack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().unpack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "HandoverType",
                                  "Cause",
                                  "UEAggregateMaximumBitrate",
                                  "E-RAB-IE-ContainerList{{E-RABToBeSetupItemHOReqIEs}}",
                                  "OCTET STRING",
                                  "UESecurityCapabilities",
                                  "HandoverRestrictionList",
                                  "TraceActivation",
                                  "RequestType",
                                  "SRVCCOperationPossible",
                                  "SecurityContext",
                                  "OCTET STRING",
                                  "BIT STRING",
                                  "CSGMembershipStatus",
                                  "GUMMEI",
                                  "INTEGER (0..4294967295)",
                                  "ManagementBasedMDTAllowed",
                                  "MDTPLMNList",
                                  "BIT STRING",
                                  "ExpectedUEBehaviour",
                                  "ProSeAuthorized",
                                  "UEUserPlaneCIoTSupportIndicator",
                                  "V2XServicesAuthorized",
                                  "UESidelinkAggregateMaximumBitrate",
                                  "EnhancedCoverageRestricted",
                                  "NRUESecurityCapabilities",
                                  "CE-ModeBRestricted",
                                  "AerialUEsubscriptionInformation",
                                  "PendingDataIndication",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "BIT STRING"};
  return convert_enum_idx(options, 32, value, "ho_request_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_request_ies_o>;

ho_request_ies_container::ho_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  handov_type(1, crit_e::reject),
  cause(2, crit_e::ignore),
  ueaggregate_maximum_bitrate(66, crit_e::reject),
  erab_to_be_setup_list_ho_req(53, crit_e::reject),
  source_to_target_transparent_container(104, crit_e::reject),
  ue_security_cap(107, crit_e::reject),
  ho_restrict_list(41, crit_e::ignore),
  trace_activation(25, crit_e::ignore),
  request_type(98, crit_e::ignore),
  srvcc_operation_possible(124, crit_e::ignore),
  security_context(40, crit_e::reject),
  nas_security_paramsto_e_utran(136, crit_e::reject),
  csg_id(127, crit_e::reject),
  csg_membership_status(146, crit_e::ignore),
  gummei_id(75, crit_e::ignore),
  mme_ue_s1ap_id_minus2(158, crit_e::ignore),
  management_based_mdt_allowed(165, crit_e::ignore),
  management_based_mdtplmn_list(177, crit_e::ignore),
  masked_imeisv(192, crit_e::ignore),
  expected_ue_behaviour(196, crit_e::ignore),
  pro_se_authorized(195, crit_e::ignore),
  ueuser_plane_cio_tsupport_ind(241, crit_e::ignore),
  v2xservices_authorized(240, crit_e::ignore),
  ue_sidelink_aggregate_maximum_bitrate(248, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore),
  aerial_uesubscription_info(277, crit_e::ignore),
  pending_data_ind(283, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore)
{}
SRSASN_CODE ho_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 8;
  nof_ies += ho_restrict_list_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += request_type_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += nas_security_paramsto_e_utran_present ? 1 : 0;
  nof_ies += csg_id_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += gummei_id_present ? 1 : 0;
  nof_ies += mme_ue_s1ap_id_minus2_present ? 1 : 0;
  nof_ies += management_based_mdt_allowed_present ? 1 : 0;
  nof_ies += management_based_mdtplmn_list_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += expected_ue_behaviour_present ? 1 : 0;
  nof_ies += pro_se_authorized_present ? 1 : 0;
  nof_ies += ueuser_plane_cio_tsupport_ind_present ? 1 : 0;
  nof_ies += v2xservices_authorized_present ? 1 : 0;
  nof_ies += ue_sidelink_aggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += aerial_uesubscription_info_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  HANDLE_CODE(erab_to_be_setup_list_ho_req.pack(bref));
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  if (ho_restrict_list_present) {
    HANDLE_CODE(ho_restrict_list.pack(bref));
  }
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (request_type_present) {
    HANDLE_CODE(request_type.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  HANDLE_CODE(security_context.pack(bref));
  if (nas_security_paramsto_e_utran_present) {
    HANDLE_CODE(nas_security_paramsto_e_utran.pack(bref));
  }
  if (csg_id_present) {
    HANDLE_CODE(csg_id.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (gummei_id_present) {
    HANDLE_CODE(gummei_id.pack(bref));
  }
  if (mme_ue_s1ap_id_minus2_present) {
    HANDLE_CODE(mme_ue_s1ap_id_minus2.pack(bref));
  }
  if (management_based_mdt_allowed_present) {
    HANDLE_CODE(management_based_mdt_allowed.pack(bref));
  }
  if (management_based_mdtplmn_list_present) {
    HANDLE_CODE(management_based_mdtplmn_list.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (pro_se_authorized_present) {
    HANDLE_CODE(pro_se_authorized.pack(bref));
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    HANDLE_CODE(ueuser_plane_cio_tsupport_ind.pack(bref));
  }
  if (v2xservices_authorized_present) {
    HANDLE_CODE(v2xservices_authorized.pack(bref));
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    HANDLE_CODE(ue_sidelink_aggregate_maximum_bitrate.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (aerial_uesubscription_info_present) {
    HANDLE_CODE(aerial_uesubscription_info.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 8;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 1:
        nof_mandatory_ies--;
        handov_type.id    = c.id;
        handov_type.crit  = c.crit;
        handov_type.value = c.value.handov_type();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 66:
        nof_mandatory_ies--;
        ueaggregate_maximum_bitrate.id    = c.id;
        ueaggregate_maximum_bitrate.crit  = c.crit;
        ueaggregate_maximum_bitrate.value = c.value.ueaggregate_maximum_bitrate();
        break;
      case 53:
        nof_mandatory_ies--;
        erab_to_be_setup_list_ho_req.id    = c.id;
        erab_to_be_setup_list_ho_req.crit  = c.crit;
        erab_to_be_setup_list_ho_req.value = c.value.erab_to_be_setup_list_ho_req();
        break;
      case 104:
        nof_mandatory_ies--;
        source_to_target_transparent_container.id    = c.id;
        source_to_target_transparent_container.crit  = c.crit;
        source_to_target_transparent_container.value = c.value.source_to_target_transparent_container();
        break;
      case 107:
        nof_mandatory_ies--;
        ue_security_cap.id    = c.id;
        ue_security_cap.crit  = c.crit;
        ue_security_cap.value = c.value.ue_security_cap();
        break;
      case 41:
        ho_restrict_list_present = true;
        ho_restrict_list.id      = c.id;
        ho_restrict_list.crit    = c.crit;
        ho_restrict_list.value   = c.value.ho_restrict_list();
        break;
      case 25:
        trace_activation_present = true;
        trace_activation.id      = c.id;
        trace_activation.crit    = c.crit;
        trace_activation.value   = c.value.trace_activation();
        break;
      case 98:
        request_type_present = true;
        request_type.id      = c.id;
        request_type.crit    = c.crit;
        request_type.value   = c.value.request_type();
        break;
      case 124:
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = c.id;
        srvcc_operation_possible.crit    = c.crit;
        srvcc_operation_possible.value   = c.value.srvcc_operation_possible();
        break;
      case 40:
        nof_mandatory_ies--;
        security_context.id    = c.id;
        security_context.crit  = c.crit;
        security_context.value = c.value.security_context();
        break;
      case 136:
        nas_security_paramsto_e_utran_present = true;
        nas_security_paramsto_e_utran.id      = c.id;
        nas_security_paramsto_e_utran.crit    = c.crit;
        nas_security_paramsto_e_utran.value   = c.value.nas_security_paramsto_e_utran();
        break;
      case 127:
        csg_id_present = true;
        csg_id.id      = c.id;
        csg_id.crit    = c.crit;
        csg_id.value   = c.value.csg_id();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 75:
        gummei_id_present = true;
        gummei_id.id      = c.id;
        gummei_id.crit    = c.crit;
        gummei_id.value   = c.value.gummei_id();
        break;
      case 158:
        mme_ue_s1ap_id_minus2_present = true;
        mme_ue_s1ap_id_minus2.id      = c.id;
        mme_ue_s1ap_id_minus2.crit    = c.crit;
        mme_ue_s1ap_id_minus2.value   = c.value.mme_ue_s1ap_id_minus2();
        break;
      case 165:
        management_based_mdt_allowed_present = true;
        management_based_mdt_allowed.id      = c.id;
        management_based_mdt_allowed.crit    = c.crit;
        management_based_mdt_allowed.value   = c.value.management_based_mdt_allowed();
        break;
      case 177:
        management_based_mdtplmn_list_present = true;
        management_based_mdtplmn_list.id      = c.id;
        management_based_mdtplmn_list.crit    = c.crit;
        management_based_mdtplmn_list.value   = c.value.management_based_mdtplmn_list();
        break;
      case 192:
        masked_imeisv_present = true;
        masked_imeisv.id      = c.id;
        masked_imeisv.crit    = c.crit;
        masked_imeisv.value   = c.value.masked_imeisv();
        break;
      case 196:
        expected_ue_behaviour_present = true;
        expected_ue_behaviour.id      = c.id;
        expected_ue_behaviour.crit    = c.crit;
        expected_ue_behaviour.value   = c.value.expected_ue_behaviour();
        break;
      case 195:
        pro_se_authorized_present = true;
        pro_se_authorized.id      = c.id;
        pro_se_authorized.crit    = c.crit;
        pro_se_authorized.value   = c.value.pro_se_authorized();
        break;
      case 241:
        ueuser_plane_cio_tsupport_ind_present = true;
        ueuser_plane_cio_tsupport_ind.id      = c.id;
        ueuser_plane_cio_tsupport_ind.crit    = c.crit;
        ueuser_plane_cio_tsupport_ind.value   = c.value.ueuser_plane_cio_tsupport_ind();
        break;
      case 240:
        v2xservices_authorized_present = true;
        v2xservices_authorized.id      = c.id;
        v2xservices_authorized.crit    = c.crit;
        v2xservices_authorized.value   = c.value.v2xservices_authorized();
        break;
      case 248:
        ue_sidelink_aggregate_maximum_bitrate_present = true;
        ue_sidelink_aggregate_maximum_bitrate.id      = c.id;
        ue_sidelink_aggregate_maximum_bitrate.crit    = c.crit;
        ue_sidelink_aggregate_maximum_bitrate.value   = c.value.ue_sidelink_aggregate_maximum_bitrate();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      case 277:
        aerial_uesubscription_info_present = true;
        aerial_uesubscription_info.id      = c.id;
        aerial_uesubscription_info.crit    = c.crit;
        aerial_uesubscription_info.value   = c.value.aerial_uesubscription_info();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.value   = c.value.add_rrm_prio_idx();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  ueaggregate_maximum_bitrate.to_json(j);
  j.write_fieldname("");
  erab_to_be_setup_list_ho_req.to_json(j);
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  if (ho_restrict_list_present) {
    j.write_fieldname("");
    ho_restrict_list.to_json(j);
  }
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (request_type_present) {
    j.write_fieldname("");
    request_type.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  j.write_fieldname("");
  security_context.to_json(j);
  if (nas_security_paramsto_e_utran_present) {
    j.write_fieldname("");
    nas_security_paramsto_e_utran.to_json(j);
  }
  if (csg_id_present) {
    j.write_fieldname("");
    csg_id.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (gummei_id_present) {
    j.write_fieldname("");
    gummei_id.to_json(j);
  }
  if (mme_ue_s1ap_id_minus2_present) {
    j.write_fieldname("");
    mme_ue_s1ap_id_minus2.to_json(j);
  }
  if (management_based_mdt_allowed_present) {
    j.write_fieldname("");
    management_based_mdt_allowed.to_json(j);
  }
  if (management_based_mdtplmn_list_present) {
    j.write_fieldname("");
    management_based_mdtplmn_list.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  if (expected_ue_behaviour_present) {
    j.write_fieldname("");
    expected_ue_behaviour.to_json(j);
  }
  if (pro_se_authorized_present) {
    j.write_fieldname("");
    pro_se_authorized.to_json(j);
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    j.write_fieldname("");
    ueuser_plane_cio_tsupport_ind.to_json(j);
  }
  if (v2xservices_authorized_present) {
    j.write_fieldname("");
    v2xservices_authorized.to_json(j);
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ue_sidelink_aggregate_maximum_bitrate.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (aerial_uesubscription_info_present) {
    j.write_fieldname("");
    aerial_uesubscription_info.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  j.end_obj();
}

// HandoverRequest ::= SEQUENCE
SRSASN_CODE ho_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// CE-mode-B-SupportIndicator ::= ENUMERATED
const char* ce_mode_b_support_ind_opts::to_string() const
{
  static const char* options[] = {"supported"};
  return convert_enum_idx(options, 1, value, "ce_mode_b_support_ind_e");
}

// HandoverRequestAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 18, 19, 123, 127, 58, 145, 242};
  return map_enum_number(options, 9, idx, "id");
}
bool ho_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 18, 19, 123, 127, 58, 145, 242};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 18:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 123:
      return crit_e::reject;
    case 127:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 145:
      return crit_e::ignore;
    case 242:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_request_ack_ies_o::value_c ho_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 18:
      ret.set(value_c::types::erab_admitted_list);
      break;
    case 19:
      ret.set(value_c::types::erab_failed_to_setup_list_ho_req_ack);
      break;
    case 123:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 127:
      ret.set(value_c::types::csg_id);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 145:
      ret.set(value_c::types::cell_access_mode);
      break;
    case 242:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 18:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 123:
      return presence_e::mandatory;
    case 127:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 145:
      return presence_e::optional;
    case 242:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_admitted_list:
      c.destroy<erab_ie_container_list_l<erab_admitted_item_ies_o> >();
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      c.destroy<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.destroy<fixed_bitstring<27, false, true> >();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_admitted_list:
      c.init<erab_ie_container_list_l<erab_admitted_item_ies_o> >();
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      c.init<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.init<fixed_bitstring<27, false, true> >();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::cell_access_mode:
      break;
    case types::ce_mode_b_support_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c::value_c(const ho_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_admitted_list:
      c.init(other.c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >());
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      c.init(other.c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.init(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::cell_access_mode:
      c.init(other.c.get<cell_access_mode_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.init(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c& ho_request_ack_ies_o::value_c::operator=(const ho_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_admitted_list:
      c.set(other.c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >());
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      c.set(other.c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.set(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::cell_access_mode:
      c.set(other.c.get<cell_access_mode_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.set(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ack_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_request_ack_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_admitted_item_ies_o>& ho_request_ack_ies_o::value_c::erab_admitted_list()
{
  assert_choice_type(types::erab_admitted_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >();
}
erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o>&
ho_request_ack_ies_o::value_c::erab_failed_to_setup_list_ho_req_ack()
{
  assert_choice_type(types::erab_failed_to_setup_list_ho_req_ack, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >();
}
unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
fixed_bitstring<27, false, true>& ho_request_ack_ies_o::value_c::csg_id()
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
cell_access_mode_e& ho_request_ack_ies_o::value_c::cell_access_mode()
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
ce_mode_b_support_ind_e& ho_request_ack_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const uint64_t& ho_request_ack_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_request_ack_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_admitted_item_ies_o>& ho_request_ack_ies_o::value_c::erab_admitted_list() const
{
  assert_choice_type(types::erab_admitted_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >();
}
const erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o>&
ho_request_ack_ies_o::value_c::erab_failed_to_setup_list_ho_req_ack() const
{
  assert_choice_type(types::erab_failed_to_setup_list_ho_req_ack, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >();
}
const unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const fixed_bitstring<27, false, true>& ho_request_ack_ies_o::value_c::csg_id() const
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
const crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cell_access_mode_e& ho_request_ack_ies_o::value_c::cell_access_mode() const
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
const ce_mode_b_support_ind_e& ho_request_ack_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
void ho_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_admitted_list:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABAdmittedItemIEs}}");
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABFailedtoSetupItemHOReqAckIEs}}");
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::csg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<27, false, true> >().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::cell_access_mode:
      j.write_str("CellAccessMode", "hybrid");
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CE-mode-B-SupportIndicator", "supported");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_admitted_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >(), 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      HANDLE_CODE(pack_dyn_seq_of(
          bref, c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().pack(bref)));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().pack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_admitted_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_ie_container_list_l<erab_admitted_item_ies_o> >(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_ho_req_ack:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_failedto_setup_item_ho_req_ack_ies_o> >(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().unpack(bref)));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().unpack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABAdmittedItemIEs}}",
                                  "E-RAB-IE-ContainerList{{E-RABFailedtoSetupItemHOReqAckIEs}}",
                                  "OCTET STRING",
                                  "BIT STRING",
                                  "CriticalityDiagnostics",
                                  "CellAccessMode",
                                  "CE-mode-B-SupportIndicator"};
  return convert_enum_idx(options, 9, value, "ho_request_ack_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_request_ack_ies_o>;

ho_request_ack_ies_container::ho_request_ack_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_admitted_list(18, crit_e::ignore),
  erab_failed_to_setup_list_ho_req_ack(19, crit_e::ignore),
  target_to_source_transparent_container(123, crit_e::reject),
  csg_id(127, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  cell_access_mode(145, crit_e::ignore),
  ce_mode_b_support_ind(242, crit_e::ignore)
{}
SRSASN_CODE ho_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += erab_failed_to_setup_list_ho_req_ack_present ? 1 : 0;
  nof_ies += csg_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += cell_access_mode_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(erab_admitted_list.pack(bref));
  if (erab_failed_to_setup_list_ho_req_ack_present) {
    HANDLE_CODE(erab_failed_to_setup_list_ho_req_ack.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (csg_id_present) {
    HANDLE_CODE(csg_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_request_ack_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 18:
        nof_mandatory_ies--;
        erab_admitted_list.id    = c.id;
        erab_admitted_list.crit  = c.crit;
        erab_admitted_list.value = c.value.erab_admitted_list();
        break;
      case 19:
        erab_failed_to_setup_list_ho_req_ack_present = true;
        erab_failed_to_setup_list_ho_req_ack.id      = c.id;
        erab_failed_to_setup_list_ho_req_ack.crit    = c.crit;
        erab_failed_to_setup_list_ho_req_ack.value   = c.value.erab_failed_to_setup_list_ho_req_ack();
        break;
      case 123:
        nof_mandatory_ies--;
        target_to_source_transparent_container.id    = c.id;
        target_to_source_transparent_container.crit  = c.crit;
        target_to_source_transparent_container.value = c.value.target_to_source_transparent_container();
        break;
      case 127:
        csg_id_present = true;
        csg_id.id      = c.id;
        csg_id.crit    = c.crit;
        csg_id.value   = c.value.csg_id();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 145:
        cell_access_mode_present = true;
        cell_access_mode.id      = c.id;
        cell_access_mode.crit    = c.crit;
        cell_access_mode.value   = c.value.cell_access_mode();
        break;
      case 242:
        ce_mode_b_support_ind_present = true;
        ce_mode_b_support_ind.id      = c.id;
        ce_mode_b_support_ind.crit    = c.crit;
        ce_mode_b_support_ind.value   = c.value.ce_mode_b_support_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  erab_admitted_list.to_json(j);
  if (erab_failed_to_setup_list_ho_req_ack_present) {
    j.write_fieldname("");
    erab_failed_to_setup_list_ho_req_ack.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (csg_id_present) {
    j.write_fieldname("");
    csg_id.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (cell_access_mode_present) {
    j.write_fieldname("");
    cell_access_mode.to_json(j);
  }
  if (ce_mode_b_support_ind_present) {
    j.write_fieldname("");
    ce_mode_b_support_ind.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestAcknowledge ::= SEQUENCE
SRSASN_CODE ho_request_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_request_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// TargetNgRanNode-ID ::= SEQUENCE
SRSASN_CODE target_ng_ran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ng_ran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ng_ran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-RAN-NODE-ID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selected-TAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Direct-Forwarding-Path-Availability ::= ENUMERATED
const char* direct_forwarding_path_availability_opts::to_string() const
{
  static const char* options[] = {"directPathAvailable"};
  return convert_enum_idx(options, 1, value, "direct_forwarding_path_availability_e");
}

// PS-ServiceNotAvailable ::= ENUMERATED
const char* ps_service_not_available_opts::to_string() const
{
  static const char* options[] = {"ps-service-not-available"};
  return convert_enum_idx(options, 1, value, "ps_service_not_available_e");
}

// SRVCCHOIndication ::= ENUMERATED
const char* srvccho_ind_opts::to_string() const
{
  static const char* options[] = {"pSandCS", "cSonly"};
  return convert_enum_idx(options, 2, value, "srvccho_ind_e");
}

// TargetID ::= CHOICE
void target_id_c::destroy_()
{
  switch (type_) {
    case types::targetenb_id:
      c.destroy<targetenb_id_s>();
      break;
    case types::target_rnc_id:
      c.destroy<target_rnc_id_s>();
      break;
    case types::cgi:
      c.destroy<cgi_s>();
      break;
    case types::targetg_ng_ran_node_id:
      c.destroy<target_ng_ran_node_id_s>();
      break;
    default:
      break;
  }
}
void target_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::targetenb_id:
      c.init<targetenb_id_s>();
      break;
    case types::target_rnc_id:
      c.init<target_rnc_id_s>();
      break;
    case types::cgi:
      c.init<cgi_s>();
      break;
    case types::targetg_ng_ran_node_id:
      c.init<target_ng_ran_node_id_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c::target_id_c(const target_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::targetenb_id:
      c.init(other.c.get<targetenb_id_s>());
      break;
    case types::target_rnc_id:
      c.init(other.c.get<target_rnc_id_s>());
      break;
    case types::cgi:
      c.init(other.c.get<cgi_s>());
      break;
    case types::targetg_ng_ran_node_id:
      c.init(other.c.get<target_ng_ran_node_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c& target_id_c::operator=(const target_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::targetenb_id:
      c.set(other.c.get<targetenb_id_s>());
      break;
    case types::target_rnc_id:
      c.set(other.c.get<target_rnc_id_s>());
      break;
    case types::cgi:
      c.set(other.c.get<cgi_s>());
      break;
    case types::targetg_ng_ran_node_id:
      c.set(other.c.get<target_ng_ran_node_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }

  return *this;
}
targetenb_id_s& target_id_c::set_targetenb_id()
{
  set(types::targetenb_id);
  return c.get<targetenb_id_s>();
}
target_rnc_id_s& target_id_c::set_target_rnc_id()
{
  set(types::target_rnc_id);
  return c.get<target_rnc_id_s>();
}
cgi_s& target_id_c::set_cgi()
{
  set(types::cgi);
  return c.get<cgi_s>();
}
target_ng_ran_node_id_s& target_id_c::set_targetg_ng_ran_node_id()
{
  set(types::targetg_ng_ran_node_id);
  return c.get<target_ng_ran_node_id_s>();
}
void target_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::targetenb_id:
      j.write_fieldname("targeteNB-ID");
      c.get<targetenb_id_s>().to_json(j);
      break;
    case types::target_rnc_id:
      j.write_fieldname("targetRNC-ID");
      c.get<target_rnc_id_s>().to_json(j);
      break;
    case types::cgi:
      j.write_fieldname("cGI");
      c.get<cgi_s>().to_json(j);
      break;
    case types::targetg_ng_ran_node_id:
      j.write_fieldname("targetgNgRanNode-ID");
      c.get<target_ng_ran_node_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
  j.end_obj();
}
SRSASN_CODE target_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::targetenb_id:
      HANDLE_CODE(c.get<targetenb_id_s>().pack(bref));
      break;
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().pack(bref));
      break;
    case types::cgi:
      HANDLE_CODE(c.get<cgi_s>().pack(bref));
      break;
    case types::targetg_ng_ran_node_id: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<target_ng_ran_node_id_s>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::targetenb_id:
      HANDLE_CODE(c.get<targetenb_id_s>().unpack(bref));
      break;
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().unpack(bref));
      break;
    case types::cgi:
      HANDLE_CODE(c.get<cgi_s>().unpack(bref));
      break;
    case types::targetg_ng_ran_node_id: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<target_ng_ran_node_id_s>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_id_c::types_opts::to_string() const
{
  static const char* options[] = {"targeteNB-ID", "targetRNC-ID", "cGI", "targetgNgRanNode-ID"};
  return convert_enum_idx(options, 4, value, "target_id_c::types");
}

// HandoverRequiredIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ho_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 1, 2, 4, 79, 125, 104, 138, 132, 133, 127, 145, 150};
  return map_enum_number(options, 14, idx, "id");
}
bool ho_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 1, 2, 4, 79, 125, 104, 138, 132, 133, 127, 145, 150};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 1:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    case 4:
      return crit_e::reject;
    case 79:
      return crit_e::ignore;
    case 125:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 138:
      return crit_e::reject;
    case 132:
      return crit_e::reject;
    case 133:
      return crit_e::ignore;
    case 127:
      return crit_e::reject;
    case 145:
      return crit_e::reject;
    case 150:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ho_required_ies_o::value_c ho_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 1:
      ret.set(value_c::types::handov_type);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 4:
      ret.set(value_c::types::target_id);
      break;
    case 79:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 125:
      ret.set(value_c::types::srvccho_ind);
      break;
    case 104:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 138:
      ret.set(value_c::types::source_to_target_transparent_container_secondary);
      break;
    case 132:
      ret.set(value_c::types::ms_classmark2);
      break;
    case 133:
      ret.set(value_c::types::ms_classmark3);
      break;
    case 127:
      ret.set(value_c::types::csg_id);
      break;
    case 145:
      ret.set(value_c::types::cell_access_mode);
      break;
    case 150:
      ret.set(value_c::types::ps_service_not_available);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ho_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 1:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 4:
      return presence_e::mandatory;
    case 79:
      return presence_e::optional;
    case 125:
      return presence_e::optional;
    case 104:
      return presence_e::mandatory;
    case 138:
      return presence_e::optional;
    case 132:
      return presence_e::conditional;
    case 133:
      return presence_e::conditional;
    case 127:
      return presence_e::optional;
    case 145:
      return presence_e::optional;
    case 150:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::target_id:
      c.destroy<target_id_c>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::source_to_target_transparent_container_secondary:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ms_classmark2:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ms_classmark3:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.destroy<fixed_bitstring<27, false, true> >();
      break;
    default:
      break;
  }
}
void ho_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::target_id:
      c.init<target_id_c>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::srvccho_ind:
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true> >();
      break;
    case types::source_to_target_transparent_container_secondary:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ms_classmark2:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ms_classmark3:
      c.init<unbounded_octstring<true> >();
      break;
    case types::csg_id:
      c.init<fixed_bitstring<27, false, true> >();
      break;
    case types::cell_access_mode:
      break;
    case types::ps_service_not_available:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c::value_c(const ho_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.init(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::srvccho_ind:
      c.init(other.c.get<srvccho_ind_e>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::source_to_target_transparent_container_secondary:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ms_classmark2:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ms_classmark3:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.init(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::cell_access_mode:
      c.init(other.c.get<cell_access_mode_e>());
      break;
    case types::ps_service_not_available:
      c.init(other.c.get<ps_service_not_available_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c& ho_required_ies_o::value_c::operator=(const ho_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.set(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::srvccho_ind:
      c.set(other.c.get<srvccho_ind_e>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::source_to_target_transparent_container_secondary:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ms_classmark2:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ms_classmark3:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::csg_id:
      c.set(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::cell_access_mode:
      c.set(other.c.get<cell_access_mode_e>());
      break;
    case types::ps_service_not_available:
      c.set(other.c.get<ps_service_not_available_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_required_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ho_required_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
handov_type_e& ho_required_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
target_id_c& ho_required_ies_o::value_c::target_id()
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
srvccho_ind_e& ho_required_ies_o::value_c::srvccho_ind()
{
  assert_choice_type(types::srvccho_ind, type_, "Value");
  return c.get<srvccho_ind_e>();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container_secondary()
{
  assert_choice_type(types::source_to_target_transparent_container_secondary, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::ms_classmark2()
{
  assert_choice_type(types::ms_classmark2, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::ms_classmark3()
{
  assert_choice_type(types::ms_classmark3, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
fixed_bitstring<27, false, true>& ho_required_ies_o::value_c::csg_id()
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
cell_access_mode_e& ho_required_ies_o::value_c::cell_access_mode()
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
ps_service_not_available_e& ho_required_ies_o::value_c::ps_service_not_available()
{
  assert_choice_type(types::ps_service_not_available, type_, "Value");
  return c.get<ps_service_not_available_e>();
}
const uint64_t& ho_required_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ho_required_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const handov_type_e& ho_required_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const target_id_c& ho_required_ies_o::value_c::target_id() const
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
const direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const srvccho_ind_e& ho_required_ies_o::value_c::srvccho_ind() const
{
  assert_choice_type(types::srvccho_ind, type_, "Value");
  return c.get<srvccho_ind_e>();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container_secondary() const
{
  assert_choice_type(types::source_to_target_transparent_container_secondary, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::ms_classmark2() const
{
  assert_choice_type(types::ms_classmark2, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::ms_classmark3() const
{
  assert_choice_type(types::ms_classmark3, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const fixed_bitstring<27, false, true>& ho_required_ies_o::value_c::csg_id() const
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
const cell_access_mode_e& ho_required_ies_o::value_c::cell_access_mode() const
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
const ps_service_not_available_e& ho_required_ies_o::value_c::ps_service_not_available() const
{
  assert_choice_type(types::ps_service_not_available, type_, "Value");
  return c.get<ps_service_not_available_e>();
}
void ho_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::target_id:
      j.write_fieldname("TargetID");
      c.get<target_id_c>().to_json(j);
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("Direct-Forwarding-Path-Availability", "directPathAvailable");
      break;
    case types::srvccho_ind:
      j.write_str("SRVCCHOIndication", c.get<srvccho_ind_e>().to_string());
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::source_to_target_transparent_container_secondary:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ms_classmark2:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ms_classmark3:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::csg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<27, false, true> >().to_string());
      break;
    case types::cell_access_mode:
      j.write_str("CellAccessMode", "hybrid");
      break;
    case types::ps_service_not_available:
      j.write_str("PS-ServiceNotAvailable", "ps-service-not-available");
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::srvccho_ind:
      HANDLE_CODE(c.get<srvccho_ind_e>().pack(bref));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::source_to_target_transparent_container_secondary:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ms_classmark2:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ms_classmark3:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().pack(bref)));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().pack(bref));
      break;
    case types::ps_service_not_available:
      HANDLE_CODE(c.get<ps_service_not_available_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::srvccho_ind:
      HANDLE_CODE(c.get<srvccho_ind_e>().unpack(bref));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::source_to_target_transparent_container_secondary:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ms_classmark2:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ms_classmark3:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().unpack(bref)));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().unpack(bref));
      break;
    case types::ps_service_not_available:
      HANDLE_CODE(c.get<ps_service_not_available_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_required_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "HandoverType",
                                  "Cause",
                                  "TargetID",
                                  "Direct-Forwarding-Path-Availability",
                                  "SRVCCHOIndication",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "BIT STRING",
                                  "CellAccessMode",
                                  "PS-ServiceNotAvailable"};
  return convert_enum_idx(options, 14, value, "ho_required_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<ho_required_ies_o>;

ho_required_ies_container::ho_required_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  handov_type(1, crit_e::reject),
  cause(2, crit_e::ignore),
  target_id(4, crit_e::reject),
  direct_forwarding_path_availability(79, crit_e::ignore),
  srvccho_ind(125, crit_e::reject),
  source_to_target_transparent_container(104, crit_e::reject),
  source_to_target_transparent_container_secondary(138, crit_e::reject),
  ms_classmark2(132, crit_e::reject),
  ms_classmark3(133, crit_e::ignore),
  csg_id(127, crit_e::reject),
  cell_access_mode(145, crit_e::reject),
  ps_service_not_available(150, crit_e::ignore)
{}
SRSASN_CODE ho_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  nof_ies += srvccho_ind_present ? 1 : 0;
  nof_ies += source_to_target_transparent_container_secondary_present ? 1 : 0;
  nof_ies += ms_classmark2_present ? 1 : 0;
  nof_ies += ms_classmark3_present ? 1 : 0;
  nof_ies += csg_id_present ? 1 : 0;
  nof_ies += cell_access_mode_present ? 1 : 0;
  nof_ies += ps_service_not_available_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(target_id.pack(bref));
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (srvccho_ind_present) {
    HANDLE_CODE(srvccho_ind.pack(bref));
  }
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  if (source_to_target_transparent_container_secondary_present) {
    HANDLE_CODE(source_to_target_transparent_container_secondary.pack(bref));
  }
  if (ms_classmark2_present) {
    HANDLE_CODE(ms_classmark2.pack(bref));
  }
  if (ms_classmark3_present) {
    HANDLE_CODE(ms_classmark3.pack(bref));
  }
  if (csg_id_present) {
    HANDLE_CODE(csg_id.pack(bref));
  }
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.pack(bref));
  }
  if (ps_service_not_available_present) {
    HANDLE_CODE(ps_service_not_available.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ho_required_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 1:
        nof_mandatory_ies--;
        handov_type.id    = c.id;
        handov_type.crit  = c.crit;
        handov_type.value = c.value.handov_type();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 4:
        nof_mandatory_ies--;
        target_id.id    = c.id;
        target_id.crit  = c.crit;
        target_id.value = c.value.target_id();
        break;
      case 79:
        direct_forwarding_path_availability_present = true;
        direct_forwarding_path_availability.id      = c.id;
        direct_forwarding_path_availability.crit    = c.crit;
        direct_forwarding_path_availability.value   = c.value.direct_forwarding_path_availability();
        break;
      case 125:
        srvccho_ind_present = true;
        srvccho_ind.id      = c.id;
        srvccho_ind.crit    = c.crit;
        srvccho_ind.value   = c.value.srvccho_ind();
        break;
      case 104:
        nof_mandatory_ies--;
        source_to_target_transparent_container.id    = c.id;
        source_to_target_transparent_container.crit  = c.crit;
        source_to_target_transparent_container.value = c.value.source_to_target_transparent_container();
        break;
      case 138:
        source_to_target_transparent_container_secondary_present = true;
        source_to_target_transparent_container_secondary.id      = c.id;
        source_to_target_transparent_container_secondary.crit    = c.crit;
        source_to_target_transparent_container_secondary.value =
            c.value.source_to_target_transparent_container_secondary();
        break;
      case 132:
        ms_classmark2_present = true;
        ms_classmark2.id      = c.id;
        ms_classmark2.crit    = c.crit;
        ms_classmark2.value   = c.value.ms_classmark2();
        break;
      case 133:
        ms_classmark3_present = true;
        ms_classmark3.id      = c.id;
        ms_classmark3.crit    = c.crit;
        ms_classmark3.value   = c.value.ms_classmark3();
        break;
      case 127:
        csg_id_present = true;
        csg_id.id      = c.id;
        csg_id.crit    = c.crit;
        csg_id.value   = c.value.csg_id();
        break;
      case 145:
        cell_access_mode_present = true;
        cell_access_mode.id      = c.id;
        cell_access_mode.crit    = c.crit;
        cell_access_mode.value   = c.value.cell_access_mode();
        break;
      case 150:
        ps_service_not_available_present = true;
        ps_service_not_available.id      = c.id;
        ps_service_not_available.crit    = c.crit;
        ps_service_not_available.value   = c.value.ps_service_not_available();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  target_id.to_json(j);
  if (direct_forwarding_path_availability_present) {
    j.write_fieldname("");
    direct_forwarding_path_availability.to_json(j);
  }
  if (srvccho_ind_present) {
    j.write_fieldname("");
    srvccho_ind.to_json(j);
  }
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  if (source_to_target_transparent_container_secondary_present) {
    j.write_fieldname("");
    source_to_target_transparent_container_secondary.to_json(j);
  }
  if (ms_classmark2_present) {
    j.write_fieldname("");
    ms_classmark2.to_json(j);
  }
  if (ms_classmark3_present) {
    j.write_fieldname("");
    ms_classmark3.to_json(j);
  }
  if (csg_id_present) {
    j.write_fieldname("");
    csg_id.to_json(j);
  }
  if (cell_access_mode_present) {
    j.write_fieldname("");
    cell_access_mode.to_json(j);
  }
  if (ps_service_not_available_present) {
    j.write_fieldname("");
    ps_service_not_available.to_json(j);
  }
  j.end_obj();
}

// HandoverRequired ::= SEQUENCE
SRSASN_CODE ho_required_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ho_required_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// MMEPagingTarget ::= CHOICE
void mme_paging_target_c::destroy_()
{
  switch (type_) {
    case types::global_enb_id:
      c.destroy<global_enb_id_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    default:
      break;
  }
}
void mme_paging_target_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_enb_id:
      c.init<global_enb_id_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
  }
}
mme_paging_target_c::mme_paging_target_c(const mme_paging_target_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_enb_id:
      c.init(other.c.get<global_enb_id_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
  }
}
mme_paging_target_c& mme_paging_target_c::operator=(const mme_paging_target_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_enb_id:
      c.set(other.c.get<global_enb_id_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
  }

  return *this;
}
global_enb_id_s& mme_paging_target_c::set_global_enb_id()
{
  set(types::global_enb_id);
  return c.get<global_enb_id_s>();
}
tai_s& mme_paging_target_c::set_tai()
{
  set(types::tai);
  return c.get<tai_s>();
}
void mme_paging_target_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_enb_id:
      j.write_fieldname("global-ENB-ID");
      c.get<global_enb_id_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("tAI");
      c.get<tai_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
  }
  j.end_obj();
}
SRSASN_CODE mme_paging_target_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_paging_target_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_paging_target_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mme_paging_target_c::types_opts::to_string() const
{
  static const char* options[] = {"global-ENB-ID", "tAI"};
  return convert_enum_idx(options, 2, value, "mme_paging_target_c::types");
}

// RecommendedENBItem ::= SEQUENCE
SRSASN_CODE recommended_enb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mme_paging_target.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_enb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mme_paging_target.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_enb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mMEPagingTarget");
  mme_paging_target.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedENBItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t recommended_enb_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {215};
  return map_enum_number(options, 1, idx, "id");
}
bool recommended_enb_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 215 == id;
}
crit_e recommended_enb_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 215) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
recommended_enb_item_ies_o::value_c recommended_enb_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 215) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e recommended_enb_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 215) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void recommended_enb_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RecommendedENBItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE recommended_enb_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_enb_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* recommended_enb_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"RecommendedENBItem"};
  return convert_enum_idx(options, 1, value, "recommended_enb_item_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<recommended_enb_item_ies_o>;

// RecommendedENBsForPaging ::= SEQUENCE
SRSASN_CODE recommended_enbs_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_enb_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_enbs_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_enb_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_enbs_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedENBList");
  for (const auto& e1 : recommended_enb_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InformationOnRecommendedCellsAndENBsForPaging ::= SEQUENCE
SRSASN_CODE info_on_recommended_cells_and_enbs_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  HANDLE_CODE(recommend_enbs_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE info_on_recommended_cells_and_enbs_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  HANDLE_CODE(recommend_enbs_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void info_on_recommended_cells_and_enbs_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  j.write_fieldname("recommendENBsForPaging");
  recommend_enbs_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t init_context_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool init_context_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
init_context_setup_fail_ies_o::value_c init_context_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c::value_c(const init_context_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c&
init_context_setup_fail_ies_o::value_c::operator=(const init_context_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& init_context_setup_fail_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& init_context_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& init_context_setup_fail_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& init_context_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "init_context_setup_fail_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<init_context_setup_fail_ies_o>;

init_context_setup_fail_ies_container::init_context_setup_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE init_context_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<init_context_setup_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupFailure ::= SEQUENCE
SRSASN_CODE init_context_setup_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void init_context_setup_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// AdditionalCSFallbackIndicator ::= ENUMERATED
const char* add_cs_fallback_ind_opts::to_string() const
{
  static const char* options[] = {"no-restriction", "restriction"};
  return convert_enum_idx(options, 2, value, "add_cs_fallback_ind_e");
}

// CSFallbackIndicator ::= ENUMERATED
const char* cs_fallback_ind_opts::to_string() const
{
  static const char* options[] = {"cs-fallback-required", "cs-fallback-high-priority"};
  return convert_enum_idx(options, 2, value, "cs_fallback_ind_e");
}

// InitialContextSetupRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t init_context_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0,   8,   66,  24,  107, 73,  25,  41,  74,  106, 108, 124, 146, 159, 75,  158,
                                     165, 177, 187, 192, 196, 195, 241, 240, 248, 251, 269, 271, 277, 283, 278, 299};
  return map_enum_number(options, 32, idx, "id");
}
bool init_context_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0,   8,   66,  24,  107, 73,  25,  41,  74,  106, 108, 124, 146, 159, 75,  158,
                                     165, 177, 187, 192, 196, 195, 241, 240, 248, 251, 269, 271, 277, 283, 278, 299};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 24:
      return crit_e::reject;
    case 107:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    case 41:
      return crit_e::ignore;
    case 74:
      return crit_e::ignore;
    case 106:
      return crit_e::ignore;
    case 108:
      return crit_e::reject;
    case 124:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 159:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 187:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 196:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 241:
      return crit_e::ignore;
    case 240:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
init_context_setup_request_ies_o::value_c init_context_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 24:
      ret.set(value_c::types::erab_to_be_setup_list_ctxt_su_req);
      break;
    case 107:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 73:
      ret.set(value_c::types::security_key);
      break;
    case 25:
      ret.set(value_c::types::trace_activation);
      break;
    case 41:
      ret.set(value_c::types::ho_restrict_list);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 106:
      ret.set(value_c::types::subscriber_profile_idfor_rfp);
      break;
    case 108:
      ret.set(value_c::types::cs_fallback_ind);
      break;
    case 124:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 159:
      ret.set(value_c::types::registered_lai);
      break;
    case 75:
      ret.set(value_c::types::gummei_id);
      break;
    case 158:
      ret.set(value_c::types::mme_ue_s1ap_id_minus2);
      break;
    case 165:
      ret.set(value_c::types::management_based_mdt_allowed);
      break;
    case 177:
      ret.set(value_c::types::management_based_mdtplmn_list);
      break;
    case 187:
      ret.set(value_c::types::add_cs_fallback_ind);
      break;
    case 192:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 196:
      ret.set(value_c::types::expected_ue_behaviour);
      break;
    case 195:
      ret.set(value_c::types::pro_se_authorized);
      break;
    case 241:
      ret.set(value_c::types::ueuser_plane_cio_tsupport_ind);
      break;
    case 240:
      ret.set(value_c::types::v2xservices_authorized);
      break;
    case 248:
      ret.set(value_c::types::ue_sidelink_aggregate_maximum_bitrate);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 277:
      ret.set(value_c::types::aerial_uesubscription_info);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 299:
      ret.set(value_c::types::add_rrm_prio_idx);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 66:
      return presence_e::mandatory;
    case 24:
      return presence_e::mandatory;
    case 107:
      return presence_e::mandatory;
    case 73:
      return presence_e::mandatory;
    case 25:
      return presence_e::optional;
    case 41:
      return presence_e::optional;
    case 74:
      return presence_e::optional;
    case 106:
      return presence_e::optional;
    case 108:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 159:
      return presence_e::optional;
    case 75:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 187:
      return presence_e::conditional;
    case 192:
      return presence_e::optional;
    case 196:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 241:
      return presence_e::optional;
    case 240:
      return presence_e::optional;
    case 248:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      c.destroy<erab_to_be_setup_list_ctxt_su_req_l>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true> >();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::ho_restrict_list:
      c.destroy<ho_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::registered_lai:
      c.destroy<lai_s>();
      break;
    case types::gummei_id:
      c.destroy<gummei_s>();
      break;
    case types::management_based_mdtplmn_list:
      c.destroy<mdtplmn_list_l>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true> >();
      break;
    case types::expected_ue_behaviour:
      c.destroy<expected_ue_behaviour_s>();
      break;
    case types::pro_se_authorized:
      c.destroy<pro_se_authorized_s>();
      break;
    case types::v2xservices_authorized:
      c.destroy<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.destroy<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    default:
      break;
  }
}
void init_context_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      c.init<erab_to_be_setup_list_ctxt_su_req_l>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true> >();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::ho_restrict_list:
      c.init<ho_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::subscriber_profile_idfor_rfp:
      break;
    case types::cs_fallback_ind:
      break;
    case types::srvcc_operation_possible:
      break;
    case types::csg_membership_status:
      break;
    case types::registered_lai:
      c.init<lai_s>();
      break;
    case types::gummei_id:
      c.init<gummei_s>();
      break;
    case types::mme_ue_s1ap_id_minus2:
      break;
    case types::management_based_mdt_allowed:
      break;
    case types::management_based_mdtplmn_list:
      c.init<mdtplmn_list_l>();
      break;
    case types::add_cs_fallback_ind:
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true> >();
      break;
    case types::expected_ue_behaviour:
      c.init<expected_ue_behaviour_s>();
      break;
    case types::pro_se_authorized:
      c.init<pro_se_authorized_s>();
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      break;
    case types::v2xservices_authorized:
      c.init<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::aerial_uesubscription_info:
      break;
    case types::pending_data_ind:
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c::value_c(const init_context_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      c.init(other.c.get<erab_to_be_setup_list_ctxt_su_req_l>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true> >());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::ho_restrict_list:
      c.init(other.c.get<ho_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::cs_fallback_ind:
      c.init(other.c.get<cs_fallback_ind_e>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::registered_lai:
      c.init(other.c.get<lai_s>());
      break;
    case types::gummei_id:
      c.init(other.c.get<gummei_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.init(other.c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      c.init(other.c.get<management_based_mdt_allowed_e>());
      break;
    case types::management_based_mdtplmn_list:
      c.init(other.c.get<mdtplmn_list_l>());
      break;
    case types::add_cs_fallback_ind:
      c.init(other.c.get<add_cs_fallback_ind_e>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true> >());
      break;
    case types::expected_ue_behaviour:
      c.init(other.c.get<expected_ue_behaviour_s>());
      break;
    case types::pro_se_authorized:
      c.init(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.init(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.init(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.init(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c&
init_context_setup_request_ies_o::value_c::operator=(const init_context_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      c.set(other.c.get<erab_to_be_setup_list_ctxt_su_req_l>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true> >());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::ho_restrict_list:
      c.set(other.c.get<ho_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::cs_fallback_ind:
      c.set(other.c.get<cs_fallback_ind_e>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::registered_lai:
      c.set(other.c.get<lai_s>());
      break;
    case types::gummei_id:
      c.set(other.c.get<gummei_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.set(other.c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      c.set(other.c.get<management_based_mdt_allowed_e>());
      break;
    case types::management_based_mdtplmn_list:
      c.set(other.c.get<mdtplmn_list_l>());
      break;
    case types::add_cs_fallback_ind:
      c.set(other.c.get<add_cs_fallback_ind_e>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true> >());
      break;
    case types::expected_ue_behaviour:
      c.set(other.c.get<expected_ue_behaviour_s>());
      break;
    case types::pro_se_authorized:
      c.set(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.set(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.set(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.set(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.set(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& init_context_setup_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
ue_aggregate_maximum_bitrate_s& init_context_setup_request_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_to_be_setup_list_ctxt_su_req_l& init_context_setup_request_ies_o::value_c::erab_to_be_setup_list_ctxt_su_req()
{
  assert_choice_type(types::erab_to_be_setup_list_ctxt_su_req, type_, "Value");
  return c.get<erab_to_be_setup_list_ctxt_su_req_l>();
}
ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true> >();
}
trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
ho_restrict_list_s& init_context_setup_request_ies_o::value_c::ho_restrict_list()
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
uint16_t& init_context_setup_request_ies_o::value_c::subscriber_profile_idfor_rfp()
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
cs_fallback_ind_e& init_context_setup_request_ies_o::value_c::cs_fallback_ind()
{
  assert_choice_type(types::cs_fallback_ind, type_, "Value");
  return c.get<cs_fallback_ind_e>();
}
srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
csg_membership_status_e& init_context_setup_request_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
lai_s& init_context_setup_request_ies_o::value_c::registered_lai()
{
  assert_choice_type(types::registered_lai, type_, "Value");
  return c.get<lai_s>();
}
gummei_s& init_context_setup_request_ies_o::value_c::gummei_id()
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
uint64_t& init_context_setup_request_ies_o::value_c::mme_ue_s1ap_id_minus2()
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
management_based_mdt_allowed_e& init_context_setup_request_ies_o::value_c::management_based_mdt_allowed()
{
  assert_choice_type(types::management_based_mdt_allowed, type_, "Value");
  return c.get<management_based_mdt_allowed_e>();
}
mdtplmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdtplmn_list()
{
  assert_choice_type(types::management_based_mdtplmn_list, type_, "Value");
  return c.get<mdtplmn_list_l>();
}
add_cs_fallback_ind_e& init_context_setup_request_ies_o::value_c::add_cs_fallback_ind()
{
  assert_choice_type(types::add_cs_fallback_ind, type_, "Value");
  return c.get<add_cs_fallback_ind_e>();
}
fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true> >();
}
expected_ue_behaviour_s& init_context_setup_request_ies_o::value_c::expected_ue_behaviour()
{
  assert_choice_type(types::expected_ue_behaviour, type_, "Value");
  return c.get<expected_ue_behaviour_s>();
}
pro_se_authorized_s& init_context_setup_request_ies_o::value_c::pro_se_authorized()
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
ueuser_plane_cio_tsupport_ind_e& init_context_setup_request_ies_o::value_c::ueuser_plane_cio_tsupport_ind()
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
v2xservices_authorized_s& init_context_setup_request_ies_o::value_c::v2xservices_authorized()
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
ue_sidelink_aggregate_maximum_bitrate_s&
init_context_setup_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate()
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
enhanced_coverage_restricted_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
nrue_security_cap_s& init_context_setup_request_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
aerial_uesubscription_info_e& init_context_setup_request_ies_o::value_c::aerial_uesubscription_info()
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
pending_data_ind_e& init_context_setup_request_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
subscription_based_ue_differentiation_info_s&
init_context_setup_request_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
fixed_bitstring<32, false, true>& init_context_setup_request_ies_o::value_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
const uint64_t& init_context_setup_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& init_context_setup_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const ue_aggregate_maximum_bitrate_s& init_context_setup_request_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_to_be_setup_list_ctxt_su_req_l&
init_context_setup_request_ies_o::value_c::erab_to_be_setup_list_ctxt_su_req() const
{
  assert_choice_type(types::erab_to_be_setup_list_ctxt_su_req, type_, "Value");
  return c.get<erab_to_be_setup_list_ctxt_su_req_l>();
}
const ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true> >();
}
const trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const ho_restrict_list_s& init_context_setup_request_ies_o::value_c::ho_restrict_list() const
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint16_t& init_context_setup_request_ies_o::value_c::subscriber_profile_idfor_rfp() const
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
const cs_fallback_ind_e& init_context_setup_request_ies_o::value_c::cs_fallback_ind() const
{
  assert_choice_type(types::cs_fallback_ind, type_, "Value");
  return c.get<cs_fallback_ind_e>();
}
const srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const csg_membership_status_e& init_context_setup_request_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const lai_s& init_context_setup_request_ies_o::value_c::registered_lai() const
{
  assert_choice_type(types::registered_lai, type_, "Value");
  return c.get<lai_s>();
}
const gummei_s& init_context_setup_request_ies_o::value_c::gummei_id() const
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::mme_ue_s1ap_id_minus2() const
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
const management_based_mdt_allowed_e& init_context_setup_request_ies_o::value_c::management_based_mdt_allowed() const
{
  assert_choice_type(types::management_based_mdt_allowed, type_, "Value");
  return c.get<management_based_mdt_allowed_e>();
}
const mdtplmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdtplmn_list() const
{
  assert_choice_type(types::management_based_mdtplmn_list, type_, "Value");
  return c.get<mdtplmn_list_l>();
}
const add_cs_fallback_ind_e& init_context_setup_request_ies_o::value_c::add_cs_fallback_ind() const
{
  assert_choice_type(types::add_cs_fallback_ind, type_, "Value");
  return c.get<add_cs_fallback_ind_e>();
}
const fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true> >();
}
const expected_ue_behaviour_s& init_context_setup_request_ies_o::value_c::expected_ue_behaviour() const
{
  assert_choice_type(types::expected_ue_behaviour, type_, "Value");
  return c.get<expected_ue_behaviour_s>();
}
const pro_se_authorized_s& init_context_setup_request_ies_o::value_c::pro_se_authorized() const
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
const ueuser_plane_cio_tsupport_ind_e& init_context_setup_request_ies_o::value_c::ueuser_plane_cio_tsupport_ind() const
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
const v2xservices_authorized_s& init_context_setup_request_ies_o::value_c::v2xservices_authorized() const
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
const ue_sidelink_aggregate_maximum_bitrate_s&
init_context_setup_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate() const
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
const enhanced_coverage_restricted_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const nrue_security_cap_s& init_context_setup_request_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const aerial_uesubscription_info_e& init_context_setup_request_ies_o::value_c::aerial_uesubscription_info() const
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
const pending_data_ind_e& init_context_setup_request_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const subscription_based_ue_differentiation_info_s&
init_context_setup_request_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const fixed_bitstring<32, false, true>& init_context_setup_request_ies_o::value_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
void init_context_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      j.start_array("E-RABToBeSetupListCtxtSUReq");
      for (const auto& e1 : c.get<erab_to_be_setup_list_ctxt_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true> >().to_string());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::ho_restrict_list:
      j.write_fieldname("HandoverRestrictionList");
      c.get<ho_restrict_list_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::subscriber_profile_idfor_rfp:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::cs_fallback_ind:
      j.write_str("CSFallbackIndicator", c.get<cs_fallback_ind_e>().to_string());
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", "possible");
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::registered_lai:
      j.write_fieldname("LAI");
      c.get<lai_s>().to_json(j);
      break;
    case types::gummei_id:
      j.write_fieldname("GUMMEI");
      c.get<gummei_s>().to_json(j);
      break;
    case types::mme_ue_s1ap_id_minus2:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::management_based_mdt_allowed:
      j.write_str("ManagementBasedMDTAllowed", "allowed");
      break;
    case types::management_based_mdtplmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdtplmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::add_cs_fallback_ind:
      j.write_str("AdditionalCSFallbackIndicator", c.get<add_cs_fallback_ind_e>().to_string());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true> >().to_string());
      break;
    case types::expected_ue_behaviour:
      j.write_fieldname("ExpectedUEBehaviour");
      c.get<expected_ue_behaviour_s>().to_json(j);
      break;
    case types::pro_se_authorized:
      j.write_fieldname("ProSeAuthorized");
      c.get<pro_se_authorized_s>().to_json(j);
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      j.write_str("UEUserPlaneCIoTSupportIndicator", "supported");
      break;
    case types::v2xservices_authorized:
      j.write_fieldname("V2XServicesAuthorized");
      c.get<v2xservices_authorized_s>().to_json(j);
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      j.write_fieldname("UESidelinkAggregateMaximumBitrate");
      c.get<ue_sidelink_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::aerial_uesubscription_info:
      j.write_str("AerialUEsubscriptionInformation", c.get<aerial_uesubscription_info_e>().to_string());
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_to_be_setup_list_ctxt_su_req_l>(), 1, 256, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true> >().pack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::cs_fallback_ind:
      HANDLE_CODE(c.get<cs_fallback_ind_e>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::registered_lai:
      HANDLE_CODE(c.get<lai_s>().pack(bref));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().pack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::management_based_mdt_allowed:
      HANDLE_CODE(c.get<management_based_mdt_allowed_e>().pack(bref));
      break;
    case types::management_based_mdtplmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdtplmn_list_l>(), 1, 16, true));
      break;
    case types::add_cs_fallback_ind:
      HANDLE_CODE(c.get<add_cs_fallback_ind_e>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true> >().pack(bref)));
      break;
    case types::expected_ue_behaviour:
      HANDLE_CODE(c.get<expected_ue_behaviour_s>().pack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().pack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().pack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().pack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_setup_list_ctxt_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_to_be_setup_list_ctxt_su_req_l>(), bref, 1, 256, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true> >().unpack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::cs_fallback_ind:
      HANDLE_CODE(c.get<cs_fallback_ind_e>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::registered_lai:
      HANDLE_CODE(c.get<lai_s>().unpack(bref));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().unpack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::management_based_mdt_allowed:
      HANDLE_CODE(c.get<management_based_mdt_allowed_e>().unpack(bref));
      break;
    case types::management_based_mdtplmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdtplmn_list_l>(), bref, 1, 16, true));
      break;
    case types::add_cs_fallback_ind:
      HANDLE_CODE(c.get<add_cs_fallback_ind_e>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true> >().unpack(bref)));
      break;
    case types::expected_ue_behaviour:
      HANDLE_CODE(c.get<expected_ue_behaviour_s>().unpack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().unpack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().unpack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().unpack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "UEAggregateMaximumBitrate",
                                  "E-RABToBeSetupListCtxtSUReq",
                                  "UESecurityCapabilities",
                                  "BIT STRING",
                                  "TraceActivation",
                                  "HandoverRestrictionList",
                                  "OCTET STRING",
                                  "INTEGER (1..256)",
                                  "CSFallbackIndicator",
                                  "SRVCCOperationPossible",
                                  "CSGMembershipStatus",
                                  "LAI",
                                  "GUMMEI",
                                  "INTEGER (0..4294967295)",
                                  "ManagementBasedMDTAllowed",
                                  "MDTPLMNList",
                                  "AdditionalCSFallbackIndicator",
                                  "BIT STRING",
                                  "ExpectedUEBehaviour",
                                  "ProSeAuthorized",
                                  "UEUserPlaneCIoTSupportIndicator",
                                  "V2XServicesAuthorized",
                                  "UESidelinkAggregateMaximumBitrate",
                                  "EnhancedCoverageRestricted",
                                  "NRUESecurityCapabilities",
                                  "CE-ModeBRestricted",
                                  "AerialUEsubscriptionInformation",
                                  "PendingDataIndication",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "BIT STRING"};
  return convert_enum_idx(options, 32, value, "init_context_setup_request_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<init_context_setup_request_ies_o>;

init_context_setup_request_ies_container::init_context_setup_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  ueaggregate_maximum_bitrate(66, crit_e::reject),
  erab_to_be_setup_list_ctxt_su_req(24, crit_e::reject),
  ue_security_cap(107, crit_e::reject),
  security_key(73, crit_e::reject),
  trace_activation(25, crit_e::ignore),
  ho_restrict_list(41, crit_e::ignore),
  ue_radio_cap(74, crit_e::ignore),
  subscriber_profile_idfor_rfp(106, crit_e::ignore),
  cs_fallback_ind(108, crit_e::reject),
  srvcc_operation_possible(124, crit_e::ignore),
  csg_membership_status(146, crit_e::ignore),
  registered_lai(159, crit_e::ignore),
  gummei_id(75, crit_e::ignore),
  mme_ue_s1ap_id_minus2(158, crit_e::ignore),
  management_based_mdt_allowed(165, crit_e::ignore),
  management_based_mdtplmn_list(177, crit_e::ignore),
  add_cs_fallback_ind(187, crit_e::ignore),
  masked_imeisv(192, crit_e::ignore),
  expected_ue_behaviour(196, crit_e::ignore),
  pro_se_authorized(195, crit_e::ignore),
  ueuser_plane_cio_tsupport_ind(241, crit_e::ignore),
  v2xservices_authorized(240, crit_e::ignore),
  ue_sidelink_aggregate_maximum_bitrate(248, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore),
  aerial_uesubscription_info(277, crit_e::ignore),
  pending_data_ind(283, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore)
{}
SRSASN_CODE init_context_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += ho_restrict_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += subscriber_profile_idfor_rfp_present ? 1 : 0;
  nof_ies += cs_fallback_ind_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += registered_lai_present ? 1 : 0;
  nof_ies += gummei_id_present ? 1 : 0;
  nof_ies += mme_ue_s1ap_id_minus2_present ? 1 : 0;
  nof_ies += management_based_mdt_allowed_present ? 1 : 0;
  nof_ies += management_based_mdtplmn_list_present ? 1 : 0;
  nof_ies += add_cs_fallback_ind_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += expected_ue_behaviour_present ? 1 : 0;
  nof_ies += pro_se_authorized_present ? 1 : 0;
  nof_ies += ueuser_plane_cio_tsupport_ind_present ? 1 : 0;
  nof_ies += v2xservices_authorized_present ? 1 : 0;
  nof_ies += ue_sidelink_aggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += aerial_uesubscription_info_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  HANDLE_CODE(erab_to_be_setup_list_ctxt_su_req.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_key.pack(bref));
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (ho_restrict_list_present) {
    HANDLE_CODE(ho_restrict_list.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (subscriber_profile_idfor_rfp_present) {
    HANDLE_CODE(subscriber_profile_idfor_rfp.pack(bref));
  }
  if (cs_fallback_ind_present) {
    HANDLE_CODE(cs_fallback_ind.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (registered_lai_present) {
    HANDLE_CODE(registered_lai.pack(bref));
  }
  if (gummei_id_present) {
    HANDLE_CODE(gummei_id.pack(bref));
  }
  if (mme_ue_s1ap_id_minus2_present) {
    HANDLE_CODE(mme_ue_s1ap_id_minus2.pack(bref));
  }
  if (management_based_mdt_allowed_present) {
    HANDLE_CODE(management_based_mdt_allowed.pack(bref));
  }
  if (management_based_mdtplmn_list_present) {
    HANDLE_CODE(management_based_mdtplmn_list.pack(bref));
  }
  if (add_cs_fallback_ind_present) {
    HANDLE_CODE(add_cs_fallback_ind.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (pro_se_authorized_present) {
    HANDLE_CODE(pro_se_authorized.pack(bref));
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    HANDLE_CODE(ueuser_plane_cio_tsupport_ind.pack(bref));
  }
  if (v2xservices_authorized_present) {
    HANDLE_CODE(v2xservices_authorized.pack(bref));
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    HANDLE_CODE(ue_sidelink_aggregate_maximum_bitrate.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (aerial_uesubscription_info_present) {
    HANDLE_CODE(aerial_uesubscription_info.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<init_context_setup_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 66:
        nof_mandatory_ies--;
        ueaggregate_maximum_bitrate.id    = c.id;
        ueaggregate_maximum_bitrate.crit  = c.crit;
        ueaggregate_maximum_bitrate.value = c.value.ueaggregate_maximum_bitrate();
        break;
      case 24:
        nof_mandatory_ies--;
        erab_to_be_setup_list_ctxt_su_req.id    = c.id;
        erab_to_be_setup_list_ctxt_su_req.crit  = c.crit;
        erab_to_be_setup_list_ctxt_su_req.value = c.value.erab_to_be_setup_list_ctxt_su_req();
        break;
      case 107:
        nof_mandatory_ies--;
        ue_security_cap.id    = c.id;
        ue_security_cap.crit  = c.crit;
        ue_security_cap.value = c.value.ue_security_cap();
        break;
      case 73:
        nof_mandatory_ies--;
        security_key.id    = c.id;
        security_key.crit  = c.crit;
        security_key.value = c.value.security_key();
        break;
      case 25:
        trace_activation_present = true;
        trace_activation.id      = c.id;
        trace_activation.crit    = c.crit;
        trace_activation.value   = c.value.trace_activation();
        break;
      case 41:
        ho_restrict_list_present = true;
        ho_restrict_list.id      = c.id;
        ho_restrict_list.crit    = c.crit;
        ho_restrict_list.value   = c.value.ho_restrict_list();
        break;
      case 74:
        ue_radio_cap_present = true;
        ue_radio_cap.id      = c.id;
        ue_radio_cap.crit    = c.crit;
        ue_radio_cap.value   = c.value.ue_radio_cap();
        break;
      case 106:
        subscriber_profile_idfor_rfp_present = true;
        subscriber_profile_idfor_rfp.id      = c.id;
        subscriber_profile_idfor_rfp.crit    = c.crit;
        subscriber_profile_idfor_rfp.value   = c.value.subscriber_profile_idfor_rfp();
        break;
      case 108:
        cs_fallback_ind_present = true;
        cs_fallback_ind.id      = c.id;
        cs_fallback_ind.crit    = c.crit;
        cs_fallback_ind.value   = c.value.cs_fallback_ind();
        break;
      case 124:
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = c.id;
        srvcc_operation_possible.crit    = c.crit;
        srvcc_operation_possible.value   = c.value.srvcc_operation_possible();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 159:
        registered_lai_present = true;
        registered_lai.id      = c.id;
        registered_lai.crit    = c.crit;
        registered_lai.value   = c.value.registered_lai();
        break;
      case 75:
        gummei_id_present = true;
        gummei_id.id      = c.id;
        gummei_id.crit    = c.crit;
        gummei_id.value   = c.value.gummei_id();
        break;
      case 158:
        mme_ue_s1ap_id_minus2_present = true;
        mme_ue_s1ap_id_minus2.id      = c.id;
        mme_ue_s1ap_id_minus2.crit    = c.crit;
        mme_ue_s1ap_id_minus2.value   = c.value.mme_ue_s1ap_id_minus2();
        break;
      case 165:
        management_based_mdt_allowed_present = true;
        management_based_mdt_allowed.id      = c.id;
        management_based_mdt_allowed.crit    = c.crit;
        management_based_mdt_allowed.value   = c.value.management_based_mdt_allowed();
        break;
      case 177:
        management_based_mdtplmn_list_present = true;
        management_based_mdtplmn_list.id      = c.id;
        management_based_mdtplmn_list.crit    = c.crit;
        management_based_mdtplmn_list.value   = c.value.management_based_mdtplmn_list();
        break;
      case 187:
        add_cs_fallback_ind_present = true;
        add_cs_fallback_ind.id      = c.id;
        add_cs_fallback_ind.crit    = c.crit;
        add_cs_fallback_ind.value   = c.value.add_cs_fallback_ind();
        break;
      case 192:
        masked_imeisv_present = true;
        masked_imeisv.id      = c.id;
        masked_imeisv.crit    = c.crit;
        masked_imeisv.value   = c.value.masked_imeisv();
        break;
      case 196:
        expected_ue_behaviour_present = true;
        expected_ue_behaviour.id      = c.id;
        expected_ue_behaviour.crit    = c.crit;
        expected_ue_behaviour.value   = c.value.expected_ue_behaviour();
        break;
      case 195:
        pro_se_authorized_present = true;
        pro_se_authorized.id      = c.id;
        pro_se_authorized.crit    = c.crit;
        pro_se_authorized.value   = c.value.pro_se_authorized();
        break;
      case 241:
        ueuser_plane_cio_tsupport_ind_present = true;
        ueuser_plane_cio_tsupport_ind.id      = c.id;
        ueuser_plane_cio_tsupport_ind.crit    = c.crit;
        ueuser_plane_cio_tsupport_ind.value   = c.value.ueuser_plane_cio_tsupport_ind();
        break;
      case 240:
        v2xservices_authorized_present = true;
        v2xservices_authorized.id      = c.id;
        v2xservices_authorized.crit    = c.crit;
        v2xservices_authorized.value   = c.value.v2xservices_authorized();
        break;
      case 248:
        ue_sidelink_aggregate_maximum_bitrate_present = true;
        ue_sidelink_aggregate_maximum_bitrate.id      = c.id;
        ue_sidelink_aggregate_maximum_bitrate.crit    = c.crit;
        ue_sidelink_aggregate_maximum_bitrate.value   = c.value.ue_sidelink_aggregate_maximum_bitrate();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      case 277:
        aerial_uesubscription_info_present = true;
        aerial_uesubscription_info.id      = c.id;
        aerial_uesubscription_info.crit    = c.crit;
        aerial_uesubscription_info.value   = c.value.aerial_uesubscription_info();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.value   = c.value.add_rrm_prio_idx();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  ueaggregate_maximum_bitrate.to_json(j);
  j.write_fieldname("");
  erab_to_be_setup_list_ctxt_su_req.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  security_key.to_json(j);
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (ho_restrict_list_present) {
    j.write_fieldname("");
    ho_restrict_list.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (subscriber_profile_idfor_rfp_present) {
    j.write_fieldname("");
    subscriber_profile_idfor_rfp.to_json(j);
  }
  if (cs_fallback_ind_present) {
    j.write_fieldname("");
    cs_fallback_ind.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (registered_lai_present) {
    j.write_fieldname("");
    registered_lai.to_json(j);
  }
  if (gummei_id_present) {
    j.write_fieldname("");
    gummei_id.to_json(j);
  }
  if (mme_ue_s1ap_id_minus2_present) {
    j.write_fieldname("");
    mme_ue_s1ap_id_minus2.to_json(j);
  }
  if (management_based_mdt_allowed_present) {
    j.write_fieldname("");
    management_based_mdt_allowed.to_json(j);
  }
  if (management_based_mdtplmn_list_present) {
    j.write_fieldname("");
    management_based_mdtplmn_list.to_json(j);
  }
  if (add_cs_fallback_ind_present) {
    j.write_fieldname("");
    add_cs_fallback_ind.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  if (expected_ue_behaviour_present) {
    j.write_fieldname("");
    expected_ue_behaviour.to_json(j);
  }
  if (pro_se_authorized_present) {
    j.write_fieldname("");
    pro_se_authorized.to_json(j);
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    j.write_fieldname("");
    ueuser_plane_cio_tsupport_ind.to_json(j);
  }
  if (v2xservices_authorized_present) {
    j.write_fieldname("");
    v2xservices_authorized.to_json(j);
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ue_sidelink_aggregate_maximum_bitrate.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (aerial_uesubscription_info_present) {
    j.write_fieldname("");
    aerial_uesubscription_info.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupRequest ::= SEQUENCE
SRSASN_CODE init_context_setup_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void init_context_setup_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// InitialContextSetupResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t init_context_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 51, 48, 58};
  return map_enum_number(options, 5, idx, "id");
}
bool init_context_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 51, 48, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 51:
      return crit_e::ignore;
    case 48:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
init_context_setup_resp_ies_o::value_c init_context_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 51:
      ret.set(value_c::types::erab_setup_list_ctxt_su_res);
      break;
    case 48:
      ret.set(value_c::types::erab_failed_to_setup_list_ctxt_su_res);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 51:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_setup_list_ctxt_su_res:
      c.destroy<erab_setup_list_ctxt_su_res_l>();
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      c.destroy<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_setup_list_ctxt_su_res:
      c.init<erab_setup_list_ctxt_su_res_l>();
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      c.init<erab_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c::value_c(const init_context_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_setup_list_ctxt_su_res:
      c.init(other.c.get<erab_setup_list_ctxt_su_res_l>());
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c&
init_context_setup_resp_ies_o::value_c::operator=(const init_context_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_setup_list_ctxt_su_res:
      c.set(other.c.get<erab_setup_list_ctxt_su_res_l>());
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& init_context_setup_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_setup_list_ctxt_su_res_l& init_context_setup_resp_ies_o::value_c::erab_setup_list_ctxt_su_res()
{
  assert_choice_type(types::erab_setup_list_ctxt_su_res, type_, "Value");
  return c.get<erab_setup_list_ctxt_su_res_l>();
}
erab_list_l& init_context_setup_resp_ies_o::value_c::erab_failed_to_setup_list_ctxt_su_res()
{
  assert_choice_type(types::erab_failed_to_setup_list_ctxt_su_res, type_, "Value");
  return c.get<erab_list_l>();
}
crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& init_context_setup_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_setup_list_ctxt_su_res_l& init_context_setup_resp_ies_o::value_c::erab_setup_list_ctxt_su_res() const
{
  assert_choice_type(types::erab_setup_list_ctxt_su_res, type_, "Value");
  return c.get<erab_setup_list_ctxt_su_res_l>();
}
const erab_list_l& init_context_setup_resp_ies_o::value_c::erab_failed_to_setup_list_ctxt_su_res() const
{
  assert_choice_type(types::erab_failed_to_setup_list_ctxt_su_res, type_, "Value");
  return c.get<erab_list_l>();
}
const crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_setup_list_ctxt_su_res:
      j.start_array("E-RABSetupListCtxtSURes");
      for (const auto& e1 : c.get<erab_setup_list_ctxt_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_setup_list_ctxt_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_setup_list_ctxt_su_res_l>(), 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_setup_list_ctxt_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_setup_list_ctxt_su_res_l>(), bref, 1, 256, true));
      break;
    case types::erab_failed_to_setup_list_ctxt_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RABSetupListCtxtSURes",
                                  "E-RABList",
                                  "CriticalityDiagnostics"};
  return convert_enum_idx(options, 5, value, "init_context_setup_resp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<init_context_setup_resp_ies_o>;

init_context_setup_resp_ies_container::init_context_setup_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_setup_list_ctxt_su_res(51, crit_e::ignore),
  erab_failed_to_setup_list_ctxt_su_res(48, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE init_context_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += erab_failed_to_setup_list_ctxt_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(erab_setup_list_ctxt_su_res.pack(bref));
  if (erab_failed_to_setup_list_ctxt_su_res_present) {
    HANDLE_CODE(erab_failed_to_setup_list_ctxt_su_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<init_context_setup_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 51:
        nof_mandatory_ies--;
        erab_setup_list_ctxt_su_res.id    = c.id;
        erab_setup_list_ctxt_su_res.crit  = c.crit;
        erab_setup_list_ctxt_su_res.value = c.value.erab_setup_list_ctxt_su_res();
        break;
      case 48:
        erab_failed_to_setup_list_ctxt_su_res_present = true;
        erab_failed_to_setup_list_ctxt_su_res.id      = c.id;
        erab_failed_to_setup_list_ctxt_su_res.crit    = c.crit;
        erab_failed_to_setup_list_ctxt_su_res.value   = c.value.erab_failed_to_setup_list_ctxt_su_res();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  erab_setup_list_ctxt_su_res.to_json(j);
  if (erab_failed_to_setup_list_ctxt_su_res_present) {
    j.write_fieldname("");
    erab_failed_to_setup_list_ctxt_su_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupResponse ::= SEQUENCE
SRSASN_CODE init_context_setup_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void init_context_setup_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// Coverage-Level ::= ENUMERATED
const char* coverage_level_opts::to_string() const
{
  static const char* options[] = {"extendedcoverage"};
  return convert_enum_idx(options, 1, value, "coverage_level_e");
}

// EDT-Session ::= ENUMERATED
const char* edt_session_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "edt_session_e");
}

// GUMMEIType ::= ENUMERATED
const char* gummei_type_opts::to_string() const
{
  static const char* options[] = {"native", "mapped", "mappedFrom5G"};
  return convert_enum_idx(options, 3, value, "gummei_type_e");
}
uint8_t gummei_type_opts::to_number() const
{
  if (value == mapped_from5_g) {
    return 5;
  }
  invalid_enum_number(value, "gummei_type_e");
  return 0;
}

// RRC-Establishment-Cause ::= ENUMERATED
const char* rrc_establishment_cause_opts::to_string() const
{
  static const char* options[] = {"emergency",
                                  "highPriorityAccess",
                                  "mt-Access",
                                  "mo-Signalling",
                                  "mo-Data",
                                  "delay-TolerantAccess",
                                  "mo-VoiceCall",
                                  "mo-ExceptionData"};
  return convert_enum_idx(options, 8, value, "rrc_establishment_cause_e");
}

// RelayNode-Indicator ::= ENUMERATED
const char* relay_node_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "relay_node_ind_e");
}

// InitialUEMessage-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t init_ue_msg_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {8,   26,  67,  100, 134, 96,  127, 75,  145, 155, 160,
                                     170, 176, 184, 186, 223, 230, 242, 246, 250, 263, 281};
  return map_enum_number(options, 22, idx, "id");
}
bool init_ue_msg_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {8,   26,  67,  100, 134, 96,  127, 75,  145, 155, 160,
                                     170, 176, 184, 186, 223, 230, 242, 246, 250, 263, 281};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_ue_msg_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 8:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 67:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 134:
      return crit_e::ignore;
    case 96:
      return crit_e::reject;
    case 127:
      return crit_e::reject;
    case 75:
      return crit_e::reject;
    case 145:
      return crit_e::reject;
    case 155:
      return crit_e::ignore;
    case 160:
      return crit_e::reject;
    case 170:
      return crit_e::ignore;
    case 176:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 230:
      return crit_e::ignore;
    case 242:
      return crit_e::ignore;
    case 246:
      return crit_e::ignore;
    case 250:
      return crit_e::ignore;
    case 263:
      return crit_e::ignore;
    case 281:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
init_ue_msg_ies_o::value_c init_ue_msg_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 26:
      ret.set(value_c::types::nas_pdu);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 134:
      ret.set(value_c::types::rrc_establishment_cause);
      break;
    case 96:
      ret.set(value_c::types::s_tmsi);
      break;
    case 127:
      ret.set(value_c::types::csg_id);
      break;
    case 75:
      ret.set(value_c::types::gummei_id);
      break;
    case 145:
      ret.set(value_c::types::cell_access_mode);
      break;
    case 155:
      ret.set(value_c::types::gw_transport_layer_address);
      break;
    case 160:
      ret.set(value_c::types::relay_node_ind);
      break;
    case 170:
      ret.set(value_c::types::gummei_type);
      break;
    case 176:
      ret.set(value_c::types::tunnel_info_for_bbf);
      break;
    case 184:
      ret.set(value_c::types::sipto_l_gw_transport_layer_address);
      break;
    case 186:
      ret.set(value_c::types::lhn_id);
      break;
    case 223:
      ret.set(value_c::types::mme_group_id);
      break;
    case 230:
      ret.set(value_c::types::ue_usage_type);
      break;
    case 242:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    case 246:
      ret.set(value_c::types::dcn_id);
      break;
    case 250:
      ret.set(value_c::types::coverage_level);
      break;
    case 263:
      ret.set(value_c::types::ue_application_layer_meas_cap);
      break;
    case 281:
      ret.set(value_c::types::edt_session);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e init_ue_msg_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 8:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 134:
      return presence_e::mandatory;
    case 96:
      return presence_e::optional;
    case 127:
      return presence_e::optional;
    case 75:
      return presence_e::optional;
    case 145:
      return presence_e::optional;
    case 155:
      return presence_e::optional;
    case 160:
      return presence_e::optional;
    case 170:
      return presence_e::optional;
    case 176:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 242:
      return presence_e::optional;
    case 246:
      return presence_e::optional;
    case 250:
      return presence_e::optional;
    case 263:
      return presence_e::optional;
    case 281:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_ue_msg_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::s_tmsi:
      c.destroy<s_tmsi_s>();
      break;
    case types::csg_id:
      c.destroy<fixed_bitstring<27, false, true> >();
      break;
    case types::gummei_id:
      c.destroy<gummei_s>();
      break;
    case types::gw_transport_layer_address:
      c.destroy<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::tunnel_info_for_bbf:
      c.destroy<tunnel_info_s>();
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.destroy<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::lhn_id:
      c.destroy<bounded_octstring<32, 256, true> >();
      break;
    case types::mme_group_id:
      c.destroy<fixed_octstring<2, true> >();
      break;
    case types::ue_application_layer_meas_cap:
      c.destroy<fixed_bitstring<8, false, true> >();
      break;
    default:
      break;
  }
}
void init_ue_msg_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enb_ue_s1ap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::rrc_establishment_cause:
      break;
    case types::s_tmsi:
      c.init<s_tmsi_s>();
      break;
    case types::csg_id:
      c.init<fixed_bitstring<27, false, true> >();
      break;
    case types::gummei_id:
      c.init<gummei_s>();
      break;
    case types::cell_access_mode:
      break;
    case types::gw_transport_layer_address:
      c.init<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::relay_node_ind:
      break;
    case types::gummei_type:
      break;
    case types::tunnel_info_for_bbf:
      c.init<tunnel_info_s>();
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.init<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::lhn_id:
      c.init<bounded_octstring<32, 256, true> >();
      break;
    case types::mme_group_id:
      c.init<fixed_octstring<2, true> >();
      break;
    case types::ue_usage_type:
      break;
    case types::ce_mode_b_support_ind:
      break;
    case types::dcn_id:
      break;
    case types::coverage_level:
      break;
    case types::ue_application_layer_meas_cap:
      c.init<fixed_bitstring<8, false, true> >();
      break;
    case types::edt_session:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c::value_c(const init_ue_msg_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::rrc_establishment_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::s_tmsi:
      c.init(other.c.get<s_tmsi_s>());
      break;
    case types::csg_id:
      c.init(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::gummei_id:
      c.init(other.c.get<gummei_s>());
      break;
    case types::cell_access_mode:
      c.init(other.c.get<cell_access_mode_e>());
      break;
    case types::gw_transport_layer_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::relay_node_ind:
      c.init(other.c.get<relay_node_ind_e>());
      break;
    case types::gummei_type:
      c.init(other.c.get<gummei_type_e>());
      break;
    case types::tunnel_info_for_bbf:
      c.init(other.c.get<tunnel_info_s>());
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::lhn_id:
      c.init(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::mme_group_id:
      c.init(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::ue_usage_type:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ce_mode_b_support_ind:
      c.init(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::dcn_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::coverage_level:
      c.init(other.c.get<coverage_level_e>());
      break;
    case types::ue_application_layer_meas_cap:
      c.init(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::edt_session:
      c.init(other.c.get<edt_session_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c& init_ue_msg_ies_o::value_c::operator=(const init_ue_msg_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::rrc_establishment_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::s_tmsi:
      c.set(other.c.get<s_tmsi_s>());
      break;
    case types::csg_id:
      c.set(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::gummei_id:
      c.set(other.c.get<gummei_s>());
      break;
    case types::cell_access_mode:
      c.set(other.c.get<cell_access_mode_e>());
      break;
    case types::gw_transport_layer_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::relay_node_ind:
      c.set(other.c.get<relay_node_ind_e>());
      break;
    case types::gummei_type:
      c.set(other.c.get<gummei_type_e>());
      break;
    case types::tunnel_info_for_bbf:
      c.set(other.c.get<tunnel_info_s>());
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::lhn_id:
      c.set(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::mme_group_id:
      c.set(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::ue_usage_type:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ce_mode_b_support_ind:
      c.set(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::dcn_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::coverage_level:
      c.set(other.c.get<coverage_level_e>());
      break;
    case types::ue_application_layer_meas_cap:
      c.set(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::edt_session:
      c.set(other.c.get<edt_session_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }

  return *this;
}
uint32_t& init_ue_msg_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
tai_s& init_ue_msg_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
eutran_cgi_s& init_ue_msg_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause()
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
s_tmsi_s& init_ue_msg_ies_o::value_c::s_tmsi()
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
fixed_bitstring<27, false, true>& init_ue_msg_ies_o::value_c::csg_id()
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
gummei_s& init_ue_msg_ies_o::value_c::gummei_id()
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
cell_access_mode_e& init_ue_msg_ies_o::value_c::cell_access_mode()
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
bounded_bitstring<1, 160, true, true>& init_ue_msg_ies_o::value_c::gw_transport_layer_address()
{
  assert_choice_type(types::gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
relay_node_ind_e& init_ue_msg_ies_o::value_c::relay_node_ind()
{
  assert_choice_type(types::relay_node_ind, type_, "Value");
  return c.get<relay_node_ind_e>();
}
gummei_type_e& init_ue_msg_ies_o::value_c::gummei_type()
{
  assert_choice_type(types::gummei_type, type_, "Value");
  return c.get<gummei_type_e>();
}
tunnel_info_s& init_ue_msg_ies_o::value_c::tunnel_info_for_bbf()
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
bounded_bitstring<1, 160, true, true>& init_ue_msg_ies_o::value_c::sipto_l_gw_transport_layer_address()
{
  assert_choice_type(types::sipto_l_gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
bounded_octstring<32, 256, true>& init_ue_msg_ies_o::value_c::lhn_id()
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
fixed_octstring<2, true>& init_ue_msg_ies_o::value_c::mme_group_id()
{
  assert_choice_type(types::mme_group_id, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
uint16_t& init_ue_msg_ies_o::value_c::ue_usage_type()
{
  assert_choice_type(types::ue_usage_type, type_, "Value");
  return c.get<uint16_t>();
}
ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
uint32_t& init_ue_msg_ies_o::value_c::dcn_id()
{
  assert_choice_type(types::dcn_id, type_, "Value");
  return c.get<uint32_t>();
}
coverage_level_e& init_ue_msg_ies_o::value_c::coverage_level()
{
  assert_choice_type(types::coverage_level, type_, "Value");
  return c.get<coverage_level_e>();
}
fixed_bitstring<8, false, true>& init_ue_msg_ies_o::value_c::ue_application_layer_meas_cap()
{
  assert_choice_type(types::ue_application_layer_meas_cap, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
edt_session_e& init_ue_msg_ies_o::value_c::edt_session()
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
const uint32_t& init_ue_msg_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const tai_s& init_ue_msg_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const eutran_cgi_s& init_ue_msg_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause() const
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const s_tmsi_s& init_ue_msg_ies_o::value_c::s_tmsi() const
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
const fixed_bitstring<27, false, true>& init_ue_msg_ies_o::value_c::csg_id() const
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
const gummei_s& init_ue_msg_ies_o::value_c::gummei_id() const
{
  assert_choice_type(types::gummei_id, type_, "Value");
  return c.get<gummei_s>();
}
const cell_access_mode_e& init_ue_msg_ies_o::value_c::cell_access_mode() const
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
const bounded_bitstring<1, 160, true, true>& init_ue_msg_ies_o::value_c::gw_transport_layer_address() const
{
  assert_choice_type(types::gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
const relay_node_ind_e& init_ue_msg_ies_o::value_c::relay_node_ind() const
{
  assert_choice_type(types::relay_node_ind, type_, "Value");
  return c.get<relay_node_ind_e>();
}
const gummei_type_e& init_ue_msg_ies_o::value_c::gummei_type() const
{
  assert_choice_type(types::gummei_type, type_, "Value");
  return c.get<gummei_type_e>();
}
const tunnel_info_s& init_ue_msg_ies_o::value_c::tunnel_info_for_bbf() const
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
const bounded_bitstring<1, 160, true, true>& init_ue_msg_ies_o::value_c::sipto_l_gw_transport_layer_address() const
{
  assert_choice_type(types::sipto_l_gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
const bounded_octstring<32, 256, true>& init_ue_msg_ies_o::value_c::lhn_id() const
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
const fixed_octstring<2, true>& init_ue_msg_ies_o::value_c::mme_group_id() const
{
  assert_choice_type(types::mme_group_id, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
const uint16_t& init_ue_msg_ies_o::value_c::ue_usage_type() const
{
  assert_choice_type(types::ue_usage_type, type_, "Value");
  return c.get<uint16_t>();
}
const ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const uint32_t& init_ue_msg_ies_o::value_c::dcn_id() const
{
  assert_choice_type(types::dcn_id, type_, "Value");
  return c.get<uint32_t>();
}
const coverage_level_e& init_ue_msg_ies_o::value_c::coverage_level() const
{
  assert_choice_type(types::coverage_level, type_, "Value");
  return c.get<coverage_level_e>();
}
const fixed_bitstring<8, false, true>& init_ue_msg_ies_o::value_c::ue_application_layer_meas_cap() const
{
  assert_choice_type(types::ue_application_layer_meas_cap, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
const edt_session_e& init_ue_msg_ies_o::value_c::edt_session() const
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
void init_ue_msg_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::rrc_establishment_cause:
      j.write_str("RRC-Establishment-Cause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::s_tmsi:
      j.write_fieldname("S-TMSI");
      c.get<s_tmsi_s>().to_json(j);
      break;
    case types::csg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<27, false, true> >().to_string());
      break;
    case types::gummei_id:
      j.write_fieldname("GUMMEI");
      c.get<gummei_s>().to_json(j);
      break;
    case types::cell_access_mode:
      j.write_str("CellAccessMode", "hybrid");
      break;
    case types::gw_transport_layer_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true> >().to_string());
      break;
    case types::relay_node_ind:
      j.write_str("RelayNode-Indicator", "true");
      break;
    case types::gummei_type:
      j.write_str("GUMMEIType", c.get<gummei_type_e>().to_string());
      break;
    case types::tunnel_info_for_bbf:
      j.write_fieldname("TunnelInformation");
      c.get<tunnel_info_s>().to_json(j);
      break;
    case types::sipto_l_gw_transport_layer_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true> >().to_string());
      break;
    case types::lhn_id:
      j.write_str("OCTET STRING", c.get<bounded_octstring<32, 256, true> >().to_string());
      break;
    case types::mme_group_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true> >().to_string());
      break;
    case types::ue_usage_type:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CE-mode-B-SupportIndicator", "supported");
      break;
    case types::dcn_id:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::coverage_level:
      j.write_str("Coverage-Level", "extendedcoverage");
      break;
    case types::ue_application_layer_meas_cap:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true> >().to_string());
      break;
    case types::edt_session:
      j.write_str("EDT-Session", "true");
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_ue_msg_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().pack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().pack(bref)));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().pack(bref));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().pack(bref));
      break;
    case types::gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().pack(bref)));
      break;
    case types::relay_node_ind:
      HANDLE_CODE(c.get<relay_node_ind_e>().pack(bref));
      break;
    case types::gummei_type:
      HANDLE_CODE(c.get<gummei_type_e>().pack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().pack(bref));
      break;
    case types::sipto_l_gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().pack(bref)));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().pack(bref)));
      break;
    case types::mme_group_id:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().pack(bref)));
      break;
    case types::ue_usage_type:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    case types::dcn_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::coverage_level:
      HANDLE_CODE(c.get<coverage_level_e>().pack(bref));
      break;
    case types::ue_application_layer_meas_cap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().pack(bref)));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().unpack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().unpack(bref)));
      break;
    case types::gummei_id:
      HANDLE_CODE(c.get<gummei_s>().unpack(bref));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().unpack(bref));
      break;
    case types::gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().unpack(bref)));
      break;
    case types::relay_node_ind:
      HANDLE_CODE(c.get<relay_node_ind_e>().unpack(bref));
      break;
    case types::gummei_type:
      HANDLE_CODE(c.get<gummei_type_e>().unpack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().unpack(bref));
      break;
    case types::sipto_l_gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().unpack(bref)));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().unpack(bref)));
      break;
    case types::mme_group_id:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().unpack(bref)));
      break;
    case types::ue_usage_type:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    case types::dcn_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::coverage_level:
      HANDLE_CODE(c.get<coverage_level_e>().unpack(bref));
      break;
    case types::ue_application_layer_meas_cap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().unpack(bref)));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_ue_msg_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "TAI",
                                  "EUTRAN-CGI",
                                  "RRC-Establishment-Cause",
                                  "S-TMSI",
                                  "BIT STRING",
                                  "GUMMEI",
                                  "CellAccessMode",
                                  "BIT STRING",
                                  "RelayNode-Indicator",
                                  "GUMMEIType",
                                  "TunnelInformation",
                                  "BIT STRING",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "INTEGER (0..255)",
                                  "CE-mode-B-SupportIndicator",
                                  "INTEGER (0..65535)",
                                  "Coverage-Level",
                                  "BIT STRING",
                                  "EDT-Session"};
  return convert_enum_idx(options, 22, value, "init_ue_msg_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<init_ue_msg_ies_o>;

init_ue_msg_ies_container::init_ue_msg_ies_container() :
  enb_ue_s1ap_id(8, crit_e::reject),
  nas_pdu(26, crit_e::reject),
  tai(67, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  rrc_establishment_cause(134, crit_e::ignore),
  s_tmsi(96, crit_e::reject),
  csg_id(127, crit_e::reject),
  gummei_id(75, crit_e::reject),
  cell_access_mode(145, crit_e::reject),
  gw_transport_layer_address(155, crit_e::ignore),
  relay_node_ind(160, crit_e::reject),
  gummei_type(170, crit_e::ignore),
  tunnel_info_for_bbf(176, crit_e::ignore),
  sipto_l_gw_transport_layer_address(184, crit_e::ignore),
  lhn_id(186, crit_e::ignore),
  mme_group_id(223, crit_e::ignore),
  ue_usage_type(230, crit_e::ignore),
  ce_mode_b_support_ind(242, crit_e::ignore),
  dcn_id(246, crit_e::ignore),
  coverage_level(250, crit_e::ignore),
  ue_application_layer_meas_cap(263, crit_e::ignore),
  edt_session(281, crit_e::ignore)
{}
SRSASN_CODE init_ue_msg_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += s_tmsi_present ? 1 : 0;
  nof_ies += csg_id_present ? 1 : 0;
  nof_ies += gummei_id_present ? 1 : 0;
  nof_ies += cell_access_mode_present ? 1 : 0;
  nof_ies += gw_transport_layer_address_present ? 1 : 0;
  nof_ies += relay_node_ind_present ? 1 : 0;
  nof_ies += gummei_type_present ? 1 : 0;
  nof_ies += tunnel_info_for_bbf_present ? 1 : 0;
  nof_ies += sipto_l_gw_transport_layer_address_present ? 1 : 0;
  nof_ies += lhn_id_present ? 1 : 0;
  nof_ies += mme_group_id_present ? 1 : 0;
  nof_ies += ue_usage_type_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  nof_ies += dcn_id_present ? 1 : 0;
  nof_ies += coverage_level_present ? 1 : 0;
  nof_ies += ue_application_layer_meas_cap_present ? 1 : 0;
  nof_ies += edt_session_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(rrc_establishment_cause.pack(bref));
  if (s_tmsi_present) {
    HANDLE_CODE(s_tmsi.pack(bref));
  }
  if (csg_id_present) {
    HANDLE_CODE(csg_id.pack(bref));
  }
  if (gummei_id_present) {
    HANDLE_CODE(gummei_id.pack(bref));
  }
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.pack(bref));
  }
  if (gw_transport_layer_address_present) {
    HANDLE_CODE(gw_transport_layer_address.pack(bref));
  }
  if (relay_node_ind_present) {
    HANDLE_CODE(relay_node_ind.pack(bref));
  }
  if (gummei_type_present) {
    HANDLE_CODE(gummei_type.pack(bref));
  }
  if (tunnel_info_for_bbf_present) {
    HANDLE_CODE(tunnel_info_for_bbf.pack(bref));
  }
  if (sipto_l_gw_transport_layer_address_present) {
    HANDLE_CODE(sipto_l_gw_transport_layer_address.pack(bref));
  }
  if (lhn_id_present) {
    HANDLE_CODE(lhn_id.pack(bref));
  }
  if (mme_group_id_present) {
    HANDLE_CODE(mme_group_id.pack(bref));
  }
  if (ue_usage_type_present) {
    HANDLE_CODE(ue_usage_type.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }
  if (dcn_id_present) {
    HANDLE_CODE(dcn_id.pack(bref));
  }
  if (coverage_level_present) {
    HANDLE_CODE(coverage_level.pack(bref));
  }
  if (ue_application_layer_meas_cap_present) {
    HANDLE_CODE(ue_application_layer_meas_cap.pack(bref));
  }
  if (edt_session_present) {
    HANDLE_CODE(edt_session.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<init_ue_msg_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 26:
        nof_mandatory_ies--;
        nas_pdu.id    = c.id;
        nas_pdu.crit  = c.crit;
        nas_pdu.value = c.value.nas_pdu();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 134:
        nof_mandatory_ies--;
        rrc_establishment_cause.id    = c.id;
        rrc_establishment_cause.crit  = c.crit;
        rrc_establishment_cause.value = c.value.rrc_establishment_cause();
        break;
      case 96:
        s_tmsi_present = true;
        s_tmsi.id      = c.id;
        s_tmsi.crit    = c.crit;
        s_tmsi.value   = c.value.s_tmsi();
        break;
      case 127:
        csg_id_present = true;
        csg_id.id      = c.id;
        csg_id.crit    = c.crit;
        csg_id.value   = c.value.csg_id();
        break;
      case 75:
        gummei_id_present = true;
        gummei_id.id      = c.id;
        gummei_id.crit    = c.crit;
        gummei_id.value   = c.value.gummei_id();
        break;
      case 145:
        cell_access_mode_present = true;
        cell_access_mode.id      = c.id;
        cell_access_mode.crit    = c.crit;
        cell_access_mode.value   = c.value.cell_access_mode();
        break;
      case 155:
        gw_transport_layer_address_present = true;
        gw_transport_layer_address.id      = c.id;
        gw_transport_layer_address.crit    = c.crit;
        gw_transport_layer_address.value   = c.value.gw_transport_layer_address();
        break;
      case 160:
        relay_node_ind_present = true;
        relay_node_ind.id      = c.id;
        relay_node_ind.crit    = c.crit;
        relay_node_ind.value   = c.value.relay_node_ind();
        break;
      case 170:
        gummei_type_present = true;
        gummei_type.id      = c.id;
        gummei_type.crit    = c.crit;
        gummei_type.value   = c.value.gummei_type();
        break;
      case 176:
        tunnel_info_for_bbf_present = true;
        tunnel_info_for_bbf.id      = c.id;
        tunnel_info_for_bbf.crit    = c.crit;
        tunnel_info_for_bbf.value   = c.value.tunnel_info_for_bbf();
        break;
      case 184:
        sipto_l_gw_transport_layer_address_present = true;
        sipto_l_gw_transport_layer_address.id      = c.id;
        sipto_l_gw_transport_layer_address.crit    = c.crit;
        sipto_l_gw_transport_layer_address.value   = c.value.sipto_l_gw_transport_layer_address();
        break;
      case 186:
        lhn_id_present = true;
        lhn_id.id      = c.id;
        lhn_id.crit    = c.crit;
        lhn_id.value   = c.value.lhn_id();
        break;
      case 223:
        mme_group_id_present = true;
        mme_group_id.id      = c.id;
        mme_group_id.crit    = c.crit;
        mme_group_id.value   = c.value.mme_group_id();
        break;
      case 230:
        ue_usage_type_present = true;
        ue_usage_type.id      = c.id;
        ue_usage_type.crit    = c.crit;
        ue_usage_type.value   = c.value.ue_usage_type();
        break;
      case 242:
        ce_mode_b_support_ind_present = true;
        ce_mode_b_support_ind.id      = c.id;
        ce_mode_b_support_ind.crit    = c.crit;
        ce_mode_b_support_ind.value   = c.value.ce_mode_b_support_ind();
        break;
      case 246:
        dcn_id_present = true;
        dcn_id.id      = c.id;
        dcn_id.crit    = c.crit;
        dcn_id.value   = c.value.dcn_id();
        break;
      case 250:
        coverage_level_present = true;
        coverage_level.id      = c.id;
        coverage_level.crit    = c.crit;
        coverage_level.value   = c.value.coverage_level();
        break;
      case 263:
        ue_application_layer_meas_cap_present = true;
        ue_application_layer_meas_cap.id      = c.id;
        ue_application_layer_meas_cap.crit    = c.crit;
        ue_application_layer_meas_cap.value   = c.value.ue_application_layer_meas_cap();
        break;
      case 281:
        edt_session_present = true;
        edt_session.id      = c.id;
        edt_session.crit    = c.crit;
        edt_session.value   = c.value.edt_session();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_ue_msg_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  rrc_establishment_cause.to_json(j);
  if (s_tmsi_present) {
    j.write_fieldname("");
    s_tmsi.to_json(j);
  }
  if (csg_id_present) {
    j.write_fieldname("");
    csg_id.to_json(j);
  }
  if (gummei_id_present) {
    j.write_fieldname("");
    gummei_id.to_json(j);
  }
  if (cell_access_mode_present) {
    j.write_fieldname("");
    cell_access_mode.to_json(j);
  }
  if (gw_transport_layer_address_present) {
    j.write_fieldname("");
    gw_transport_layer_address.to_json(j);
  }
  if (relay_node_ind_present) {
    j.write_fieldname("");
    relay_node_ind.to_json(j);
  }
  if (gummei_type_present) {
    j.write_fieldname("");
    gummei_type.to_json(j);
  }
  if (tunnel_info_for_bbf_present) {
    j.write_fieldname("");
    tunnel_info_for_bbf.to_json(j);
  }
  if (sipto_l_gw_transport_layer_address_present) {
    j.write_fieldname("");
    sipto_l_gw_transport_layer_address.to_json(j);
  }
  if (lhn_id_present) {
    j.write_fieldname("");
    lhn_id.to_json(j);
  }
  if (mme_group_id_present) {
    j.write_fieldname("");
    mme_group_id.to_json(j);
  }
  if (ue_usage_type_present) {
    j.write_fieldname("");
    ue_usage_type.to_json(j);
  }
  if (ce_mode_b_support_ind_present) {
    j.write_fieldname("");
    ce_mode_b_support_ind.to_json(j);
  }
  if (dcn_id_present) {
    j.write_fieldname("");
    dcn_id.to_json(j);
  }
  if (coverage_level_present) {
    j.write_fieldname("");
    coverage_level.to_json(j);
  }
  if (ue_application_layer_meas_cap_present) {
    j.write_fieldname("");
    ue_application_layer_meas_cap.to_json(j);
  }
  if (edt_session_present) {
    j.write_fieldname("");
    edt_session.to_json(j);
  }
  j.end_obj();
}

// InitialUEMessage ::= SEQUENCE
SRSASN_CODE init_ue_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void init_ue_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("InitialUEMessage");
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

// UE-associatedLogicalS1-ConnectionItem ::= SEQUENCE
SRSASN_CODE ue_associated_lc_s1_conn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mme_ue_s1ap_id_present, 1));
  HANDLE_CODE(bref.pack(enb_ue_s1ap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mme_ue_s1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, mme_ue_s1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (enb_ue_s1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, enb_ue_s1ap_id, (uint32_t)0u, (uint32_t)16777215u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_s1_conn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mme_ue_s1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(enb_ue_s1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mme_ue_s1ap_id_present) {
    HANDLE_CODE(unpack_integer(mme_ue_s1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (enb_ue_s1ap_id_present) {
    HANDLE_CODE(unpack_integer(enb_ue_s1ap_id, bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_associated_lc_s1_conn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mme_ue_s1ap_id_present) {
    j.write_int("mME-UE-S1AP-ID", mme_ue_s1ap_id);
  }
  if (enb_ue_s1ap_id_present) {
    j.write_int("eNB-UE-S1AP-ID", enb_ue_s1ap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedGUMMEIsItem-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t served_gummeis_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {170};
  return map_enum_number(options, 1, idx, "id");
}
bool served_gummeis_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 170 == id;
}
crit_e served_gummeis_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 170) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
served_gummeis_item_ext_ies_o::ext_c served_gummeis_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 170) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e served_gummeis_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 170) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_gummeis_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("GUMMEIType", c.to_string());
  j.end_obj();
}
SRSASN_CODE served_gummeis_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_gummeis_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* served_gummeis_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"GUMMEIType"};
  return convert_enum_idx(options, 1, value, "served_gummeis_item_ext_ies_o::ext_c::types");
}

// TAIItem ::= SEQUENCE
SRSASN_CODE tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-associatedLogicalS1-ConnectionItemRes ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_associated_lc_s1_conn_item_res_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {91};
  return map_enum_number(options, 1, idx, "id");
}
bool ue_associated_lc_s1_conn_item_res_o::is_id_valid(const uint32_t& id)
{
  return 91 == id;
}
crit_e ue_associated_lc_s1_conn_item_res_o::get_crit(const uint32_t& id)
{
  if (id == 91) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
ue_associated_lc_s1_conn_item_res_o::value_c ue_associated_lc_s1_conn_item_res_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 91) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_associated_lc_s1_conn_item_res_o::get_presence(const uint32_t& id)
{
  if (id == 91) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_associated_lc_s1_conn_item_res_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UE-associatedLogicalS1-ConnectionItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ue_associated_lc_s1_conn_item_res_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_s1_conn_item_res_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_associated_lc_s1_conn_item_res_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"UE-associatedLogicalS1-ConnectionItem"};
  return convert_enum_idx(options, 1, value, "ue_associated_lc_s1_conn_item_res_o::value_c::types");
}
uint8_t ue_associated_lc_s1_conn_item_res_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {1};
  return map_enum_number(options, 1, value, "ue_associated_lc_s1_conn_item_res_o::value_c::types");
}

// NB-IoT-Paging-eDRX-Cycle ::= ENUMERATED
const char* nb_io_t_paging_e_drx_cycle_opts::to_string() const
{
  static const char* options[] = {
      "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(options, 14, value, "nb_io_t_paging_e_drx_cycle_e");
}
uint16_t nb_io_t_paging_e_drx_cycle_opts::to_number() const
{
  static const uint16_t options[] = {2, 4, 6, 8, 10, 12, 14, 16, 32, 64, 128, 256, 512, 1024};
  return map_enum_number(options, 14, value, "nb_io_t_paging_e_drx_cycle_e");
}

// NB-IoT-PagingTimeWindow ::= ENUMERATED
const char* nb_io_t_paging_time_win_opts::to_string() const
{
  static const char* options[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(options, 16, value, "nb_io_t_paging_time_win_e");
}
uint8_t nb_io_t_paging_time_win_opts::to_number() const
{
  static const uint8_t options[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(options, 16, value, "nb_io_t_paging_time_win_e");
}

// OverloadAction ::= ENUMERATED
const char* overload_action_opts::to_string() const
{
  static const char* options[] = {
      "reject-non-emergency-mo-dt",
      "reject-rrc-cr-signalling",
      "permit-emergency-sessions-and-mobile-terminated-services-only",
      "permit-high-priority-sessions-and-mobile-terminated-services-only",
      "reject-delay-tolerant-access",
      "permit-high-priority-sessions-and-exception-reporting-and-mobile-terminated-services-only",
      "not-accept-mo-data-or-delay-tolerant-access-from-CP-CIoT"};
  return convert_enum_idx(options, 7, value, "overload_action_e");
}

// Paging-eDRX-Cycle ::= ENUMERATED
const char* paging_e_drx_cycle_opts::to_string() const
{
  static const char* options[] = {
      "hfhalf", "hf1", "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256"};
  return convert_enum_idx(options, 14, value, "paging_e_drx_cycle_e");
}
float paging_e_drx_cycle_opts::to_number() const
{
  static const float options[] = {0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 32.0, 64.0, 128.0, 256.0};
  return map_enum_number(options, 14, value, "paging_e_drx_cycle_e");
}
const char* paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* options[] = {"0.5", "1", "2", "4", "6", "8", "10", "12", "14", "16", "32", "64", "128", "256"};
  return convert_enum_idx(options, 14, value, "paging_e_drx_cycle_e");
}

// PagingTimeWindow ::= ENUMERATED
const char* paging_time_win_opts::to_string() const
{
  static const char* options[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(options, 16, value, "paging_time_win_e");
}
uint8_t paging_time_win_opts::to_number() const
{
  static const uint8_t options[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(options, 16, value, "paging_time_win_e");
}

// ResetAll ::= ENUMERATED
const char* reset_all_opts::to_string() const
{
  static const char* options[] = {"reset-all"};
  return convert_enum_idx(options, 1, value, "reset_all_e");
}

// ServedDCNsItem ::= SEQUENCE
SRSASN_CODE served_dcns_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dcn_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(pack_integer(bref, relative_dcn_capacity, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_dcns_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dcn_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(unpack_integer(relative_dcn_capacity, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_dcns_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dCN-ID", dcn_id);
  j.write_int("relativeDCNCapacity", relative_dcn_capacity);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedGUMMEIsItem ::= SEQUENCE
SRSASN_CODE served_gummeis_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, served_plmns, 1, 32, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, served_group_ids, 1, 65535, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, served_mmecs, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_gummeis_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(served_plmns, bref, 1, 32, true));
  HANDLE_CODE(unpack_dyn_seq_of(served_group_ids, bref, 1, 65535, true));
  HANDLE_CODE(unpack_dyn_seq_of(served_mmecs, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_gummeis_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("servedPLMNs");
  for (const auto& e1 : served_plmns) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.start_array("servedGroupIDs");
  for (const auto& e1 : served_group_ids) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.start_array("servedMMECs");
  for (const auto& e1 : served_mmecs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// TAIItemIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t tai_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {47};
  return map_enum_number(options, 1, idx, "id");
}
bool tai_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 47 == id;
}
crit_e tai_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 47) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
tai_item_ies_o::value_c tai_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 47) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e tai_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 47) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void tai_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAIItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE tai_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* tai_item_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"TAIItem"};
  return convert_enum_idx(options, 1, value, "tai_item_ies_o::value_c::types");
}

// UE-S1AP-ID-pair ::= SEQUENCE
SRSASN_CODE ue_s1ap_id_pair_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mme_ue_s1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(pack_integer(bref, enb_ue_s1ap_id, (uint32_t)0u, (uint32_t)16777215u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_s1ap_id_pair_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mme_ue_s1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(unpack_integer(enb_ue_s1ap_id, bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_s1ap_id_pair_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mME-UE-S1AP-ID", mme_ue_s1ap_id);
  j.write_int("eNB-UE-S1AP-ID", enb_ue_s1ap_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-associatedLogicalS1-ConnectionItemResAck ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_associated_lc_s1_conn_item_res_ack_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {91};
  return map_enum_number(options, 1, idx, "id");
}
bool ue_associated_lc_s1_conn_item_res_ack_o::is_id_valid(const uint32_t& id)
{
  return 91 == id;
}
crit_e ue_associated_lc_s1_conn_item_res_ack_o::get_crit(const uint32_t& id)
{
  if (id == 91) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
ue_associated_lc_s1_conn_item_res_ack_o::value_c ue_associated_lc_s1_conn_item_res_ack_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 91) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_associated_lc_s1_conn_item_res_ack_o::get_presence(const uint32_t& id)
{
  if (id == 91) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_associated_lc_s1_conn_item_res_ack_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UE-associatedLogicalS1-ConnectionItem");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ue_associated_lc_s1_conn_item_res_ack_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_s1_conn_item_res_ack_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_associated_lc_s1_conn_item_res_ack_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"UE-associatedLogicalS1-ConnectionItem"};
  return convert_enum_idx(options, 1, value, "ue_associated_lc_s1_conn_item_res_ack_o::value_c::types");
}
uint8_t ue_associated_lc_s1_conn_item_res_ack_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {1};
  return map_enum_number(options, 1, value, "ue_associated_lc_s1_conn_item_res_ack_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<ue_associated_lc_s1_conn_item_res_o>;

// CNDomain ::= ENUMERATED
const char* cn_domain_opts::to_string() const
{
  static const char* options[] = {"ps", "cs"};
  return convert_enum_idx(options, 2, value, "cn_domain_e");
}

// Cdma2000HORequiredIndication ::= ENUMERATED
const char* cdma2000_ho_required_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "cdma2000_ho_required_ind_e");
}

// ConcurrentWarningMessageIndicator ::= ENUMERATED
const char* concurrent_warning_msg_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "concurrent_warning_msg_ind_e");
}

// GWContextReleaseIndication ::= ENUMERATED
const char* gw_context_release_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "gw_context_release_ind_e");
}

// HandoverFlag ::= ENUMERATED
const char* ho_flag_opts::to_string() const
{
  static const char* options[] = {"handoverPreparation"};
  return convert_enum_idx(options, 1, value, "ho_flag_e");
}

// KillAllWarningMessages ::= ENUMERATED
const char* kill_all_warning_msgs_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "kill_all_warning_msgs_e");
}

// LTE-M-Indication ::= ENUMERATED
const char* lte_m_ind_opts::to_string() const
{
  static const char* options[] = {"lte-m"};
  return convert_enum_idx(options, 1, value, "lte_m_ind_e");
}

// MMERelaySupportIndicator ::= ENUMERATED
const char* mme_relay_support_ind_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "mme_relay_support_ind_e");
}

// NB-IoT-Paging-eDRXInformation ::= SEQUENCE
SRSASN_CODE nb_io_t_paging_e_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nb_io_t_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nb_io_t_paging_e_drx_cycle.pack(bref));
  if (nb_io_t_paging_time_win_present) {
    HANDLE_CODE(nb_io_t_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nb_io_t_paging_e_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nb_io_t_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nb_io_t_paging_e_drx_cycle.unpack(bref));
  if (nb_io_t_paging_time_win_present) {
    HANDLE_CODE(nb_io_t_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nb_io_t_paging_e_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nB-IoT-paging-eDRX-Cycle", nb_io_t_paging_e_drx_cycle.to_string());
  if (nb_io_t_paging_time_win_present) {
    j.write_str("nB-IoT-pagingTimeWindow", nb_io_t_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OverloadResponse ::= CHOICE
void overload_resp_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("overloadAction", c.to_string());
  j.end_obj();
}
SRSASN_CODE overload_resp_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_resp_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "overload_resp_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* overload_resp_c::types_opts::to_string() const
{
  static const char* options[] = {"overloadAction"};
  return convert_enum_idx(options, 1, value, "overload_resp_c::types");
}

// Paging-eDRXInformation ::= SEQUENCE
SRSASN_CODE paging_e_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(paging_e_drx_cycle.pack(bref));
  if (paging_time_win_present) {
    HANDLE_CODE(paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_e_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(paging_e_drx_cycle.unpack(bref));
  if (paging_time_win_present) {
    HANDLE_CODE(paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_e_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("paging-eDRX-Cycle", paging_e_drx_cycle.to_string());
  if (paging_time_win_present) {
    j.write_str("pagingTimeWindow", paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingPriority ::= ENUMERATED
const char* paging_prio_opts::to_string() const
{
  static const char* options[] = {
      "priolevel1", "priolevel2", "priolevel3", "priolevel4", "priolevel5", "priolevel6", "priolevel7", "priolevel8"};
  return convert_enum_idx(options, 8, value, "paging_prio_e");
}
uint8_t paging_prio_opts::to_number() const
{
  static const uint8_t options[] = {1, 2, 3, 4, 5, 6, 7, 8};
  return map_enum_number(options, 8, value, "paging_prio_e");
}

// ResetType ::= CHOICE
void reset_type_c::destroy_()
{
  switch (type_) {
    case types::part_of_s1_interface:
      c.destroy<ue_associated_lc_s1_conn_list_res_l>();
      break;
    default:
      break;
  }
}
void reset_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s1_interface:
      break;
    case types::part_of_s1_interface:
      c.init<ue_associated_lc_s1_conn_list_res_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c::reset_type_c(const reset_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s1_interface:
      c.init(other.c.get<reset_all_e>());
      break;
    case types::part_of_s1_interface:
      c.init(other.c.get<ue_associated_lc_s1_conn_list_res_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c& reset_type_c::operator=(const reset_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s1_interface:
      c.set(other.c.get<reset_all_e>());
      break;
    case types::part_of_s1_interface:
      c.set(other.c.get<ue_associated_lc_s1_conn_list_res_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }

  return *this;
}
reset_all_e& reset_type_c::set_s1_interface()
{
  set(types::s1_interface);
  return c.get<reset_all_e>();
}
ue_associated_lc_s1_conn_list_res_l& reset_type_c::set_part_of_s1_interface()
{
  set(types::part_of_s1_interface);
  return c.get<ue_associated_lc_s1_conn_list_res_l>();
}
void reset_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s1_interface:
      j.write_str("s1-Interface", "reset-all");
      break;
    case types::part_of_s1_interface:
      j.start_array("partOfS1-Interface");
      for (const auto& e1 : c.get<ue_associated_lc_s1_conn_list_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::s1_interface:
      HANDLE_CODE(c.get<reset_all_e>().pack(bref));
      break;
    case types::part_of_s1_interface:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_s1_conn_list_res_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::s1_interface:
      HANDLE_CODE(c.get<reset_all_e>().unpack(bref));
      break;
    case types::part_of_s1_interface:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_s1_conn_list_res_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_type_c::types_opts::to_string() const
{
  static const char* options[] = {"s1-Interface", "partOfS1-Interface"};
  return convert_enum_idx(options, 2, value, "reset_type_c::types");
}

// SRVCCOperationNotPossible ::= ENUMERATED
const char* srvcc_operation_not_possible_opts::to_string() const
{
  static const char* options[] = {"notPossible"};
  return convert_enum_idx(options, 1, value, "srvcc_operation_not_possible_e");
}

template struct asn1::s1ap::protocol_ie_single_container_s<tai_item_ies_o>;

// UE-RetentionInformation ::= ENUMERATED
const char* ue_retention_info_opts::to_string() const
{
  static const char* options[] = {"ues-retained"};
  return convert_enum_idx(options, 1, value, "ue_retention_info_e");
}

// UE-S1AP-IDs ::= CHOICE
void ue_s1ap_ids_c::destroy_()
{
  switch (type_) {
    case types::ue_s1ap_id_pair:
      c.destroy<ue_s1ap_id_pair_s>();
      break;
    default:
      break;
  }
}
void ue_s1ap_ids_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_s1ap_id_pair:
      c.init<ue_s1ap_id_pair_s>();
      break;
    case types::mme_ue_s1ap_id:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
  }
}
ue_s1ap_ids_c::ue_s1ap_ids_c(const ue_s1ap_ids_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_s1ap_id_pair:
      c.init(other.c.get<ue_s1ap_id_pair_s>());
      break;
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
  }
}
ue_s1ap_ids_c& ue_s1ap_ids_c::operator=(const ue_s1ap_ids_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_s1ap_id_pair:
      c.set(other.c.get<ue_s1ap_id_pair_s>());
      break;
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
  }

  return *this;
}
ue_s1ap_id_pair_s& ue_s1ap_ids_c::set_ue_s1ap_id_pair()
{
  set(types::ue_s1ap_id_pair);
  return c.get<ue_s1ap_id_pair_s>();
}
uint64_t& ue_s1ap_ids_c::set_mme_ue_s1ap_id()
{
  set(types::mme_ue_s1ap_id);
  return c.get<uint64_t>();
}
void ue_s1ap_ids_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_s1ap_id_pair:
      j.write_fieldname("uE-S1AP-ID-pair");
      c.get<ue_s1ap_id_pair_s>().to_json(j);
      break;
    case types::mme_ue_s1ap_id:
      j.write_int("mME-UE-S1AP-ID", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_s1ap_ids_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ue_s1ap_id_pair:
      HANDLE_CODE(c.get<ue_s1ap_id_pair_s>().pack(bref));
      break;
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_s1ap_ids_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ue_s1ap_id_pair:
      HANDLE_CODE(c.get<ue_s1ap_id_pair_s>().unpack(bref));
      break;
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_s1ap_ids_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_s1ap_ids_c::types_opts::to_string() const
{
  static const char* options[] = {"uE-S1AP-ID-pair", "mME-UE-S1AP-ID"};
  return convert_enum_idx(options, 2, value, "ue_s1ap_ids_c::types");
}

template struct asn1::s1ap::protocol_ie_single_container_s<ue_associated_lc_s1_conn_item_res_ack_o>;

// UEPagingID ::= CHOICE
void ue_paging_id_c::destroy_()
{
  switch (type_) {
    case types::s_tmsi:
      c.destroy<s_tmsi_s>();
      break;
    case types::imsi:
      c.destroy<bounded_octstring<3, 8, true> >();
      break;
    default:
      break;
  }
}
void ue_paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_tmsi:
      c.init<s_tmsi_s>();
      break;
    case types::imsi:
      c.init<bounded_octstring<3, 8, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c::ue_paging_id_c(const ue_paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_tmsi:
      c.init(other.c.get<s_tmsi_s>());
      break;
    case types::imsi:
      c.init(other.c.get<bounded_octstring<3, 8, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c& ue_paging_id_c::operator=(const ue_paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_tmsi:
      c.set(other.c.get<s_tmsi_s>());
      break;
    case types::imsi:
      c.set(other.c.get<bounded_octstring<3, 8, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }

  return *this;
}
s_tmsi_s& ue_paging_id_c::set_s_tmsi()
{
  set(types::s_tmsi);
  return c.get<s_tmsi_s>();
}
bounded_octstring<3, 8, true>& ue_paging_id_c::set_imsi()
{
  set(types::imsi);
  return c.get<bounded_octstring<3, 8, true> >();
}
void ue_paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_tmsi:
      j.write_fieldname("s-TMSI");
      c.get<s_tmsi_s>().to_json(j);
      break;
    case types::imsi:
      j.write_str("iMSI", c.get<bounded_octstring<3, 8, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().pack(bref));
      break;
    case types::imsi:
      HANDLE_CODE((c.get<bounded_octstring<3, 8, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().unpack(bref));
      break;
    case types::imsi:
      HANDLE_CODE((c.get<bounded_octstring<3, 8, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_paging_id_c::types_opts::to_string() const
{
  static const char* options[] = {"s-TMSI", "iMSI"};
  return convert_enum_idx(options, 2, value, "ue_paging_id_c::types");
}

// VoiceSupportMatchIndicator ::= ENUMERATED
const char* voice_support_match_ind_opts::to_string() const
{
  static const char* options[] = {"supported", "not-supported"};
  return convert_enum_idx(options, 2, value, "voice_support_match_ind_e");
}

// WarningAreaList ::= CHOICE
void warning_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_list:
      c.destroy<ecgi_list_l>();
      break;
    case types::tracking_area_listfor_warning:
      c.destroy<tai_listfor_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.destroy<emergency_area_id_list_l>();
      break;
    default:
      break;
  }
}
void warning_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_list:
      c.init<ecgi_list_l>();
      break;
    case types::tracking_area_listfor_warning:
      c.init<tai_listfor_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.init<emergency_area_id_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c::warning_area_list_c(const warning_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_list:
      c.init(other.c.get<ecgi_list_l>());
      break;
    case types::tracking_area_listfor_warning:
      c.init(other.c.get<tai_listfor_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.init(other.c.get<emergency_area_id_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c& warning_area_list_c::operator=(const warning_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_list:
      c.set(other.c.get<ecgi_list_l>());
      break;
    case types::tracking_area_listfor_warning:
      c.set(other.c.get<tai_listfor_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.set(other.c.get<emergency_area_id_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }

  return *this;
}
ecgi_list_l& warning_area_list_c::set_cell_id_list()
{
  set(types::cell_id_list);
  return c.get<ecgi_list_l>();
}
tai_listfor_warning_l& warning_area_list_c::set_tracking_area_listfor_warning()
{
  set(types::tracking_area_listfor_warning);
  return c.get<tai_listfor_warning_l>();
}
emergency_area_id_list_l& warning_area_list_c::set_emergency_area_id_list()
{
  set(types::emergency_area_id_list);
  return c.get<emergency_area_id_list_l>();
}
void warning_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_list:
      j.start_array("cellIDList");
      for (const auto& e1 : c.get<ecgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tracking_area_listfor_warning:
      j.start_array("trackingAreaListforWarning");
      for (const auto& e1 : c.get<tai_listfor_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list:
      j.start_array("emergencyAreaIDList");
      for (const auto& e1 : c.get<emergency_area_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE warning_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ecgi_list_l>(), 1, 256, true));
      break;
    case types::tracking_area_listfor_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_listfor_warning_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_l>(), 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE warning_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ecgi_list_l>(), bref, 1, 256, true));
      break;
    case types::tracking_area_listfor_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_listfor_warning_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_l>(), bref, 1, 65535, true));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* warning_area_list_c::types_opts::to_string() const
{
  static const char* options[] = {"cellIDList", "trackingAreaListforWarning", "emergencyAreaIDList"};
  return convert_enum_idx(options, 3, value, "warning_area_list_c::types");
}

// KillRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t kill_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {111, 112, 113, 191};
  return map_enum_number(options, 4, idx, "id");
}
bool kill_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {111, 112, 113, 191};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e kill_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::reject;
    case 112:
      return crit_e::reject;
    case 113:
      return crit_e::ignore;
    case 191:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
kill_request_ies_o::value_c kill_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::msg_id);
      break;
    case 112:
      ret.set(value_c::types::serial_num);
      break;
    case 113:
      ret.set(value_c::types::warning_area_list);
      break;
    case 191:
      ret.set(value_c::types::kill_all_warning_msgs);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e kill_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::mandatory;
    case 112:
      return presence_e::mandatory;
    case 113:
      return presence_e::optional;
    case 191:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void kill_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    default:
      break;
  }
}
void kill_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::kill_all_warning_msgs:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
  }
}
kill_request_ies_o::value_c::value_c(const kill_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::kill_all_warning_msgs:
      c.init(other.c.get<kill_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
  }
}
kill_request_ies_o::value_c& kill_request_ies_o::value_c::operator=(const kill_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::kill_all_warning_msgs:
      c.set(other.c.get<kill_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& kill_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
fixed_bitstring<16, false, true>& kill_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
warning_area_list_c& kill_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
kill_all_warning_msgs_e& kill_request_ies_o::value_c::kill_all_warning_msgs()
{
  assert_choice_type(types::kill_all_warning_msgs, type_, "Value");
  return c.get<kill_all_warning_msgs_e>();
}
const fixed_bitstring<16, false, true>& kill_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const fixed_bitstring<16, false, true>& kill_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const warning_area_list_c& kill_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const kill_all_warning_msgs_e& kill_request_ies_o::value_c::kill_all_warning_msgs() const
{
  assert_choice_type(types::kill_all_warning_msgs, type_, "Value");
  return c.get<kill_all_warning_msgs_e>();
}
void kill_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::kill_all_warning_msgs:
      j.write_str("KillAllWarningMessages", "true");
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE kill_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::kill_all_warning_msgs:
      HANDLE_CODE(c.get<kill_all_warning_msgs_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::kill_all_warning_msgs:
      HANDLE_CODE(c.get<kill_all_warning_msgs_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "kill_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* kill_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"BIT STRING", "BIT STRING", "WarningAreaList", "KillAllWarningMessages"};
  return convert_enum_idx(options, 4, value, "kill_request_ies_o::value_c::types");
}

// KillResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t kill_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {111, 112, 141, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool kill_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {111, 112, 141, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e kill_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::reject;
    case 112:
      return crit_e::reject;
    case 141:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
kill_resp_ies_o::value_c kill_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::msg_id);
      break;
    case 112:
      ret.set(value_c::types::serial_num);
      break;
    case 141:
      ret.set(value_c::types::broadcast_cancelled_area_list);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e kill_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::mandatory;
    case 112:
      return presence_e::mandatory;
    case 141:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void kill_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::broadcast_cancelled_area_list:
      c.destroy<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void kill_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::broadcast_cancelled_area_list:
      c.init<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
  }
}
kill_resp_ies_o::value_c::value_c(const kill_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::broadcast_cancelled_area_list:
      c.init(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
  }
}
kill_resp_ies_o::value_c& kill_resp_ies_o::value_c::operator=(const kill_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::broadcast_cancelled_area_list:
      c.set(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& kill_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
fixed_bitstring<16, false, true>& kill_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
broadcast_cancelled_area_list_c& kill_resp_ies_o::value_c::broadcast_cancelled_area_list()
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
crit_diagnostics_s& kill_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& kill_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const fixed_bitstring<16, false, true>& kill_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const broadcast_cancelled_area_list_c& kill_resp_ies_o::value_c::broadcast_cancelled_area_list() const
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
const crit_diagnostics_s& kill_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void kill_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::broadcast_cancelled_area_list:
      j.write_fieldname("BroadcastCancelledAreaList");
      c.get<broadcast_cancelled_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE kill_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "kill_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* kill_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"BIT STRING", "BIT STRING", "BroadcastCancelledAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "kill_resp_ies_o::value_c::types");
}

// LocationReportIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t location_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 100, 67, 98, 288};
  return map_enum_number(options, 6, idx, "id");
}
bool location_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 100, 67, 98, 288};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 67:
      return crit_e::ignore;
    case 98:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
location_report_ies_o::value_c location_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 98:
      ret.set(value_c::types::request_type);
      break;
    case 288:
      ret.set(value_c::types::ps_cell_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e location_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 98:
      return presence_e::mandatory;
    case 288:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::request_type:
      c.destroy<request_type_s>();
      break;
    case types::ps_cell_info:
      c.destroy<ps_cell_info_s>();
      break;
    default:
      break;
  }
}
void location_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::request_type:
      c.init<request_type_s>();
      break;
    case types::ps_cell_info:
      c.init<ps_cell_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c::value_c(const location_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::request_type:
      c.init(other.c.get<request_type_s>());
      break;
    case types::ps_cell_info:
      c.init(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c& location_report_ies_o::value_c::operator=(const location_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::request_type:
      c.set(other.c.get<request_type_s>());
      break;
    case types::ps_cell_info:
      c.set(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& location_report_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
eutran_cgi_s& location_report_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
tai_s& location_report_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
request_type_s& location_report_ies_o::value_c::request_type()
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
ps_cell_info_s& location_report_ies_o::value_c::ps_cell_info()
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
const uint64_t& location_report_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& location_report_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const eutran_cgi_s& location_report_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const tai_s& location_report_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const request_type_s& location_report_ies_o::value_c::request_type() const
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
const ps_cell_info_s& location_report_ies_o::value_c::ps_cell_info() const
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
void location_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::request_type:
      j.write_fieldname("RequestType");
      c.get<request_type_s>().to_json(j);
      break;
    case types::ps_cell_info:
      j.write_fieldname("PSCellInformation");
      c.get<ps_cell_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().pack(bref));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().unpack(bref));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "EUTRAN-CGI", "TAI", "RequestType", "PSCellInformation"};
  return convert_enum_idx(options, 6, value, "location_report_ies_o::value_c::types");
}

// LocationReportingControlIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t location_report_ctrl_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 98};
  return map_enum_number(options, 3, idx, "id");
}
bool location_report_ctrl_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 98};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ctrl_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 98:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
location_report_ctrl_ies_o::value_c location_report_ctrl_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 98:
      ret.set(value_c::types::request_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e location_report_ctrl_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 98:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ctrl_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::request_type:
      c.destroy<request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ctrl_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::request_type:
      c.init<request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c::value_c(const location_report_ctrl_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::request_type:
      c.init(other.c.get<request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c&
location_report_ctrl_ies_o::value_c::operator=(const location_report_ctrl_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::request_type:
      c.set(other.c.get<request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ctrl_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& location_report_ctrl_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
request_type_s& location_report_ctrl_ies_o::value_c::request_type()
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& location_report_ctrl_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const request_type_s& location_report_ctrl_ies_o::value_c::request_type() const
{
  assert_choice_type(types::request_type, type_, "Value");
  return c.get<request_type_s>();
}
void location_report_ctrl_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::request_type:
      j.write_fieldname("RequestType");
      c.get<request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::request_type:
      HANDLE_CODE(c.get<request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ctrl_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "RequestType"};
  return convert_enum_idx(options, 3, value, "location_report_ctrl_ies_o::value_c::types");
}

// LocationReportingFailureIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t location_report_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2};
  return map_enum_number(options, 3, idx, "id");
}
bool location_report_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
location_report_fail_ind_ies_o::value_c location_report_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e location_report_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void location_report_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c::value_c(const location_report_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c&
location_report_fail_ind_ies_o::value_c::operator=(const location_report_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_fail_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& location_report_fail_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& location_report_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& location_report_fail_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& location_report_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void location_report_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause"};
  return convert_enum_idx(options, 3, value, "location_report_fail_ind_ies_o::value_c::types");
}

// MMECPRelocationIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mmecp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8};
  return map_enum_number(options, 2, idx, "id");
}
bool mmecp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mmecp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
mmecp_relocation_ind_ies_o::value_c mmecp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mmecp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mmecp_relocation_ind_ies_o::value_c::destroy_() {}
void mmecp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
mmecp_relocation_ind_ies_o::value_c::value_c(const mmecp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mmecp_relocation_ind_ies_o::value_c");
  }
}
mmecp_relocation_ind_ies_o::value_c&
mmecp_relocation_ind_ies_o::value_c::operator=(const mmecp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mmecp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& mmecp_relocation_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& mmecp_relocation_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const uint64_t& mmecp_relocation_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& mmecp_relocation_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
void mmecp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "mmecp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mmecp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "mmecp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mmecp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "mmecp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mmecp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)"};
  return convert_enum_idx(options, 2, value, "mmecp_relocation_ind_ies_o::value_c::types");
}

// MMEConfigurationTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {130, 295};
  return map_enum_number(options, 2, idx, "id");
}
bool mme_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {130, 295};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mme_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 130:
      return crit_e::ignore;
    case 295:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
mme_cfg_transfer_ies_o::value_c mme_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 130:
      ret.set(value_c::types::son_cfg_transfer_mct);
      break;
    case 295:
      ret.set(value_c::types::en_dcson_cfg_transfer_mct);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 130:
      return presence_e::optional;
    case 295:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mme_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_mct:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::en_dcson_cfg_transfer_mct:
      c.destroy<en_dcson_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void mme_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_mct:
      c.init<son_cfg_transfer_s>();
      break;
    case types::en_dcson_cfg_transfer_mct:
      c.init<en_dcson_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
  }
}
mme_cfg_transfer_ies_o::value_c::value_c(const mme_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_mct:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::en_dcson_cfg_transfer_mct:
      c.init(other.c.get<en_dcson_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
  }
}
mme_cfg_transfer_ies_o::value_c&
mme_cfg_transfer_ies_o::value_c::operator=(const mme_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_mct:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::en_dcson_cfg_transfer_mct:
      c.set(other.c.get<en_dcson_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& mme_cfg_transfer_ies_o::value_c::son_cfg_transfer_mct()
{
  assert_choice_type(types::son_cfg_transfer_mct, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
en_dcson_cfg_transfer_s& mme_cfg_transfer_ies_o::value_c::en_dcson_cfg_transfer_mct()
{
  assert_choice_type(types::en_dcson_cfg_transfer_mct, type_, "Value");
  return c.get<en_dcson_cfg_transfer_s>();
}
const son_cfg_transfer_s& mme_cfg_transfer_ies_o::value_c::son_cfg_transfer_mct() const
{
  assert_choice_type(types::son_cfg_transfer_mct, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const en_dcson_cfg_transfer_s& mme_cfg_transfer_ies_o::value_c::en_dcson_cfg_transfer_mct() const
{
  assert_choice_type(types::en_dcson_cfg_transfer_mct, type_, "Value");
  return c.get<en_dcson_cfg_transfer_s>();
}
void mme_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_mct:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::en_dcson_cfg_transfer_mct:
      j.write_fieldname("EN-DCSONConfigurationTransfer");
      c.get<en_dcson_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mme_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_mct:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::en_dcson_cfg_transfer_mct:
      HANDLE_CODE(c.get<en_dcson_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_mct:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::en_dcson_cfg_transfer_mct:
      HANDLE_CODE(c.get<en_dcson_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mme_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"SONConfigurationTransfer", "EN-DCSONConfigurationTransfer"};
  return convert_enum_idx(options, 2, value, "mme_cfg_transfer_ies_o::value_c::types");
}

// MMEConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {58};
  return map_enum_number(options, 1, idx, "id");
}
bool mme_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 58 == id;
}
crit_e mme_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 58) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
mme_cfg_upd_ack_ies_o::value_c mme_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 58) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 58) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void mme_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE mme_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* mme_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"CriticalityDiagnostics"};
  return convert_enum_idx(options, 1, value, "mme_cfg_upd_ack_ies_o::value_c::types");
}

// MMEConfigurationUpdateFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {2, 65, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool mme_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {2, 65, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mme_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
mme_cfg_upd_fail_ies_o::value_c mme_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 65:
      ret.set(value_c::types::time_to_wait);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mme_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void mme_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
  }
}
mme_cfg_upd_fail_ies_o::value_c::value_c(const mme_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
  }
}
mme_cfg_upd_fail_ies_o::value_c&
mme_cfg_upd_fail_ies_o::value_c::operator=(const mme_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& mme_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& mme_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& mme_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& mme_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& mme_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& mme_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void mme_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mme_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mme_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "mme_cfg_upd_fail_ies_o::value_c::types");
}

// MMEConfigurationUpdateIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {61, 105, 87, 247};
  return map_enum_number(options, 4, idx, "id");
}
bool mme_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {61, 105, 87, 247};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mme_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 61:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 87:
      return crit_e::reject;
    case 247:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
mme_cfg_upd_ies_o::value_c mme_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 61:
      ret.set(value_c::types::mm_ename);
      break;
    case 105:
      ret.set(value_c::types::served_gummeis);
      break;
    case 87:
      ret.set(value_c::types::relative_mme_capacity);
      break;
    case 247:
      ret.set(value_c::types::served_dcns);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 61:
      return presence_e::optional;
    case 105:
      return presence_e::optional;
    case 87:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mme_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mm_ename:
      c.destroy<printable_string<1, 150, true, true> >();
      break;
    case types::served_gummeis:
      c.destroy<served_gummeis_l>();
      break;
    case types::served_dcns:
      c.destroy<served_dcns_l>();
      break;
    default:
      break;
  }
}
void mme_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mm_ename:
      c.init<printable_string<1, 150, true, true> >();
      break;
    case types::served_gummeis:
      c.init<served_gummeis_l>();
      break;
    case types::relative_mme_capacity:
      break;
    case types::served_dcns:
      c.init<served_dcns_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
  }
}
mme_cfg_upd_ies_o::value_c::value_c(const mme_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mm_ename:
      c.init(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::served_gummeis:
      c.init(other.c.get<served_gummeis_l>());
      break;
    case types::relative_mme_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::served_dcns:
      c.init(other.c.get<served_dcns_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
  }
}
mme_cfg_upd_ies_o::value_c& mme_cfg_upd_ies_o::value_c::operator=(const mme_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mm_ename:
      c.set(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::served_gummeis:
      c.set(other.c.get<served_gummeis_l>());
      break;
    case types::relative_mme_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::served_dcns:
      c.set(other.c.get<served_dcns_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& mme_cfg_upd_ies_o::value_c::mm_ename()
{
  assert_choice_type(types::mm_ename, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
served_gummeis_l& mme_cfg_upd_ies_o::value_c::served_gummeis()
{
  assert_choice_type(types::served_gummeis, type_, "Value");
  return c.get<served_gummeis_l>();
}
uint16_t& mme_cfg_upd_ies_o::value_c::relative_mme_capacity()
{
  assert_choice_type(types::relative_mme_capacity, type_, "Value");
  return c.get<uint16_t>();
}
served_dcns_l& mme_cfg_upd_ies_o::value_c::served_dcns()
{
  assert_choice_type(types::served_dcns, type_, "Value");
  return c.get<served_dcns_l>();
}
const printable_string<1, 150, true, true>& mme_cfg_upd_ies_o::value_c::mm_ename() const
{
  assert_choice_type(types::mm_ename, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
const served_gummeis_l& mme_cfg_upd_ies_o::value_c::served_gummeis() const
{
  assert_choice_type(types::served_gummeis, type_, "Value");
  return c.get<served_gummeis_l>();
}
const uint16_t& mme_cfg_upd_ies_o::value_c::relative_mme_capacity() const
{
  assert_choice_type(types::relative_mme_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const served_dcns_l& mme_cfg_upd_ies_o::value_c::served_dcns() const
{
  assert_choice_type(types::served_dcns, type_, "Value");
  return c.get<served_dcns_l>();
}
void mme_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mm_ename:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true> >().to_string());
      break;
    case types::served_gummeis:
      j.start_array("ServedGUMMEIs");
      for (const auto& e1 : c.get<served_gummeis_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_mme_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::served_dcns:
      j.start_array("ServedDCNs");
      for (const auto& e1 : c.get<served_dcns_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mme_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mm_ename:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().pack(bref)));
      break;
    case types::served_gummeis:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_gummeis_l>(), 1, 8, true));
      break;
    case types::relative_mme_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::served_dcns:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_dcns_l>(), 0, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mm_ename:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().unpack(bref)));
      break;
    case types::served_gummeis:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_gummeis_l>(), bref, 1, 8, true));
      break;
    case types::relative_mme_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::served_dcns:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_dcns_l>(), bref, 0, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "mme_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mme_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"PrintableString", "ServedGUMMEIs", "INTEGER (0..255)", "ServedDCNs"};
  return convert_enum_idx(options, 4, value, "mme_cfg_upd_ies_o::value_c::types");
}
uint8_t mme_cfg_upd_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_mme_capacity) {
    return 0;
  }
  invalid_enum_number(value, "mme_cfg_upd_ies_o::value_c::types");
  return 0;
}

// MMEDirectInformationTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_direct_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {122};
  return map_enum_number(options, 1, idx, "id");
}
bool mme_direct_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 122 == id;
}
crit_e mme_direct_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 122) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
mme_direct_info_transfer_ies_o::value_c mme_direct_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 122) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_direct_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 122) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void mme_direct_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("Inter-SystemInformationTransferType");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE mme_direct_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_direct_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* mme_direct_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Inter-SystemInformationTransferType"};
  return convert_enum_idx(options, 1, value, "mme_direct_info_transfer_ies_o::value_c::types");
}

// MMEStatusTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t mme_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 90};
  return map_enum_number(options, 3, idx, "id");
}
bool mme_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 90};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mme_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 90:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
mme_status_transfer_ies_o::value_c mme_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 90:
      ret.set(value_c::types::enb_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e mme_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mme_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::enb_status_transfer_transparent_container:
      c.destroy<enb_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void mme_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::enb_status_transfer_transparent_container:
      c.init<enb_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
  }
}
mme_status_transfer_ies_o::value_c::value_c(const mme_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      c.init(other.c.get<enb_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
  }
}
mme_status_transfer_ies_o::value_c&
mme_status_transfer_ies_o::value_c::operator=(const mme_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      c.set(other.c.get<enb_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& mme_status_transfer_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& mme_status_transfer_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
enb_status_transfer_transparent_container_s&
mme_status_transfer_ies_o::value_c::enb_status_transfer_transparent_container()
{
  assert_choice_type(types::enb_status_transfer_transparent_container, type_, "Value");
  return c.get<enb_status_transfer_transparent_container_s>();
}
const uint64_t& mme_status_transfer_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& mme_status_transfer_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const enb_status_transfer_transparent_container_s&
mme_status_transfer_ies_o::value_c::enb_status_transfer_transparent_container() const
{
  assert_choice_type(types::enb_status_transfer_transparent_container, type_, "Value");
  return c.get<enb_status_transfer_transparent_container_s>();
}
void mme_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::enb_status_transfer_transparent_container:
      j.write_fieldname("ENB-StatusTransfer-TransparentContainer");
      c.get<enb_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mme_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::enb_status_transfer_transparent_container:
      HANDLE_CODE(c.get<enb_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::enb_status_transfer_transparent_container:
      HANDLE_CODE(c.get<enb_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mme_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mme_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "ENB-StatusTransfer-TransparentContainer"};
  return convert_enum_idx(options, 3, value, "mme_status_transfer_ies_o::value_c::types");
}

// NASDeliveryIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t nas_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8};
  return map_enum_number(options, 2, idx, "id");
}
bool nas_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
nas_delivery_ind_ies_o::value_c nas_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e nas_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_delivery_ind_ies_o::value_c::destroy_() {}
void nas_delivery_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
nas_delivery_ind_ies_o::value_c::value_c(const nas_delivery_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_delivery_ind_ies_o::value_c");
  }
}
nas_delivery_ind_ies_o::value_c&
nas_delivery_ind_ies_o::value_c::operator=(const nas_delivery_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_delivery_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& nas_delivery_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& nas_delivery_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const uint64_t& nas_delivery_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& nas_delivery_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
void nas_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "nas_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "nas_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "nas_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nas_delivery_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)"};
  return convert_enum_idx(options, 2, value, "nas_delivery_ind_ies_o::value_c::types");
}

// NASNonDeliveryIndication-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t nas_non_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 26, 2};
  return map_enum_number(options, 4, idx, "id");
}
bool nas_non_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 26, 2};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_non_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 26:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
nas_non_delivery_ind_ies_o::value_c nas_non_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 26:
      ret.set(value_c::types::nas_pdu);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e nas_non_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_non_delivery_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void nas_non_delivery_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c::value_c(const nas_non_delivery_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c&
nas_non_delivery_ind_ies_o::value_c::operator=(const nas_non_delivery_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& nas_non_delivery_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
cause_c& nas_non_delivery_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& nas_non_delivery_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const cause_c& nas_non_delivery_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void nas_non_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nas_non_delivery_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "OCTET STRING", "Cause"};
  return convert_enum_idx(options, 4, value, "nas_non_delivery_ind_ies_o::value_c::types");
}

// OverloadStartIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t overload_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {101, 154, 161};
  return map_enum_number(options, 3, idx, "id");
}
bool overload_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {101, 154, 161};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e overload_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 101:
      return crit_e::reject;
    case 154:
      return crit_e::ignore;
    case 161:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
overload_start_ies_o::value_c overload_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 101:
      ret.set(value_c::types::overload_resp);
      break;
    case 154:
      ret.set(value_c::types::gummei_list);
      break;
    case 161:
      ret.set(value_c::types::traffic_load_reduction_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e overload_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 101:
      return presence_e::mandatory;
    case 154:
      return presence_e::optional;
    case 161:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void overload_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::overload_resp:
      c.destroy<overload_resp_c>();
      break;
    case types::gummei_list:
      c.destroy<gummei_list_l>();
      break;
    default:
      break;
  }
}
void overload_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::overload_resp:
      c.init<overload_resp_c>();
      break;
    case types::gummei_list:
      c.init<gummei_list_l>();
      break;
    case types::traffic_load_reduction_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c::value_c(const overload_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::overload_resp:
      c.init(other.c.get<overload_resp_c>());
      break;
    case types::gummei_list:
      c.init(other.c.get<gummei_list_l>());
      break;
    case types::traffic_load_reduction_ind:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c& overload_start_ies_o::value_c::operator=(const overload_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::overload_resp:
      c.set(other.c.get<overload_resp_c>());
      break;
    case types::gummei_list:
      c.set(other.c.get<gummei_list_l>());
      break;
    case types::traffic_load_reduction_ind:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }

  return *this;
}
overload_resp_c& overload_start_ies_o::value_c::overload_resp()
{
  assert_choice_type(types::overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
gummei_list_l& overload_start_ies_o::value_c::gummei_list()
{
  assert_choice_type(types::gummei_list, type_, "Value");
  return c.get<gummei_list_l>();
}
uint8_t& overload_start_ies_o::value_c::traffic_load_reduction_ind()
{
  assert_choice_type(types::traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
const overload_resp_c& overload_start_ies_o::value_c::overload_resp() const
{
  assert_choice_type(types::overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
const gummei_list_l& overload_start_ies_o::value_c::gummei_list() const
{
  assert_choice_type(types::gummei_list, type_, "Value");
  return c.get<gummei_list_l>();
}
const uint8_t& overload_start_ies_o::value_c::traffic_load_reduction_ind() const
{
  assert_choice_type(types::traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
void overload_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::overload_resp:
      j.write_fieldname("OverloadResponse");
      c.get<overload_resp_c>().to_json(j);
      break;
    case types::gummei_list:
      j.start_array("GUMMEIList");
      for (const auto& e1 : c.get<gummei_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::traffic_load_reduction_ind:
      j.write_int("INTEGER (1..99)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().pack(bref));
      break;
    case types::gummei_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<gummei_list_l>(), 1, 256, true));
      break;
    case types::traffic_load_reduction_ind:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().unpack(bref));
      break;
    case types::gummei_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<gummei_list_l>(), bref, 1, 256, true));
      break;
    case types::traffic_load_reduction_ind:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* overload_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"OverloadResponse", "GUMMEIList", "INTEGER (1..99)"};
  return convert_enum_idx(options, 3, value, "overload_start_ies_o::value_c::types");
}
uint8_t overload_start_ies_o::value_c::types_opts::to_number() const
{
  if (value == traffic_load_reduction_ind) {
    return 1;
  }
  invalid_enum_number(value, "overload_start_ies_o::value_c::types");
  return 0;
}

// OverloadStopIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t overload_stop_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {154};
  return map_enum_number(options, 1, idx, "id");
}
bool overload_stop_ies_o::is_id_valid(const uint32_t& id)
{
  return 154 == id;
}
crit_e overload_stop_ies_o::get_crit(const uint32_t& id)
{
  if (id == 154) {
    return crit_e::ignore;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
overload_stop_ies_o::value_c overload_stop_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 154) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e overload_stop_ies_o::get_presence(const uint32_t& id)
{
  if (id == 154) {
    return presence_e::optional;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void overload_stop_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("GUMMEIList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE overload_stop_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 256, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_stop_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 256, true));
  return SRSASN_SUCCESS;
}

const char* overload_stop_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"GUMMEIList"};
  return convert_enum_idx(options, 1, value, "overload_stop_ies_o::value_c::types");
}

// PWSFailureIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t pws_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {222, 59};
  return map_enum_number(options, 2, idx, "id");
}
bool pws_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {222, 59};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 222:
      return crit_e::reject;
    case 59:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
pws_fail_ind_ies_o::value_c pws_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 222:
      ret.set(value_c::types::pw_sfailed_ecgi_list);
      break;
    case 59:
      ret.set(value_c::types::global_enb_id);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e pws_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 222:
      return presence_e::mandatory;
    case 59:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      c.destroy<pw_sfailed_ecgi_list_l>();
      break;
    case types::global_enb_id:
      c.destroy<global_enb_id_s>();
      break;
    default:
      break;
  }
}
void pws_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      c.init<pw_sfailed_ecgi_list_l>();
      break;
    case types::global_enb_id:
      c.init<global_enb_id_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c::value_c(const pws_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      c.init(other.c.get<pw_sfailed_ecgi_list_l>());
      break;
    case types::global_enb_id:
      c.init(other.c.get<global_enb_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c& pws_fail_ind_ies_o::value_c::operator=(const pws_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      c.set(other.c.get<pw_sfailed_ecgi_list_l>());
      break;
    case types::global_enb_id:
      c.set(other.c.get<global_enb_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }

  return *this;
}
pw_sfailed_ecgi_list_l& pws_fail_ind_ies_o::value_c::pw_sfailed_ecgi_list()
{
  assert_choice_type(types::pw_sfailed_ecgi_list, type_, "Value");
  return c.get<pw_sfailed_ecgi_list_l>();
}
global_enb_id_s& pws_fail_ind_ies_o::value_c::global_enb_id()
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
const pw_sfailed_ecgi_list_l& pws_fail_ind_ies_o::value_c::pw_sfailed_ecgi_list() const
{
  assert_choice_type(types::pw_sfailed_ecgi_list, type_, "Value");
  return c.get<pw_sfailed_ecgi_list_l>();
}
const global_enb_id_s& pws_fail_ind_ies_o::value_c::global_enb_id() const
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
void pws_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      j.start_array("PWSfailedECGIList");
      for (const auto& e1 : c.get<pw_sfailed_ecgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::global_enb_id:
      j.write_fieldname("Global-ENB-ID");
      c.get<global_enb_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pw_sfailed_ecgi_list_l>(), 1, 256, true));
      break;
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pw_sfailed_ecgi_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pw_sfailed_ecgi_list_l>(), bref, 1, 256, true));
      break;
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"PWSfailedECGIList", "Global-ENB-ID"};
  return convert_enum_idx(options, 2, value, "pws_fail_ind_ies_o::value_c::types");
}

// PWSRestartIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t pws_restart_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {182, 59, 188, 190};
  return map_enum_number(options, 4, idx, "id");
}
bool pws_restart_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {182, 59, 188, 190};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_restart_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 182:
      return crit_e::reject;
    case 59:
      return crit_e::reject;
    case 188:
      return crit_e::reject;
    case 190:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
pws_restart_ind_ies_o::value_c pws_restart_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 182:
      ret.set(value_c::types::ecgi_list_for_restart);
      break;
    case 59:
      ret.set(value_c::types::global_enb_id);
      break;
    case 188:
      ret.set(value_c::types::tai_list_for_restart);
      break;
    case 190:
      ret.set(value_c::types::emergency_area_id_list_for_restart);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e pws_restart_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 182:
      return presence_e::mandatory;
    case 59:
      return presence_e::mandatory;
    case 188:
      return presence_e::mandatory;
    case 190:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_restart_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ecgi_list_for_restart:
      c.destroy<ecgi_list_for_restart_l>();
      break;
    case types::global_enb_id:
      c.destroy<global_enb_id_s>();
      break;
    case types::tai_list_for_restart:
      c.destroy<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.destroy<emergency_area_id_list_for_restart_l>();
      break;
    default:
      break;
  }
}
void pws_restart_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ecgi_list_for_restart:
      c.init<ecgi_list_for_restart_l>();
      break;
    case types::global_enb_id:
      c.init<global_enb_id_s>();
      break;
    case types::tai_list_for_restart:
      c.init<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.init<emergency_area_id_list_for_restart_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c::value_c(const pws_restart_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ecgi_list_for_restart:
      c.init(other.c.get<ecgi_list_for_restart_l>());
      break;
    case types::global_enb_id:
      c.init(other.c.get<global_enb_id_s>());
      break;
    case types::tai_list_for_restart:
      c.init(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.init(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c& pws_restart_ind_ies_o::value_c::operator=(const pws_restart_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ecgi_list_for_restart:
      c.set(other.c.get<ecgi_list_for_restart_l>());
      break;
    case types::global_enb_id:
      c.set(other.c.get<global_enb_id_s>());
      break;
    case types::tai_list_for_restart:
      c.set(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.set(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }

  return *this;
}
ecgi_list_for_restart_l& pws_restart_ind_ies_o::value_c::ecgi_list_for_restart()
{
  assert_choice_type(types::ecgi_list_for_restart, type_, "Value");
  return c.get<ecgi_list_for_restart_l>();
}
global_enb_id_s& pws_restart_ind_ies_o::value_c::global_enb_id()
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart()
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart()
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
const ecgi_list_for_restart_l& pws_restart_ind_ies_o::value_c::ecgi_list_for_restart() const
{
  assert_choice_type(types::ecgi_list_for_restart, type_, "Value");
  return c.get<ecgi_list_for_restart_l>();
}
const global_enb_id_s& pws_restart_ind_ies_o::value_c::global_enb_id() const
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
const tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart() const
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
const emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart() const
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
void pws_restart_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ecgi_list_for_restart:
      j.start_array("ECGIListForRestart");
      for (const auto& e1 : c.get<ecgi_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::global_enb_id:
      j.write_fieldname("Global-ENB-ID");
      c.get<global_enb_id_s>().to_json(j);
      break;
    case types::tai_list_for_restart:
      j.start_array("TAIListForRestart");
      for (const auto& e1 : c.get<tai_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list_for_restart:
      j.start_array("EmergencyAreaIDListForRestart");
      for (const auto& e1 : c.get<emergency_area_id_list_for_restart_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ecgi_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ecgi_list_for_restart_l>(), 1, 256, true));
      break;
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().pack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_restart_l>(), 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_for_restart_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ecgi_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ecgi_list_for_restart_l>(), bref, 1, 256, true));
      break;
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().unpack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_restart_l>(), bref, 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_for_restart_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_restart_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "ECGIListForRestart", "Global-ENB-ID", "TAIListForRestart", "EmergencyAreaIDListForRestart"};
  return convert_enum_idx(options, 4, value, "pws_restart_ind_ies_o::value_c::types");
}

// PagingIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {80, 43, 44, 109, 46, 128, 151, 198, 211, 227, 231, 239, 244, 251, 271};
  return map_enum_number(options, 15, idx, "id");
}
bool paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {80, 43, 44, 109, 46, 128, 151, 198, 211, 227, 231, 239, 244, 251, 271};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 80:
      return crit_e::ignore;
    case 43:
      return crit_e::ignore;
    case 44:
      return crit_e::ignore;
    case 109:
      return crit_e::ignore;
    case 46:
      return crit_e::ignore;
    case 128:
      return crit_e::ignore;
    case 151:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 211:
      return crit_e::ignore;
    case 227:
      return crit_e::ignore;
    case 231:
      return crit_e::ignore;
    case 239:
      return crit_e::ignore;
    case 244:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
paging_ies_o::value_c paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 80:
      ret.set(value_c::types::ue_id_idx_value);
      break;
    case 43:
      ret.set(value_c::types::ue_paging_id);
      break;
    case 44:
      ret.set(value_c::types::paging_drx);
      break;
    case 109:
      ret.set(value_c::types::cn_domain);
      break;
    case 46:
      ret.set(value_c::types::tai_list);
      break;
    case 128:
      ret.set(value_c::types::csg_id_list);
      break;
    case 151:
      ret.set(value_c::types::paging_prio);
      break;
    case 198:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 211:
      ret.set(value_c::types::assist_data_for_paging);
      break;
    case 227:
      ret.set(value_c::types::paging_e_drx_info);
      break;
    case 231:
      ret.set(value_c::types::extended_ue_id_idx_value);
      break;
    case 239:
      ret.set(value_c::types::nb_io_t_paging_e_drx_info);
      break;
    case 244:
      ret.set(value_c::types::nb_io_t_ue_id_idx_value);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 80:
      return presence_e::mandatory;
    case 43:
      return presence_e::mandatory;
    case 44:
      return presence_e::optional;
    case 109:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    case 128:
      return presence_e::optional;
    case 151:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 211:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    case 239:
      return presence_e::optional;
    case 244:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_id_idx_value:
      c.destroy<fixed_bitstring<10, false, true> >();
      break;
    case types::ue_paging_id:
      c.destroy<ue_paging_id_c>();
      break;
    case types::tai_list:
      c.destroy<tai_list_l>();
      break;
    case types::csg_id_list:
      c.destroy<csg_id_list_l>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::assist_data_for_paging:
      c.destroy<assist_data_for_paging_s>();
      break;
    case types::paging_e_drx_info:
      c.destroy<paging_e_drx_info_s>();
      break;
    case types::extended_ue_id_idx_value:
      c.destroy<fixed_bitstring<14, false, true> >();
      break;
    case types::nb_io_t_paging_e_drx_info:
      c.destroy<nb_io_t_paging_e_drx_info_s>();
      break;
    case types::nb_io_t_ue_id_idx_value:
      c.destroy<fixed_bitstring<12, false, true> >();
      break;
    default:
      break;
  }
}
void paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_id_idx_value:
      c.init<fixed_bitstring<10, false, true> >();
      break;
    case types::ue_paging_id:
      c.init<ue_paging_id_c>();
      break;
    case types::paging_drx:
      break;
    case types::cn_domain:
      break;
    case types::tai_list:
      c.init<tai_list_l>();
      break;
    case types::csg_id_list:
      c.init<csg_id_list_l>();
      break;
    case types::paging_prio:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<unbounded_octstring<true> >();
      break;
    case types::assist_data_for_paging:
      c.init<assist_data_for_paging_s>();
      break;
    case types::paging_e_drx_info:
      c.init<paging_e_drx_info_s>();
      break;
    case types::extended_ue_id_idx_value:
      c.init<fixed_bitstring<14, false, true> >();
      break;
    case types::nb_io_t_paging_e_drx_info:
      c.init<nb_io_t_paging_e_drx_info_s>();
      break;
    case types::nb_io_t_ue_id_idx_value:
      c.init<fixed_bitstring<12, false, true> >();
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::ce_mode_brestricted:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c::value_c(const paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_id_idx_value:
      c.init(other.c.get<fixed_bitstring<10, false, true> >());
      break;
    case types::ue_paging_id:
      c.init(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::cn_domain:
      c.init(other.c.get<cn_domain_e>());
      break;
    case types::tai_list:
      c.init(other.c.get<tai_list_l>());
      break;
    case types::csg_id_list:
      c.init(other.c.get<csg_id_list_l>());
      break;
    case types::paging_prio:
      c.init(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::assist_data_for_paging:
      c.init(other.c.get<assist_data_for_paging_s>());
      break;
    case types::paging_e_drx_info:
      c.init(other.c.get<paging_e_drx_info_s>());
      break;
    case types::extended_ue_id_idx_value:
      c.init(other.c.get<fixed_bitstring<14, false, true> >());
      break;
    case types::nb_io_t_paging_e_drx_info:
      c.init(other.c.get<nb_io_t_paging_e_drx_info_s>());
      break;
    case types::nb_io_t_ue_id_idx_value:
      c.init(other.c.get<fixed_bitstring<12, false, true> >());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c& paging_ies_o::value_c::operator=(const paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_id_idx_value:
      c.set(other.c.get<fixed_bitstring<10, false, true> >());
      break;
    case types::ue_paging_id:
      c.set(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::cn_domain:
      c.set(other.c.get<cn_domain_e>());
      break;
    case types::tai_list:
      c.set(other.c.get<tai_list_l>());
      break;
    case types::csg_id_list:
      c.set(other.c.get<csg_id_list_l>());
      break;
    case types::paging_prio:
      c.set(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::assist_data_for_paging:
      c.set(other.c.get<assist_data_for_paging_s>());
      break;
    case types::paging_e_drx_info:
      c.set(other.c.get<paging_e_drx_info_s>());
      break;
    case types::extended_ue_id_idx_value:
      c.set(other.c.get<fixed_bitstring<14, false, true> >());
      break;
    case types::nb_io_t_paging_e_drx_info:
      c.set(other.c.get<nb_io_t_paging_e_drx_info_s>());
      break;
    case types::nb_io_t_ue_id_idx_value:
      c.set(other.c.get<fixed_bitstring<12, false, true> >());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& paging_ies_o::value_c::ue_id_idx_value()
{
  assert_choice_type(types::ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<10, false, true> >();
}
ue_paging_id_c& paging_ies_o::value_c::ue_paging_id()
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
paging_drx_e& paging_ies_o::value_c::paging_drx()
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
cn_domain_e& paging_ies_o::value_c::cn_domain()
{
  assert_choice_type(types::cn_domain, type_, "Value");
  return c.get<cn_domain_e>();
}
tai_list_l& paging_ies_o::value_c::tai_list()
{
  assert_choice_type(types::tai_list, type_, "Value");
  return c.get<tai_list_l>();
}
csg_id_list_l& paging_ies_o::value_c::csg_id_list()
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
paging_prio_e& paging_ies_o::value_c::paging_prio()
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
unbounded_octstring<true>& paging_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging()
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
paging_e_drx_info_s& paging_ies_o::value_c::paging_e_drx_info()
{
  assert_choice_type(types::paging_e_drx_info, type_, "Value");
  return c.get<paging_e_drx_info_s>();
}
fixed_bitstring<14, false, true>& paging_ies_o::value_c::extended_ue_id_idx_value()
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<14, false, true> >();
}
nb_io_t_paging_e_drx_info_s& paging_ies_o::value_c::nb_io_t_paging_e_drx_info()
{
  assert_choice_type(types::nb_io_t_paging_e_drx_info, type_, "Value");
  return c.get<nb_io_t_paging_e_drx_info_s>();
}
fixed_bitstring<12, false, true>& paging_ies_o::value_c::nb_io_t_ue_id_idx_value()
{
  assert_choice_type(types::nb_io_t_ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<12, false, true> >();
}
enhanced_coverage_restricted_e& paging_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const fixed_bitstring<10, false, true>& paging_ies_o::value_c::ue_id_idx_value() const
{
  assert_choice_type(types::ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<10, false, true> >();
}
const ue_paging_id_c& paging_ies_o::value_c::ue_paging_id() const
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
const paging_drx_e& paging_ies_o::value_c::paging_drx() const
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const cn_domain_e& paging_ies_o::value_c::cn_domain() const
{
  assert_choice_type(types::cn_domain, type_, "Value");
  return c.get<cn_domain_e>();
}
const tai_list_l& paging_ies_o::value_c::tai_list() const
{
  assert_choice_type(types::tai_list, type_, "Value");
  return c.get<tai_list_l>();
}
const csg_id_list_l& paging_ies_o::value_c::csg_id_list() const
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
const paging_prio_e& paging_ies_o::value_c::paging_prio() const
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
const unbounded_octstring<true>& paging_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging() const
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
const paging_e_drx_info_s& paging_ies_o::value_c::paging_e_drx_info() const
{
  assert_choice_type(types::paging_e_drx_info, type_, "Value");
  return c.get<paging_e_drx_info_s>();
}
const fixed_bitstring<14, false, true>& paging_ies_o::value_c::extended_ue_id_idx_value() const
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<14, false, true> >();
}
const nb_io_t_paging_e_drx_info_s& paging_ies_o::value_c::nb_io_t_paging_e_drx_info() const
{
  assert_choice_type(types::nb_io_t_paging_e_drx_info, type_, "Value");
  return c.get<nb_io_t_paging_e_drx_info_s>();
}
const fixed_bitstring<12, false, true>& paging_ies_o::value_c::nb_io_t_ue_id_idx_value() const
{
  assert_choice_type(types::nb_io_t_ue_id_idx_value, type_, "Value");
  return c.get<fixed_bitstring<12, false, true> >();
}
const enhanced_coverage_restricted_e& paging_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
void paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_id_idx_value:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true> >().to_string());
      break;
    case types::ue_paging_id:
      j.write_fieldname("UEPagingID");
      c.get<ue_paging_id_c>().to_json(j);
      break;
    case types::paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::cn_domain:
      j.write_str("CNDomain", c.get<cn_domain_e>().to_string());
      break;
    case types::tai_list:
      j.start_array("TAIList");
      for (const auto& e1 : c.get<tai_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::csg_id_list:
      j.start_array("CSG-IdList");
      for (const auto& e1 : c.get<csg_id_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::paging_prio:
      j.write_str("PagingPriority", c.get<paging_prio_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::assist_data_for_paging:
      j.write_fieldname("AssistanceDataForPaging");
      c.get<assist_data_for_paging_s>().to_json(j);
      break;
    case types::paging_e_drx_info:
      j.write_fieldname("Paging-eDRXInformation");
      c.get<paging_e_drx_info_s>().to_json(j);
      break;
    case types::extended_ue_id_idx_value:
      j.write_str("BIT STRING", c.get<fixed_bitstring<14, false, true> >().to_string());
      break;
    case types::nb_io_t_paging_e_drx_info:
      j.write_fieldname("NB-IoT-Paging-eDRXInformation");
      c.get<nb_io_t_paging_e_drx_info_s>().to_json(j);
      break;
    case types::nb_io_t_ue_id_idx_value:
      j.write_str("BIT STRING", c.get<fixed_bitstring<12, false, true> >().to_string());
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true> >().pack(bref)));
      break;
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().pack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::cn_domain:
      HANDLE_CODE(c.get<cn_domain_e>().pack(bref));
      break;
    case types::tai_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_l>(), 1, 256, true));
      break;
    case types::csg_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<csg_id_list_l>(), 1, 256, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().pack(bref));
      break;
    case types::paging_e_drx_info:
      HANDLE_CODE(c.get<paging_e_drx_info_s>().pack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<14, false, true> >().pack(bref)));
      break;
    case types::nb_io_t_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_io_t_paging_e_drx_info_s>().pack(bref));
      break;
    case types::nb_io_t_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<12, false, true> >().pack(bref)));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true> >().unpack(bref)));
      break;
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().unpack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::cn_domain:
      HANDLE_CODE(c.get<cn_domain_e>().unpack(bref));
      break;
    case types::tai_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_l>(), bref, 1, 256, true));
      break;
    case types::csg_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<csg_id_list_l>(), bref, 1, 256, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().unpack(bref));
      break;
    case types::paging_e_drx_info:
      HANDLE_CODE(c.get<paging_e_drx_info_s>().unpack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<14, false, true> >().unpack(bref)));
      break;
    case types::nb_io_t_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_io_t_paging_e_drx_info_s>().unpack(bref));
      break;
    case types::nb_io_t_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<12, false, true> >().unpack(bref)));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* paging_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"BIT STRING",
                                  "UEPagingID",
                                  "PagingDRX",
                                  "CNDomain",
                                  "TAIList",
                                  "CSG-IdList",
                                  "PagingPriority",
                                  "OCTET STRING",
                                  "AssistanceDataForPaging",
                                  "Paging-eDRXInformation",
                                  "BIT STRING",
                                  "NB-IoT-Paging-eDRXInformation",
                                  "BIT STRING",
                                  "EnhancedCoverageRestricted",
                                  "CE-ModeBRestricted"};
  return convert_enum_idx(options, 15, value, "paging_ies_o::value_c::types");
}

// PathSwitchRequestAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t path_switch_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0,   8,   66,  95,  33,  40,  58,  158, 146, 195, 241,
                                     240, 248, 251, 269, 271, 277, 283, 278, 41,  299};
  return map_enum_number(options, 21, idx, "id");
}
bool path_switch_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0,   8,   66,  95,  33,  40,  58,  158, 146, 195, 241,
                                     240, 248, 251, 269, 271, 277, 283, 278, 41,  299};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 66:
      return crit_e::ignore;
    case 95:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 40:
      return crit_e::reject;
    case 58:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 241:
      return crit_e::ignore;
    case 240:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 271:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 41:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
path_switch_request_ack_ies_o::value_c path_switch_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 95:
      ret.set(value_c::types::erab_to_be_switched_ul_list);
      break;
    case 33:
      ret.set(value_c::types::erab_to_be_released_list);
      break;
    case 40:
      ret.set(value_c::types::security_context);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 158:
      ret.set(value_c::types::mme_ue_s1ap_id_minus2);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 195:
      ret.set(value_c::types::pro_se_authorized);
      break;
    case 241:
      ret.set(value_c::types::ueuser_plane_cio_tsupport_ind);
      break;
    case 240:
      ret.set(value_c::types::v2xservices_authorized);
      break;
    case 248:
      ret.set(value_c::types::ue_sidelink_aggregate_maximum_bitrate);
      break;
    case 251:
      ret.set(value_c::types::enhanced_coverage_restricted);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 271:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 277:
      ret.set(value_c::types::aerial_uesubscription_info);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 41:
      ret.set(value_c::types::ho_restrict_list);
      break;
    case 299:
      ret.set(value_c::types::add_rrm_prio_idx);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 95:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 40:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 241:
      return presence_e::optional;
    case 240:
      return presence_e::optional;
    case 248:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 41:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_switched_ul_list:
      c.destroy<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >();
      break;
    case types::erab_to_be_released_list:
      c.destroy<erab_list_l>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::pro_se_authorized:
      c.destroy<pro_se_authorized_s>();
      break;
    case types::v2xservices_authorized:
      c.destroy<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.destroy<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    case types::ho_restrict_list:
      c.destroy<ho_restrict_list_s>();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    default:
      break;
  }
}
void path_switch_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::erab_to_be_switched_ul_list:
      c.init<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >();
      break;
    case types::erab_to_be_released_list:
      c.init<erab_list_l>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::mme_ue_s1ap_id_minus2:
      break;
    case types::csg_membership_status:
      break;
    case types::pro_se_authorized:
      c.init<pro_se_authorized_s>();
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      break;
    case types::v2xservices_authorized:
      c.init<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::enhanced_coverage_restricted:
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::aerial_uesubscription_info:
      break;
    case types::pending_data_ind:
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::ho_restrict_list:
      c.init<ho_restrict_list_s>();
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c::value_c(const path_switch_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_switched_ul_list:
      c.init(other.c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >());
      break;
    case types::erab_to_be_released_list:
      c.init(other.c.get<erab_list_l>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.init(other.c.get<uint64_t>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::pro_se_authorized:
      c.init(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.init(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.init(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.init(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.init(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::ho_restrict_list:
      c.init(other.c.get<ho_restrict_list_s>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c&
path_switch_request_ack_ies_o::value_c::operator=(const path_switch_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::erab_to_be_switched_ul_list:
      c.set(other.c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >());
      break;
    case types::erab_to_be_released_list:
      c.set(other.c.get<erab_list_l>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::mme_ue_s1ap_id_minus2:
      c.set(other.c.get<uint64_t>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::pro_se_authorized:
      c.set(other.c.get<pro_se_authorized_s>());
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      c.set(other.c.get<ueuser_plane_cio_tsupport_ind_e>());
      break;
    case types::v2xservices_authorized:
      c.set(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.set(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::enhanced_coverage_restricted:
      c.set(other.c.get<enhanced_coverage_restricted_e>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::aerial_uesubscription_info:
      c.set(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::ho_restrict_list:
      c.set(other.c.get<ho_restrict_list_s>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ack_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& path_switch_request_ack_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
ue_aggregate_maximum_bitrate_s& path_switch_request_ack_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o>&
path_switch_request_ack_ies_o::value_c::erab_to_be_switched_ul_list()
{
  assert_choice_type(types::erab_to_be_switched_ul_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >();
}
erab_list_l& path_switch_request_ack_ies_o::value_c::erab_to_be_released_list()
{
  assert_choice_type(types::erab_to_be_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
security_context_s& path_switch_request_ack_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
uint64_t& path_switch_request_ack_ies_o::value_c::mme_ue_s1ap_id_minus2()
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
csg_membership_status_e& path_switch_request_ack_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::pro_se_authorized()
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
ueuser_plane_cio_tsupport_ind_e& path_switch_request_ack_ies_o::value_c::ueuser_plane_cio_tsupport_ind()
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
v2xservices_authorized_s& path_switch_request_ack_ies_o::value_c::v2xservices_authorized()
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
ue_sidelink_aggregate_maximum_bitrate_s& path_switch_request_ack_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate()
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
enhanced_coverage_restricted_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restricted()
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
nrue_security_cap_s& path_switch_request_ack_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
aerial_uesubscription_info_e& path_switch_request_ack_ies_o::value_c::aerial_uesubscription_info()
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
pending_data_ind_e& path_switch_request_ack_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
subscription_based_ue_differentiation_info_s&
path_switch_request_ack_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
ho_restrict_list_s& path_switch_request_ack_ies_o::value_c::ho_restrict_list()
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
fixed_bitstring<32, false, true>& path_switch_request_ack_ies_o::value_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& path_switch_request_ack_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const ue_aggregate_maximum_bitrate_s& path_switch_request_ack_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o>&
path_switch_request_ack_ies_o::value_c::erab_to_be_switched_ul_list() const
{
  assert_choice_type(types::erab_to_be_switched_ul_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >();
}
const erab_list_l& path_switch_request_ack_ies_o::value_c::erab_to_be_released_list() const
{
  assert_choice_type(types::erab_to_be_released_list, type_, "Value");
  return c.get<erab_list_l>();
}
const security_context_s& path_switch_request_ack_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::mme_ue_s1ap_id_minus2() const
{
  assert_choice_type(types::mme_ue_s1ap_id_minus2, type_, "Value");
  return c.get<uint64_t>();
}
const csg_membership_status_e& path_switch_request_ack_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::pro_se_authorized() const
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
const ueuser_plane_cio_tsupport_ind_e& path_switch_request_ack_ies_o::value_c::ueuser_plane_cio_tsupport_ind() const
{
  assert_choice_type(types::ueuser_plane_cio_tsupport_ind, type_, "Value");
  return c.get<ueuser_plane_cio_tsupport_ind_e>();
}
const v2xservices_authorized_s& path_switch_request_ack_ies_o::value_c::v2xservices_authorized() const
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
const ue_sidelink_aggregate_maximum_bitrate_s&
path_switch_request_ack_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate() const
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
const enhanced_coverage_restricted_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restricted() const
{
  assert_choice_type(types::enhanced_coverage_restricted, type_, "Value");
  return c.get<enhanced_coverage_restricted_e>();
}
const nrue_security_cap_s& path_switch_request_ack_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const aerial_uesubscription_info_e& path_switch_request_ack_ies_o::value_c::aerial_uesubscription_info() const
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
const pending_data_ind_e& path_switch_request_ack_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const subscription_based_ue_differentiation_info_s&
path_switch_request_ack_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const ho_restrict_list_s& path_switch_request_ack_ies_o::value_c::ho_restrict_list() const
{
  assert_choice_type(types::ho_restrict_list, type_, "Value");
  return c.get<ho_restrict_list_s>();
}
const fixed_bitstring<32, false, true>& path_switch_request_ack_ies_o::value_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
void path_switch_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::erab_to_be_switched_ul_list:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABToBeSwitchedULItemIEs}}");
      break;
    case types::erab_to_be_released_list:
      j.start_array("E-RABList");
      for (const auto& e1 : c.get<erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::mme_ue_s1ap_id_minus2:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::pro_se_authorized:
      j.write_fieldname("ProSeAuthorized");
      c.get<pro_se_authorized_s>().to_json(j);
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      j.write_str("UEUserPlaneCIoTSupportIndicator", "supported");
      break;
    case types::v2xservices_authorized:
      j.write_fieldname("V2XServicesAuthorized");
      c.get<v2xservices_authorized_s>().to_json(j);
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      j.write_fieldname("UESidelinkAggregateMaximumBitrate");
      c.get<ue_sidelink_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::enhanced_coverage_restricted:
      j.write_str("EnhancedCoverageRestricted", "restricted");
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CE-ModeBRestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::aerial_uesubscription_info:
      j.write_str("AerialUEsubscriptionInformation", c.get<aerial_uesubscription_info_e>().to_string());
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::ho_restrict_list:
      j.write_fieldname("HandoverRestrictionList");
      c.get<ho_restrict_list_s>().to_json(j);
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::erab_to_be_switched_ul_list:
      HANDLE_CODE(
          pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >(), 1, 256, true));
      break;
    case types::erab_to_be_released_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<erab_list_l>(), 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().pack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().pack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().pack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::erab_to_be_switched_ul_list:
      HANDLE_CODE(
          unpack_dyn_seq_of(c.get<erab_ie_container_list_l<erab_to_be_switched_ul_item_ies_o> >(), bref, 1, 256, true));
      break;
    case types::erab_to_be_released_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<erab_list_l>(), bref, 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::mme_ue_s1ap_id_minus2:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().unpack(bref));
      break;
    case types::ueuser_plane_cio_tsupport_ind:
      HANDLE_CODE(c.get<ueuser_plane_cio_tsupport_ind_e>().unpack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().unpack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::enhanced_coverage_restricted:
      HANDLE_CODE(c.get<enhanced_coverage_restricted_e>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::ho_restrict_list:
      HANDLE_CODE(c.get<ho_restrict_list_s>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "UEAggregateMaximumBitrate",
                                  "E-RAB-IE-ContainerList{{E-RABToBeSwitchedULItemIEs}}",
                                  "E-RABList",
                                  "SecurityContext",
                                  "CriticalityDiagnostics",
                                  "INTEGER (0..4294967295)",
                                  "CSGMembershipStatus",
                                  "ProSeAuthorized",
                                  "UEUserPlaneCIoTSupportIndicator",
                                  "V2XServicesAuthorized",
                                  "UESidelinkAggregateMaximumBitrate",
                                  "EnhancedCoverageRestricted",
                                  "NRUESecurityCapabilities",
                                  "CE-ModeBRestricted",
                                  "AerialUEsubscriptionInformation",
                                  "PendingDataIndication",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "HandoverRestrictionList",
                                  "BIT STRING"};
  return convert_enum_idx(options, 21, value, "path_switch_request_ack_ies_o::value_c::types");
}

// PathSwitchRequestFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t path_switch_request_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool path_switch_request_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
path_switch_request_fail_ies_o::value_c path_switch_request_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void path_switch_request_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c::value_c(const path_switch_request_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c&
path_switch_request_fail_ies_o::value_c::operator=(const path_switch_request_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& path_switch_request_fail_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& path_switch_request_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& path_switch_request_fail_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& path_switch_request_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void path_switch_request_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "path_switch_request_fail_ies_o::value_c::types");
}

// PathSwitchRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t path_switch_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {8, 22, 88, 100, 67, 107, 127, 145, 157, 146, 176, 186, 245, 269, 288};
  return map_enum_number(options, 15, idx, "id");
}
bool path_switch_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {8, 22, 88, 100, 67, 107, 127, 145, 157, 146, 176, 186, 245, 269, 288};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 8:
      return crit_e::reject;
    case 22:
      return crit_e::reject;
    case 88:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 67:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 127:
      return crit_e::ignore;
    case 145:
      return crit_e::ignore;
    case 157:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 176:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 245:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
path_switch_request_ies_o::value_c path_switch_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 22:
      ret.set(value_c::types::erab_to_be_switched_dl_list);
      break;
    case 88:
      ret.set(value_c::types::source_mme_ue_s1ap_id);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 107:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 127:
      ret.set(value_c::types::csg_id);
      break;
    case 145:
      ret.set(value_c::types::cell_access_mode);
      break;
    case 157:
      ret.set(value_c::types::source_mme_gummei);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 176:
      ret.set(value_c::types::tunnel_info_for_bbf);
      break;
    case 186:
      ret.set(value_c::types::lhn_id);
      break;
    case 245:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 288:
      ret.set(value_c::types::ps_cell_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 8:
      return presence_e::mandatory;
    case 22:
      return presence_e::mandatory;
    case 88:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 107:
      return presence_e::mandatory;
    case 127:
      return presence_e::optional;
    case 145:
      return presence_e::optional;
    case 157:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 176:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 288:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_to_be_switched_dl_list:
      c.destroy<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >();
      break;
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::csg_id:
      c.destroy<fixed_bitstring<27, false, true> >();
      break;
    case types::source_mme_gummei:
      c.destroy<gummei_s>();
      break;
    case types::tunnel_info_for_bbf:
      c.destroy<tunnel_info_s>();
      break;
    case types::lhn_id:
      c.destroy<bounded_octstring<32, 256, true> >();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::ps_cell_info:
      c.destroy<ps_cell_info_s>();
      break;
    default:
      break;
  }
}
void path_switch_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_to_be_switched_dl_list:
      c.init<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >();
      break;
    case types::source_mme_ue_s1ap_id:
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::csg_id:
      c.init<fixed_bitstring<27, false, true> >();
      break;
    case types::cell_access_mode:
      break;
    case types::source_mme_gummei:
      c.init<gummei_s>();
      break;
    case types::csg_membership_status:
      break;
    case types::tunnel_info_for_bbf:
      c.init<tunnel_info_s>();
      break;
    case types::lhn_id:
      c.init<bounded_octstring<32, 256, true> >();
      break;
    case types::rrc_resume_cause:
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::ps_cell_info:
      c.init<ps_cell_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c::value_c(const path_switch_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_to_be_switched_dl_list:
      c.init(other.c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >());
      break;
    case types::source_mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::csg_id:
      c.init(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::cell_access_mode:
      c.init(other.c.get<cell_access_mode_e>());
      break;
    case types::source_mme_gummei:
      c.init(other.c.get<gummei_s>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::tunnel_info_for_bbf:
      c.init(other.c.get<tunnel_info_s>());
      break;
    case types::lhn_id:
      c.init(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::ps_cell_info:
      c.init(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c&
path_switch_request_ies_o::value_c::operator=(const path_switch_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_to_be_switched_dl_list:
      c.set(other.c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >());
      break;
    case types::source_mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::csg_id:
      c.set(other.c.get<fixed_bitstring<27, false, true> >());
      break;
    case types::cell_access_mode:
      c.set(other.c.get<cell_access_mode_e>());
      break;
    case types::source_mme_gummei:
      c.set(other.c.get<gummei_s>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::tunnel_info_for_bbf:
      c.set(other.c.get<tunnel_info_s>());
      break;
    case types::lhn_id:
      c.set(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::ps_cell_info:
      c.set(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }

  return *this;
}
uint32_t& path_switch_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o>&
path_switch_request_ies_o::value_c::erab_to_be_switched_dl_list()
{
  assert_choice_type(types::erab_to_be_switched_dl_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >();
}
uint64_t& path_switch_request_ies_o::value_c::source_mme_ue_s1ap_id()
{
  assert_choice_type(types::source_mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
eutran_cgi_s& path_switch_request_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
tai_s& path_switch_request_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<27, false, true>& path_switch_request_ies_o::value_c::csg_id()
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
cell_access_mode_e& path_switch_request_ies_o::value_c::cell_access_mode()
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
gummei_s& path_switch_request_ies_o::value_c::source_mme_gummei()
{
  assert_choice_type(types::source_mme_gummei, type_, "Value");
  return c.get<gummei_s>();
}
csg_membership_status_e& path_switch_request_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
tunnel_info_s& path_switch_request_ies_o::value_c::tunnel_info_for_bbf()
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
bounded_octstring<32, 256, true>& path_switch_request_ies_o::value_c::lhn_id()
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
nrue_security_cap_s& path_switch_request_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
ps_cell_info_s& path_switch_request_ies_o::value_c::ps_cell_info()
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
const uint32_t& path_switch_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o>&
path_switch_request_ies_o::value_c::erab_to_be_switched_dl_list() const
{
  assert_choice_type(types::erab_to_be_switched_dl_list, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >();
}
const uint64_t& path_switch_request_ies_o::value_c::source_mme_ue_s1ap_id() const
{
  assert_choice_type(types::source_mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const eutran_cgi_s& path_switch_request_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const tai_s& path_switch_request_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<27, false, true>& path_switch_request_ies_o::value_c::csg_id() const
{
  assert_choice_type(types::csg_id, type_, "Value");
  return c.get<fixed_bitstring<27, false, true> >();
}
const cell_access_mode_e& path_switch_request_ies_o::value_c::cell_access_mode() const
{
  assert_choice_type(types::cell_access_mode, type_, "Value");
  return c.get<cell_access_mode_e>();
}
const gummei_s& path_switch_request_ies_o::value_c::source_mme_gummei() const
{
  assert_choice_type(types::source_mme_gummei, type_, "Value");
  return c.get<gummei_s>();
}
const csg_membership_status_e& path_switch_request_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const tunnel_info_s& path_switch_request_ies_o::value_c::tunnel_info_for_bbf() const
{
  assert_choice_type(types::tunnel_info_for_bbf, type_, "Value");
  return c.get<tunnel_info_s>();
}
const bounded_octstring<32, 256, true>& path_switch_request_ies_o::value_c::lhn_id() const
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
const rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const nrue_security_cap_s& path_switch_request_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const ps_cell_info_s& path_switch_request_ies_o::value_c::ps_cell_info() const
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
void path_switch_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_to_be_switched_dl_list:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABToBeSwitchedDLItemIEs}}");
      break;
    case types::source_mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::csg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<27, false, true> >().to_string());
      break;
    case types::cell_access_mode:
      j.write_str("CellAccessMode", "hybrid");
      break;
    case types::source_mme_gummei:
      j.write_fieldname("GUMMEI");
      c.get<gummei_s>().to_json(j);
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::tunnel_info_for_bbf:
      j.write_fieldname("TunnelInformation");
      c.get<tunnel_info_s>().to_json(j);
      break;
    case types::lhn_id:
      j.write_str("OCTET STRING", c.get<bounded_octstring<32, 256, true> >().to_string());
      break;
    case types::rrc_resume_cause:
      j.write_str("RRC-Establishment-Cause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::ps_cell_info:
      j.write_fieldname("PSCellInformation");
      c.get<ps_cell_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_to_be_switched_dl_list:
      HANDLE_CODE(
          pack_dyn_seq_of(bref, c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >(), 1, 256, true));
      break;
    case types::source_mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().pack(bref)));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().pack(bref));
      break;
    case types::source_mme_gummei:
      HANDLE_CODE(c.get<gummei_s>().pack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().pack(bref));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().pack(bref)));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_to_be_switched_dl_list:
      HANDLE_CODE(
          unpack_dyn_seq_of(c.get<erab_ie_container_list_l<erab_to_be_switched_dl_item_ies_o> >(), bref, 1, 256, true));
      break;
    case types::source_mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::csg_id:
      HANDLE_CODE((c.get<fixed_bitstring<27, false, true> >().unpack(bref)));
      break;
    case types::cell_access_mode:
      HANDLE_CODE(c.get<cell_access_mode_e>().unpack(bref));
      break;
    case types::source_mme_gummei:
      HANDLE_CODE(c.get<gummei_s>().unpack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::tunnel_info_for_bbf:
      HANDLE_CODE(c.get<tunnel_info_s>().unpack(bref));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().unpack(bref)));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABToBeSwitchedDLItemIEs}}",
                                  "INTEGER (0..4294967295)",
                                  "EUTRAN-CGI",
                                  "TAI",
                                  "UESecurityCapabilities",
                                  "BIT STRING",
                                  "CellAccessMode",
                                  "GUMMEI",
                                  "CSGMembershipStatus",
                                  "TunnelInformation",
                                  "OCTET STRING",
                                  "RRC-Establishment-Cause",
                                  "NRUESecurityCapabilities",
                                  "PSCellInformation"};
  return convert_enum_idx(options, 15, value, "path_switch_request_ies_o::value_c::types");
}

// Value ::= OPEN TYPE
void s1ap_private_ies_empty_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}
SRSASN_CODE s1ap_private_ies_empty_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_private_ies_empty_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}

const char* s1ap_private_ies_empty_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {};
  return convert_enum_idx(options, 0, value, "s1ap_private_ies_empty_o::value_c::types");
}

// RerouteNASRequest-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t reroute_nas_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {8, 0, 225, 223, 224, 230};
  return map_enum_number(options, 6, idx, "id");
}
bool reroute_nas_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {8, 0, 225, 223, 224, 230};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reroute_nas_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 8:
      return crit_e::reject;
    case 0:
      return crit_e::ignore;
    case 225:
      return crit_e::reject;
    case 223:
      return crit_e::reject;
    case 224:
      return crit_e::ignore;
    case 230:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
reroute_nas_request_ies_o::value_c reroute_nas_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 225:
      ret.set(value_c::types::s1_msg);
      break;
    case 223:
      ret.set(value_c::types::mme_group_id);
      break;
    case 224:
      ret.set(value_c::types::add_guti);
      break;
    case 230:
      ret.set(value_c::types::ue_usage_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e reroute_nas_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 8:
      return presence_e::mandatory;
    case 0:
      return presence_e::optional;
    case 225:
      return presence_e::mandatory;
    case 223:
      return presence_e::mandatory;
    case 224:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reroute_nas_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s1_msg:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::mme_group_id:
      c.destroy<fixed_octstring<2, true> >();
      break;
    case types::add_guti:
      c.destroy<add_guti_s>();
      break;
    default:
      break;
  }
}
void reroute_nas_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::enb_ue_s1ap_id:
      break;
    case types::mme_ue_s1ap_id:
      break;
    case types::s1_msg:
      c.init<unbounded_octstring<true> >();
      break;
    case types::mme_group_id:
      c.init<fixed_octstring<2, true> >();
      break;
    case types::add_guti:
      c.init<add_guti_s>();
      break;
    case types::ue_usage_type:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c::value_c(const reroute_nas_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::s1_msg:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::mme_group_id:
      c.init(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::add_guti:
      c.init(other.c.get<add_guti_s>());
      break;
    case types::ue_usage_type:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c&
reroute_nas_request_ies_o::value_c::operator=(const reroute_nas_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::s1_msg:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::mme_group_id:
      c.set(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::add_guti:
      c.set(other.c.get<add_guti_s>());
      break;
    case types::ue_usage_type:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }

  return *this;
}
uint32_t& reroute_nas_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
uint64_t& reroute_nas_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::s1_msg()
{
  assert_choice_type(types::s1_msg, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
fixed_octstring<2, true>& reroute_nas_request_ies_o::value_c::mme_group_id()
{
  assert_choice_type(types::mme_group_id, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
add_guti_s& reroute_nas_request_ies_o::value_c::add_guti()
{
  assert_choice_type(types::add_guti, type_, "Value");
  return c.get<add_guti_s>();
}
uint16_t& reroute_nas_request_ies_o::value_c::ue_usage_type()
{
  assert_choice_type(types::ue_usage_type, type_, "Value");
  return c.get<uint16_t>();
}
const uint32_t& reroute_nas_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::s1_msg() const
{
  assert_choice_type(types::s1_msg, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const fixed_octstring<2, true>& reroute_nas_request_ies_o::value_c::mme_group_id() const
{
  assert_choice_type(types::mme_group_id, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
const add_guti_s& reroute_nas_request_ies_o::value_c::add_guti() const
{
  assert_choice_type(types::add_guti, type_, "Value");
  return c.get<add_guti_s>();
}
const uint16_t& reroute_nas_request_ies_o::value_c::ue_usage_type() const
{
  assert_choice_type(types::ue_usage_type, type_, "Value");
  return c.get<uint16_t>();
}
void reroute_nas_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::s1_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::mme_group_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true> >().to_string());
      break;
    case types::add_guti:
      j.write_fieldname("Additional-GUTI");
      c.get<add_guti_s>().to_json(j);
      break;
    case types::ue_usage_type:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s1_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::mme_group_id:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().pack(bref)));
      break;
    case types::add_guti:
      HANDLE_CODE(c.get<add_guti_s>().pack(bref));
      break;
    case types::ue_usage_type:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s1_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::mme_group_id:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().unpack(bref)));
      break;
    case types::add_guti:
      HANDLE_CODE(c.get<add_guti_s>().unpack(bref));
      break;
    case types::ue_usage_type:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reroute_nas_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..16777215)",
                                  "INTEGER (0..4294967295)",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "Additional-GUTI",
                                  "INTEGER (0..255)"};
  return convert_enum_idx(options, 6, value, "reroute_nas_request_ies_o::value_c::types");
}

// ResetAcknowledgeIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t reset_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {93, 58};
  return map_enum_number(options, 2, idx, "id");
}
bool reset_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {93, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reset_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 93:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
reset_ack_ies_o::value_c reset_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 93:
      ret.set(value_c::types::ue_associated_lc_s1_conn_list_res_ack);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e reset_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 93:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reset_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      c.destroy<ue_associated_lc_s1_conn_list_res_ack_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void reset_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      c.init<ue_associated_lc_s1_conn_list_res_ack_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
  }
}
reset_ack_ies_o::value_c::value_c(const reset_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      c.init(other.c.get<ue_associated_lc_s1_conn_list_res_ack_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
  }
}
reset_ack_ies_o::value_c& reset_ack_ies_o::value_c::operator=(const reset_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      c.set(other.c.get<ue_associated_lc_s1_conn_list_res_ack_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
  }

  return *this;
}
ue_associated_lc_s1_conn_list_res_ack_l& reset_ack_ies_o::value_c::ue_associated_lc_s1_conn_list_res_ack()
{
  assert_choice_type(types::ue_associated_lc_s1_conn_list_res_ack, type_, "Value");
  return c.get<ue_associated_lc_s1_conn_list_res_ack_l>();
}
crit_diagnostics_s& reset_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_associated_lc_s1_conn_list_res_ack_l& reset_ack_ies_o::value_c::ue_associated_lc_s1_conn_list_res_ack() const
{
  assert_choice_type(types::ue_associated_lc_s1_conn_list_res_ack, type_, "Value");
  return c.get<ue_associated_lc_s1_conn_list_res_ack_l>();
}
const crit_diagnostics_s& reset_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void reset_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      j.start_array("UE-associatedLogicalS1-ConnectionListResAck");
      for (const auto& e1 : c.get<ue_associated_lc_s1_conn_list_res_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_s1_conn_list_res_ack_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_s1_conn_list_res_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_s1_conn_list_res_ack_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"UE-associatedLogicalS1-ConnectionListResAck", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 2, value, "reset_ack_ies_o::value_c::types");
}
uint8_t reset_ack_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {1};
  return map_enum_number(options, 1, value, "reset_ack_ies_o::value_c::types");
}

// ResetIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t reset_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {2, 92};
  return map_enum_number(options, 2, idx, "id");
}
bool reset_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {2, 92};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reset_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::ignore;
    case 92:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
reset_ies_o::value_c reset_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 92:
      ret.set(value_c::types::reset_type);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e reset_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::mandatory;
    case 92:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reset_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::reset_type:
      c.destroy<reset_type_c>();
      break;
    default:
      break;
  }
}
void reset_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::reset_type:
      c.init<reset_type_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
  }
}
reset_ies_o::value_c::value_c(const reset_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.init(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
  }
}
reset_ies_o::value_c& reset_ies_o::value_c::operator=(const reset_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.set(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
  }

  return *this;
}
cause_c& reset_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
reset_type_c& reset_ies_o::value_c::reset_type()
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
const cause_c& reset_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const reset_type_c& reset_ies_o::value_c::reset_type() const
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
void reset_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::reset_type:
      j.write_fieldname("ResetType");
      c.get<reset_type_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Cause", "ResetType"};
  return convert_enum_idx(options, 2, value, "reset_ies_o::value_c::types");
}

// RetrieveUEInformationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t retrieve_ue_info_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {96};
  return map_enum_number(options, 1, idx, "id");
}
bool retrieve_ue_info_ies_o::is_id_valid(const uint32_t& id)
{
  return 96 == id;
}
crit_e retrieve_ue_info_ies_o::get_crit(const uint32_t& id)
{
  if (id == 96) {
    return crit_e::reject;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}
retrieve_ue_info_ies_o::value_c retrieve_ue_info_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 96) {
    asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e retrieve_ue_info_ies_o::get_presence(const uint32_t& id)
{
  if (id == 96) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id=%d is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void retrieve_ue_info_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("S-TMSI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* retrieve_ue_info_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"S-TMSI"};
  return convert_enum_idx(options, 1, value, "retrieve_ue_info_ies_o::value_c::types");
}

// S1SetupFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t s1_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {2, 65, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool s1_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {2, 65, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e s1_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
s1_setup_fail_ies_o::value_c s1_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 65:
      ret.set(value_c::types::time_to_wait);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e s1_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void s1_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void s1_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
  }
}
s1_setup_fail_ies_o::value_c::value_c(const s1_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
  }
}
s1_setup_fail_ies_o::value_c& s1_setup_fail_ies_o::value_c::operator=(const s1_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& s1_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& s1_setup_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& s1_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& s1_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& s1_setup_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& s1_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void s1_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE s1_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "s1_setup_fail_ies_o::value_c::types");
}

// S1SetupRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t s1_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {59, 60, 64, 137, 128, 228, 234, 291};
  return map_enum_number(options, 8, idx, "id");
}
bool s1_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {59, 60, 64, 137, 128, 228, 234, 291};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e s1_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 59:
      return crit_e::reject;
    case 60:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    case 137:
      return crit_e::ignore;
    case 128:
      return crit_e::reject;
    case 228:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 291:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
s1_setup_request_ies_o::value_c s1_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 59:
      ret.set(value_c::types::global_enb_id);
      break;
    case 60:
      ret.set(value_c::types::enbname);
      break;
    case 64:
      ret.set(value_c::types::supported_tas);
      break;
    case 137:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 128:
      ret.set(value_c::types::csg_id_list);
      break;
    case 228:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 234:
      ret.set(value_c::types::nb_io_t_default_paging_drx);
      break;
    case 291:
      ret.set(value_c::types::connectedeng_nb_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e s1_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 59:
      return presence_e::mandatory;
    case 60:
      return presence_e::optional;
    case 64:
      return presence_e::mandatory;
    case 137:
      return presence_e::mandatory;
    case 128:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 291:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void s1_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_enb_id:
      c.destroy<global_enb_id_s>();
      break;
    case types::enbname:
      c.destroy<printable_string<1, 150, true, true> >();
      break;
    case types::supported_tas:
      c.destroy<supported_tas_l>();
      break;
    case types::csg_id_list:
      c.destroy<csg_id_list_l>();
      break;
    case types::connectedeng_nb_list:
      c.destroy<connectedeng_nb_list_l>();
      break;
    default:
      break;
  }
}
void s1_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_enb_id:
      c.init<global_enb_id_s>();
      break;
    case types::enbname:
      c.init<printable_string<1, 150, true, true> >();
      break;
    case types::supported_tas:
      c.init<supported_tas_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::csg_id_list:
      c.init<csg_id_list_l>();
      break;
    case types::ue_retention_info:
      break;
    case types::nb_io_t_default_paging_drx:
      break;
    case types::connectedeng_nb_list:
      c.init<connectedeng_nb_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
  }
}
s1_setup_request_ies_o::value_c::value_c(const s1_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_enb_id:
      c.init(other.c.get<global_enb_id_s>());
      break;
    case types::enbname:
      c.init(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::supported_tas:
      c.init(other.c.get<supported_tas_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::csg_id_list:
      c.init(other.c.get<csg_id_list_l>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_io_t_default_paging_drx:
      c.init(other.c.get<nb_io_t_default_paging_drx_e>());
      break;
    case types::connectedeng_nb_list:
      c.init(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
  }
}
s1_setup_request_ies_o::value_c&
s1_setup_request_ies_o::value_c::operator=(const s1_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_enb_id:
      c.set(other.c.get<global_enb_id_s>());
      break;
    case types::enbname:
      c.set(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::supported_tas:
      c.set(other.c.get<supported_tas_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::csg_id_list:
      c.set(other.c.get<csg_id_list_l>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_io_t_default_paging_drx:
      c.set(other.c.get<nb_io_t_default_paging_drx_e>());
      break;
    case types::connectedeng_nb_list:
      c.set(other.c.get<connectedeng_nb_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
  }

  return *this;
}
global_enb_id_s& s1_setup_request_ies_o::value_c::global_enb_id()
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
printable_string<1, 150, true, true>& s1_setup_request_ies_o::value_c::enbname()
{
  assert_choice_type(types::enbname, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
supported_tas_l& s1_setup_request_ies_o::value_c::supported_tas()
{
  assert_choice_type(types::supported_tas, type_, "Value");
  return c.get<supported_tas_l>();
}
paging_drx_e& s1_setup_request_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
csg_id_list_l& s1_setup_request_ies_o::value_c::csg_id_list()
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
ue_retention_info_e& s1_setup_request_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
nb_io_t_default_paging_drx_e& s1_setup_request_ies_o::value_c::nb_io_t_default_paging_drx()
{
  assert_choice_type(types::nb_io_t_default_paging_drx, type_, "Value");
  return c.get<nb_io_t_default_paging_drx_e>();
}
connectedeng_nb_list_l& s1_setup_request_ies_o::value_c::connectedeng_nb_list()
{
  assert_choice_type(types::connectedeng_nb_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
const global_enb_id_s& s1_setup_request_ies_o::value_c::global_enb_id() const
{
  assert_choice_type(types::global_enb_id, type_, "Value");
  return c.get<global_enb_id_s>();
}
const printable_string<1, 150, true, true>& s1_setup_request_ies_o::value_c::enbname() const
{
  assert_choice_type(types::enbname, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
const supported_tas_l& s1_setup_request_ies_o::value_c::supported_tas() const
{
  assert_choice_type(types::supported_tas, type_, "Value");
  return c.get<supported_tas_l>();
}
const paging_drx_e& s1_setup_request_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const csg_id_list_l& s1_setup_request_ies_o::value_c::csg_id_list() const
{
  assert_choice_type(types::csg_id_list, type_, "Value");
  return c.get<csg_id_list_l>();
}
const ue_retention_info_e& s1_setup_request_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const nb_io_t_default_paging_drx_e& s1_setup_request_ies_o::value_c::nb_io_t_default_paging_drx() const
{
  assert_choice_type(types::nb_io_t_default_paging_drx, type_, "Value");
  return c.get<nb_io_t_default_paging_drx_e>();
}
const connectedeng_nb_list_l& s1_setup_request_ies_o::value_c::connectedeng_nb_list() const
{
  assert_choice_type(types::connectedeng_nb_list, type_, "Value");
  return c.get<connectedeng_nb_list_l>();
}
void s1_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_enb_id:
      j.write_fieldname("Global-ENB-ID");
      c.get<global_enb_id_s>().to_json(j);
      break;
    case types::enbname:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true> >().to_string());
      break;
    case types::supported_tas:
      j.start_array("SupportedTAs");
      for (const auto& e1 : c.get<supported_tas_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::csg_id_list:
      j.start_array("CSG-IdList");
      for (const auto& e1 : c.get<csg_id_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_retention_info:
      j.write_str("UE-RetentionInformation", "ues-retained");
      break;
    case types::nb_io_t_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_io_t_default_paging_drx_e>().to_string());
      break;
    case types::connectedeng_nb_list:
      j.start_array("ConnectedengNBList");
      for (const auto& e1 : c.get<connectedeng_nb_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE s1_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().pack(bref));
      break;
    case types::enbname:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().pack(bref)));
      break;
    case types::supported_tas:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_tas_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::csg_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<csg_id_list_l>(), 1, 256, true));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::nb_io_t_default_paging_drx:
      HANDLE_CODE(c.get<nb_io_t_default_paging_drx_e>().pack(bref));
      break;
    case types::connectedeng_nb_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<connectedeng_nb_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_enb_id:
      HANDLE_CODE(c.get<global_enb_id_s>().unpack(bref));
      break;
    case types::enbname:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().unpack(bref)));
      break;
    case types::supported_tas:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_tas_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::csg_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<csg_id_list_l>(), bref, 1, 256, true));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::nb_io_t_default_paging_drx:
      HANDLE_CODE(c.get<nb_io_t_default_paging_drx_e>().unpack(bref));
      break;
    case types::connectedeng_nb_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<connectedeng_nb_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"Global-ENB-ID",
                                  "PrintableString",
                                  "SupportedTAs",
                                  "PagingDRX",
                                  "CSG-IdList",
                                  "UE-RetentionInformation",
                                  "NB-IoT-DefaultPagingDRX",
                                  "ConnectedengNBList"};
  return convert_enum_idx(options, 8, value, "s1_setup_request_ies_o::value_c::types");
}

// S1SetupResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t s1_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {61, 105, 87, 163, 58, 228, 247};
  return map_enum_number(options, 7, idx, "id");
}
bool s1_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {61, 105, 87, 163, 58, 228, 247};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e s1_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 61:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 87:
      return crit_e::ignore;
    case 163:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 228:
      return crit_e::ignore;
    case 247:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
s1_setup_resp_ies_o::value_c s1_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 61:
      ret.set(value_c::types::mm_ename);
      break;
    case 105:
      ret.set(value_c::types::served_gummeis);
      break;
    case 87:
      ret.set(value_c::types::relative_mme_capacity);
      break;
    case 163:
      ret.set(value_c::types::mme_relay_support_ind);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 228:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 247:
      ret.set(value_c::types::served_dcns);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e s1_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 61:
      return presence_e::optional;
    case 105:
      return presence_e::mandatory;
    case 87:
      return presence_e::mandatory;
    case 163:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void s1_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mm_ename:
      c.destroy<printable_string<1, 150, true, true> >();
      break;
    case types::served_gummeis:
      c.destroy<served_gummeis_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::served_dcns:
      c.destroy<served_dcns_l>();
      break;
    default:
      break;
  }
}
void s1_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mm_ename:
      c.init<printable_string<1, 150, true, true> >();
      break;
    case types::served_gummeis:
      c.init<served_gummeis_l>();
      break;
    case types::relative_mme_capacity:
      break;
    case types::mme_relay_support_ind:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::ue_retention_info:
      break;
    case types::served_dcns:
      c.init<served_dcns_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
  }
}
s1_setup_resp_ies_o::value_c::value_c(const s1_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mm_ename:
      c.init(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::served_gummeis:
      c.init(other.c.get<served_gummeis_l>());
      break;
    case types::relative_mme_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::mme_relay_support_ind:
      c.init(other.c.get<mme_relay_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::served_dcns:
      c.init(other.c.get<served_dcns_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
  }
}
s1_setup_resp_ies_o::value_c& s1_setup_resp_ies_o::value_c::operator=(const s1_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mm_ename:
      c.set(other.c.get<printable_string<1, 150, true, true> >());
      break;
    case types::served_gummeis:
      c.set(other.c.get<served_gummeis_l>());
      break;
    case types::relative_mme_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::mme_relay_support_ind:
      c.set(other.c.get<mme_relay_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::served_dcns:
      c.set(other.c.get<served_dcns_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& s1_setup_resp_ies_o::value_c::mm_ename()
{
  assert_choice_type(types::mm_ename, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
served_gummeis_l& s1_setup_resp_ies_o::value_c::served_gummeis()
{
  assert_choice_type(types::served_gummeis, type_, "Value");
  return c.get<served_gummeis_l>();
}
uint16_t& s1_setup_resp_ies_o::value_c::relative_mme_capacity()
{
  assert_choice_type(types::relative_mme_capacity, type_, "Value");
  return c.get<uint16_t>();
}
mme_relay_support_ind_e& s1_setup_resp_ies_o::value_c::mme_relay_support_ind()
{
  assert_choice_type(types::mme_relay_support_ind, type_, "Value");
  return c.get<mme_relay_support_ind_e>();
}
crit_diagnostics_s& s1_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
ue_retention_info_e& s1_setup_resp_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
served_dcns_l& s1_setup_resp_ies_o::value_c::served_dcns()
{
  assert_choice_type(types::served_dcns, type_, "Value");
  return c.get<served_dcns_l>();
}
const printable_string<1, 150, true, true>& s1_setup_resp_ies_o::value_c::mm_ename() const
{
  assert_choice_type(types::mm_ename, type_, "Value");
  return c.get<printable_string<1, 150, true, true> >();
}
const served_gummeis_l& s1_setup_resp_ies_o::value_c::served_gummeis() const
{
  assert_choice_type(types::served_gummeis, type_, "Value");
  return c.get<served_gummeis_l>();
}
const uint16_t& s1_setup_resp_ies_o::value_c::relative_mme_capacity() const
{
  assert_choice_type(types::relative_mme_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const mme_relay_support_ind_e& s1_setup_resp_ies_o::value_c::mme_relay_support_ind() const
{
  assert_choice_type(types::mme_relay_support_ind, type_, "Value");
  return c.get<mme_relay_support_ind_e>();
}
const crit_diagnostics_s& s1_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_retention_info_e& s1_setup_resp_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const served_dcns_l& s1_setup_resp_ies_o::value_c::served_dcns() const
{
  assert_choice_type(types::served_dcns, type_, "Value");
  return c.get<served_dcns_l>();
}
void s1_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mm_ename:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true> >().to_string());
      break;
    case types::served_gummeis:
      j.start_array("ServedGUMMEIs");
      for (const auto& e1 : c.get<served_gummeis_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_mme_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::mme_relay_support_ind:
      j.write_str("MMERelaySupportIndicator", "true");
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::ue_retention_info:
      j.write_str("UE-RetentionInformation", "ues-retained");
      break;
    case types::served_dcns:
      j.start_array("ServedDCNs");
      for (const auto& e1 : c.get<served_dcns_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE s1_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mm_ename:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().pack(bref)));
      break;
    case types::served_gummeis:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_gummeis_l>(), 1, 8, true));
      break;
    case types::relative_mme_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::mme_relay_support_ind:
      HANDLE_CODE(c.get<mme_relay_support_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::served_dcns:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_dcns_l>(), 0, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mm_ename:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true> >().unpack(bref)));
      break;
    case types::served_gummeis:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_gummeis_l>(), bref, 1, 8, true));
      break;
    case types::relative_mme_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::mme_relay_support_ind:
      HANDLE_CODE(c.get<mme_relay_support_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::served_dcns:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_dcns_l>(), bref, 0, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "s1_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"PrintableString",
                                  "ServedGUMMEIs",
                                  "INTEGER (0..255)",
                                  "MMERelaySupportIndicator",
                                  "CriticalityDiagnostics",
                                  "UE-RetentionInformation",
                                  "ServedDCNs"};
  return convert_enum_idx(options, 7, value, "s1_setup_resp_ies_o::value_c::types");
}
uint8_t s1_setup_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_mme_capacity) {
    return 0;
  }
  invalid_enum_number(value, "s1_setup_resp_ies_o::value_c::types");
  return 0;
}

// SecondaryRATDataUsageReportIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 264, 266, 189, 297};
  return map_enum_number(options, 6, idx, "id");
}
bool secondary_rat_data_usage_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 264, 266, 189, 297};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e secondary_rat_data_usage_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    case 266:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    case 297:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
secondary_rat_data_usage_report_ies_o::value_c secondary_rat_data_usage_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    case 266:
      ret.set(value_c::types::ho_flag);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    case 297:
      ret.set(value_c::types::time_since_secondary_node_release);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 264:
      return presence_e::mandatory;
    case 266:
      return presence_e::optional;
    case 189:
      return presence_e::optional;
    case 297:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    case types::time_since_secondary_node_release:
      c.destroy<fixed_octstring<4, true> >();
      break;
    default:
      break;
  }
}
void secondary_rat_data_usage_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::ho_flag:
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::time_since_secondary_node_release:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c::value_c(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::ho_flag:
      c.init(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::time_since_secondary_node_release:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c&
secondary_rat_data_usage_report_ies_o::value_c::operator=(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::ho_flag:
      c.set(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::time_since_secondary_node_release:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& secondary_rat_data_usage_report_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
secondary_rat_data_usage_report_list_l&
secondary_rat_data_usage_report_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag()
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
user_location_info_s& secondary_rat_data_usage_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
fixed_octstring<4, true>& secondary_rat_data_usage_report_ies_o::value_c::time_since_secondary_node_release()
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& secondary_rat_data_usage_report_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const secondary_rat_data_usage_report_list_l&
secondary_rat_data_usage_report_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag() const
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
const user_location_info_s& secondary_rat_data_usage_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const fixed_octstring<4, true>&
secondary_rat_data_usage_report_ies_o::value_c::time_since_secondary_node_release() const
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
void secondary_rat_data_usage_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ho_flag:
      j.write_str("HandoverFlag", "handoverPreparation");
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    case types::time_since_secondary_node_release:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* secondary_rat_data_usage_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "SecondaryRATDataUsageReportList",
                                  "HandoverFlag",
                                  "UserLocationInformation",
                                  "OCTET STRING"};
  return convert_enum_idx(options, 6, value, "secondary_rat_data_usage_report_ies_o::value_c::types");
}

// TraceFailureIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t trace_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 86, 2};
  return map_enum_number(options, 4, idx, "id");
}
bool trace_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 86, 2};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
trace_fail_ind_ies_o::value_c trace_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 86:
      ret.set(value_c::types::e_utran_trace_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e trace_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::e_utran_trace_id:
      c.destroy<fixed_octstring<8, true> >();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void trace_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::e_utran_trace_id:
      c.init<fixed_octstring<8, true> >();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c::value_c(const trace_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c& trace_fail_ind_ies_o::value_c::operator=(const trace_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true> >());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_fail_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& trace_fail_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::e_utran_trace_id()
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
cause_c& trace_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& trace_fail_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::e_utran_trace_id() const
{
  assert_choice_type(types::e_utran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true> >();
}
const cause_c& trace_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void trace_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::e_utran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true> >().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().pack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::e_utran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true> >().unpack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "OCTET STRING", "Cause"};
  return convert_enum_idx(options, 4, value, "trace_fail_ind_ies_o::value_c::types");
}

// TraceStartIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t trace_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 25};
  return map_enum_number(options, 3, idx, "id");
}
bool trace_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 25};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
trace_start_ies_o::value_c trace_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 25:
      ret.set(value_c::types::trace_activation);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e trace_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 25:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    default:
      break;
  }
}
void trace_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c::value_c(const trace_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c& trace_start_ies_o::value_c::operator=(const trace_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_start_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& trace_start_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
trace_activation_s& trace_start_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const uint64_t& trace_start_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& trace_start_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const trace_activation_s& trace_start_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
void trace_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "TraceActivation"};
  return convert_enum_idx(options, 3, value, "trace_start_ies_o::value_c::types");
}

// UECapabilityInfoIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_cap_info_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 74, 198, 263, 272};
  return map_enum_number(options, 6, idx, "id");
}
bool ue_cap_info_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 74, 198, 263, 272};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_cap_info_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 74:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 263:
      return crit_e::ignore;
    case 272:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_cap_info_ind_ies_o::value_c ue_cap_info_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 198:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 263:
      ret.set(value_c::types::ue_application_layer_meas_cap);
      break;
    case 272:
      ret.set(value_c::types::lte_m_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_cap_info_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 74:
      return presence_e::mandatory;
    case 198:
      return presence_e::optional;
    case 263:
      return presence_e::optional;
    case 272:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_cap_info_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ue_application_layer_meas_cap:
      c.destroy<fixed_bitstring<8, false, true> >();
      break;
    default:
      break;
  }
}
void ue_cap_info_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ue_radio_cap_for_paging:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ue_application_layer_meas_cap:
      c.init<fixed_bitstring<8, false, true> >();
      break;
    case types::lte_m_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
  }
}
ue_cap_info_ind_ies_o::value_c::value_c(const ue_cap_info_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_application_layer_meas_cap:
      c.init(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::lte_m_ind:
      c.init(other.c.get<lte_m_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
  }
}
ue_cap_info_ind_ies_o::value_c& ue_cap_info_ind_ies_o::value_c::operator=(const ue_cap_info_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ue_application_layer_meas_cap:
      c.set(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::lte_m_ind:
      c.set(other.c.get<lte_m_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_cap_info_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_cap_info_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& ue_cap_info_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ue_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
fixed_bitstring<8, false, true>& ue_cap_info_ind_ies_o::value_c::ue_application_layer_meas_cap()
{
  assert_choice_type(types::ue_application_layer_meas_cap, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
lte_m_ind_e& ue_cap_info_ind_ies_o::value_c::lte_m_ind()
{
  assert_choice_type(types::lte_m_ind, type_, "Value");
  return c.get<lte_m_ind_e>();
}
const uint64_t& ue_cap_info_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_cap_info_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& ue_cap_info_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ue_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const fixed_bitstring<8, false, true>& ue_cap_info_ind_ies_o::value_c::ue_application_layer_meas_cap() const
{
  assert_choice_type(types::ue_application_layer_meas_cap, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
const lte_m_ind_e& ue_cap_info_ind_ies_o::value_c::lte_m_ind() const
{
  assert_choice_type(types::lte_m_ind, type_, "Value");
  return c.get<lte_m_ind_e>();
}
void ue_cap_info_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ue_application_layer_meas_cap:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true> >().to_string());
      break;
    case types::lte_m_ind:
      j.write_str("LTE-M-Indication", "lte-m");
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_cap_info_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ue_application_layer_meas_cap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().pack(bref)));
      break;
    case types::lte_m_ind:
      HANDLE_CODE(c.get<lte_m_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_cap_info_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ue_application_layer_meas_cap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().unpack(bref)));
      break;
    case types::lte_m_ind:
      HANDLE_CODE(c.get<lte_m_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_cap_info_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "BIT STRING",
                                  "LTE-M-Indication"};
  return convert_enum_idx(options, 6, value, "ue_cap_info_ind_ies_o::value_c::types");
}

// UEContextModificationConfirmIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_mod_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 146, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_context_mod_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 146, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_mod_confirm_ies_o::value_c ue_context_mod_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 146:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_confirm_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_confirm_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::csg_membership_status:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
  }
}
ue_context_mod_confirm_ies_o::value_c::value_c(const ue_context_mod_confirm_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
  }
}
ue_context_mod_confirm_ies_o::value_c&
ue_context_mod_confirm_ies_o::value_c::operator=(const ue_context_mod_confirm_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_confirm_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_mod_confirm_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
csg_membership_status_e& ue_context_mod_confirm_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
crit_diagnostics_s& ue_context_mod_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_confirm_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_mod_confirm_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const csg_membership_status_e& ue_context_mod_confirm_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const crit_diagnostics_s& ue_context_mod_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_confirm_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "CSGMembershipStatus", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "ue_context_mod_confirm_ies_o::value_c::types");
}

// UEContextModificationFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_context_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_mod_fail_ies_o::value_c ue_context_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c::value_c(const ue_context_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c&
ue_context_mod_fail_ies_o::value_c::operator=(const ue_context_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_mod_fail_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& ue_context_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_mod_fail_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& ue_context_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "ue_context_mod_fail_ies_o::value_c::types");
}

// UEContextModificationIndicationIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_mod_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 226};
  return map_enum_number(options, 3, idx, "id");
}
bool ue_context_mod_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 226};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 226:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_mod_ind_ies_o::value_c ue_context_mod_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 226:
      ret.set(value_c::types::csg_membership_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 226:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::csg_membership_info:
      c.destroy<csg_membership_info_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::csg_membership_info:
      c.init<csg_membership_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
  }
}
ue_context_mod_ind_ies_o::value_c::value_c(const ue_context_mod_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::csg_membership_info:
      c.init(other.c.get<csg_membership_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
  }
}
ue_context_mod_ind_ies_o::value_c&
ue_context_mod_ind_ies_o::value_c::operator=(const ue_context_mod_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::csg_membership_info:
      c.set(other.c.get<csg_membership_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_ind_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_mod_ind_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
csg_membership_info_s& ue_context_mod_ind_ies_o::value_c::csg_membership_info()
{
  assert_choice_type(types::csg_membership_info, type_, "Value");
  return c.get<csg_membership_info_s>();
}
const uint64_t& ue_context_mod_ind_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_mod_ind_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const csg_membership_info_s& ue_context_mod_ind_ies_o::value_c::csg_membership_info() const
{
  assert_choice_type(types::csg_membership_info, type_, "Value");
  return c.get<csg_membership_info_s>();
}
void ue_context_mod_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::csg_membership_info:
      j.write_fieldname("CSGMembershipInfo");
      c.get<csg_membership_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::csg_membership_info:
      HANDLE_CODE(c.get<csg_membership_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::csg_membership_info:
      HANDLE_CODE(c.get<csg_membership_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "CSGMembershipInfo"};
  return convert_enum_idx(options, 3, value, "ue_context_mod_ind_ies_o::value_c::types");
}

// UEContextModificationRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {
      0, 8, 73, 106, 66, 108, 107, 146, 159, 187, 195, 124, 243, 240, 248, 269, 277, 299};
  return map_enum_number(options, 18, idx, "id");
}
bool ue_context_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {
      0, 8, 73, 106, 66, 108, 107, 146, 159, 187, 195, 124, 243, 240, 248, 269, 277, 299};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 106:
      return crit_e::ignore;
    case 66:
      return crit_e::ignore;
    case 108:
      return crit_e::reject;
    case 107:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 159:
      return crit_e::ignore;
    case 187:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 243:
      return crit_e::ignore;
    case 240:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_mod_request_ies_o::value_c ue_context_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 73:
      ret.set(value_c::types::security_key);
      break;
    case 106:
      ret.set(value_c::types::subscriber_profile_idfor_rfp);
      break;
    case 66:
      ret.set(value_c::types::ueaggregate_maximum_bitrate);
      break;
    case 108:
      ret.set(value_c::types::cs_fallback_ind);
      break;
    case 107:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 146:
      ret.set(value_c::types::csg_membership_status);
      break;
    case 159:
      ret.set(value_c::types::registered_lai);
      break;
    case 187:
      ret.set(value_c::types::add_cs_fallback_ind);
      break;
    case 195:
      ret.set(value_c::types::pro_se_authorized);
      break;
    case 124:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 243:
      ret.set(value_c::types::srvcc_operation_not_possible);
      break;
    case 240:
      ret.set(value_c::types::v2xservices_authorized);
      break;
    case 248:
      ret.set(value_c::types::ue_sidelink_aggregate_maximum_bitrate);
      break;
    case 269:
      ret.set(value_c::types::nrue_security_cap);
      break;
    case 277:
      ret.set(value_c::types::aerial_uesubscription_info);
      break;
    case 299:
      ret.set(value_c::types::add_rrm_prio_idx);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 73:
      return presence_e::optional;
    case 106:
      return presence_e::optional;
    case 66:
      return presence_e::optional;
    case 108:
      return presence_e::optional;
    case 107:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 159:
      return presence_e::optional;
    case 187:
      return presence_e::conditional;
    case 195:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 243:
      return presence_e::optional;
    case 240:
      return presence_e::optional;
    case 248:
      return presence_e::optional;
    case 269:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true> >();
      break;
    case types::ueaggregate_maximum_bitrate:
      c.destroy<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::registered_lai:
      c.destroy<lai_s>();
      break;
    case types::pro_se_authorized:
      c.destroy<pro_se_authorized_s>();
      break;
    case types::v2xservices_authorized:
      c.destroy<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.destroy<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::nrue_security_cap:
      c.destroy<nrue_security_cap_s>();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    default:
      break;
  }
}
void ue_context_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true> >();
      break;
    case types::subscriber_profile_idfor_rfp:
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init<ue_aggregate_maximum_bitrate_s>();
      break;
    case types::cs_fallback_ind:
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::csg_membership_status:
      break;
    case types::registered_lai:
      c.init<lai_s>();
      break;
    case types::add_cs_fallback_ind:
      break;
    case types::pro_se_authorized:
      c.init<pro_se_authorized_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::srvcc_operation_not_possible:
      break;
    case types::v2xservices_authorized:
      c.init<v2xservices_authorized_s>();
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init<ue_sidelink_aggregate_maximum_bitrate_s>();
      break;
    case types::nrue_security_cap:
      c.init<nrue_security_cap_s>();
      break;
    case types::aerial_uesubscription_info:
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c::value_c(const ue_context_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true> >());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.init(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::cs_fallback_ind:
      c.init(other.c.get<cs_fallback_ind_e>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::csg_membership_status:
      c.init(other.c.get<csg_membership_status_e>());
      break;
    case types::registered_lai:
      c.init(other.c.get<lai_s>());
      break;
    case types::add_cs_fallback_ind:
      c.init(other.c.get<add_cs_fallback_ind_e>());
      break;
    case types::pro_se_authorized:
      c.init(other.c.get<pro_se_authorized_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::srvcc_operation_not_possible:
      c.init(other.c.get<srvcc_operation_not_possible_e>());
      break;
    case types::v2xservices_authorized:
      c.init(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.init(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::nrue_security_cap:
      c.init(other.c.get<nrue_security_cap_s>());
      break;
    case types::aerial_uesubscription_info:
      c.init(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c&
ue_context_mod_request_ies_o::value_c::operator=(const ue_context_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true> >());
      break;
    case types::subscriber_profile_idfor_rfp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      c.set(other.c.get<ue_aggregate_maximum_bitrate_s>());
      break;
    case types::cs_fallback_ind:
      c.set(other.c.get<cs_fallback_ind_e>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::csg_membership_status:
      c.set(other.c.get<csg_membership_status_e>());
      break;
    case types::registered_lai:
      c.set(other.c.get<lai_s>());
      break;
    case types::add_cs_fallback_ind:
      c.set(other.c.get<add_cs_fallback_ind_e>());
      break;
    case types::pro_se_authorized:
      c.set(other.c.get<pro_se_authorized_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::srvcc_operation_not_possible:
      c.set(other.c.get<srvcc_operation_not_possible_e>());
      break;
    case types::v2xservices_authorized:
      c.set(other.c.get<v2xservices_authorized_s>());
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      c.set(other.c.get<ue_sidelink_aggregate_maximum_bitrate_s>());
      break;
    case types::nrue_security_cap:
      c.set(other.c.get<nrue_security_cap_s>());
      break;
    case types::aerial_uesubscription_info:
      c.set(other.c.get<aerial_uesubscription_info_e>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_mod_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true> >();
}
uint16_t& ue_context_mod_request_ies_o::value_c::subscriber_profile_idfor_rfp()
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggregate_maximum_bitrate_s& ue_context_mod_request_ies_o::value_c::ueaggregate_maximum_bitrate()
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
cs_fallback_ind_e& ue_context_mod_request_ies_o::value_c::cs_fallback_ind()
{
  assert_choice_type(types::cs_fallback_ind, type_, "Value");
  return c.get<cs_fallback_ind_e>();
}
ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
csg_membership_status_e& ue_context_mod_request_ies_o::value_c::csg_membership_status()
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
lai_s& ue_context_mod_request_ies_o::value_c::registered_lai()
{
  assert_choice_type(types::registered_lai, type_, "Value");
  return c.get<lai_s>();
}
add_cs_fallback_ind_e& ue_context_mod_request_ies_o::value_c::add_cs_fallback_ind()
{
  assert_choice_type(types::add_cs_fallback_ind, type_, "Value");
  return c.get<add_cs_fallback_ind_e>();
}
pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::pro_se_authorized()
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
srvcc_operation_not_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_not_possible()
{
  assert_choice_type(types::srvcc_operation_not_possible, type_, "Value");
  return c.get<srvcc_operation_not_possible_e>();
}
v2xservices_authorized_s& ue_context_mod_request_ies_o::value_c::v2xservices_authorized()
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
ue_sidelink_aggregate_maximum_bitrate_s& ue_context_mod_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate()
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
nrue_security_cap_s& ue_context_mod_request_ies_o::value_c::nrue_security_cap()
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
aerial_uesubscription_info_e& ue_context_mod_request_ies_o::value_c::aerial_uesubscription_info()
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
fixed_bitstring<32, false, true>& ue_context_mod_request_ies_o::value_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_mod_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true> >();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::subscriber_profile_idfor_rfp() const
{
  assert_choice_type(types::subscriber_profile_idfor_rfp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggregate_maximum_bitrate_s& ue_context_mod_request_ies_o::value_c::ueaggregate_maximum_bitrate() const
{
  assert_choice_type(types::ueaggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_aggregate_maximum_bitrate_s>();
}
const cs_fallback_ind_e& ue_context_mod_request_ies_o::value_c::cs_fallback_ind() const
{
  assert_choice_type(types::cs_fallback_ind, type_, "Value");
  return c.get<cs_fallback_ind_e>();
}
const ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const csg_membership_status_e& ue_context_mod_request_ies_o::value_c::csg_membership_status() const
{
  assert_choice_type(types::csg_membership_status, type_, "Value");
  return c.get<csg_membership_status_e>();
}
const lai_s& ue_context_mod_request_ies_o::value_c::registered_lai() const
{
  assert_choice_type(types::registered_lai, type_, "Value");
  return c.get<lai_s>();
}
const add_cs_fallback_ind_e& ue_context_mod_request_ies_o::value_c::add_cs_fallback_ind() const
{
  assert_choice_type(types::add_cs_fallback_ind, type_, "Value");
  return c.get<add_cs_fallback_ind_e>();
}
const pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::pro_se_authorized() const
{
  assert_choice_type(types::pro_se_authorized, type_, "Value");
  return c.get<pro_se_authorized_s>();
}
const srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const srvcc_operation_not_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_not_possible() const
{
  assert_choice_type(types::srvcc_operation_not_possible, type_, "Value");
  return c.get<srvcc_operation_not_possible_e>();
}
const v2xservices_authorized_s& ue_context_mod_request_ies_o::value_c::v2xservices_authorized() const
{
  assert_choice_type(types::v2xservices_authorized, type_, "Value");
  return c.get<v2xservices_authorized_s>();
}
const ue_sidelink_aggregate_maximum_bitrate_s&
ue_context_mod_request_ies_o::value_c::ue_sidelink_aggregate_maximum_bitrate() const
{
  assert_choice_type(types::ue_sidelink_aggregate_maximum_bitrate, type_, "Value");
  return c.get<ue_sidelink_aggregate_maximum_bitrate_s>();
}
const nrue_security_cap_s& ue_context_mod_request_ies_o::value_c::nrue_security_cap() const
{
  assert_choice_type(types::nrue_security_cap, type_, "Value");
  return c.get<nrue_security_cap_s>();
}
const aerial_uesubscription_info_e& ue_context_mod_request_ies_o::value_c::aerial_uesubscription_info() const
{
  assert_choice_type(types::aerial_uesubscription_info, type_, "Value");
  return c.get<aerial_uesubscription_info_e>();
}
const fixed_bitstring<32, false, true>& ue_context_mod_request_ies_o::value_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Value");
  return c.get<fixed_bitstring<32, false, true> >();
}
void ue_context_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true> >().to_string());
      break;
    case types::subscriber_profile_idfor_rfp:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::ueaggregate_maximum_bitrate:
      j.write_fieldname("UEAggregateMaximumBitrate");
      c.get<ue_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::cs_fallback_ind:
      j.write_str("CSFallbackIndicator", c.get<cs_fallback_ind_e>().to_string());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::csg_membership_status:
      j.write_str("CSGMembershipStatus", c.get<csg_membership_status_e>().to_string());
      break;
    case types::registered_lai:
      j.write_fieldname("LAI");
      c.get<lai_s>().to_json(j);
      break;
    case types::add_cs_fallback_ind:
      j.write_str("AdditionalCSFallbackIndicator", c.get<add_cs_fallback_ind_e>().to_string());
      break;
    case types::pro_se_authorized:
      j.write_fieldname("ProSeAuthorized");
      c.get<pro_se_authorized_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", "possible");
      break;
    case types::srvcc_operation_not_possible:
      j.write_str("SRVCCOperationNotPossible", "notPossible");
      break;
    case types::v2xservices_authorized:
      j.write_fieldname("V2XServicesAuthorized");
      c.get<v2xservices_authorized_s>().to_json(j);
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      j.write_fieldname("UESidelinkAggregateMaximumBitrate");
      c.get<ue_sidelink_aggregate_maximum_bitrate_s>().to_json(j);
      break;
    case types::nrue_security_cap:
      j.write_fieldname("NRUESecurityCapabilities");
      c.get<nrue_security_cap_s>().to_json(j);
      break;
    case types::aerial_uesubscription_info:
      j.write_str("AerialUEsubscriptionInformation", c.get<aerial_uesubscription_info_e>().to_string());
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true> >().pack(bref)));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::cs_fallback_ind:
      HANDLE_CODE(c.get<cs_fallback_ind_e>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().pack(bref));
      break;
    case types::registered_lai:
      HANDLE_CODE(c.get<lai_s>().pack(bref));
      break;
    case types::add_cs_fallback_ind:
      HANDLE_CODE(c.get<add_cs_fallback_ind_e>().pack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::srvcc_operation_not_possible:
      HANDLE_CODE(c.get<srvcc_operation_not_possible_e>().pack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().pack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().pack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().pack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true> >().unpack(bref)));
      break;
    case types::subscriber_profile_idfor_rfp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::ueaggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::cs_fallback_ind:
      HANDLE_CODE(c.get<cs_fallback_ind_e>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::csg_membership_status:
      HANDLE_CODE(c.get<csg_membership_status_e>().unpack(bref));
      break;
    case types::registered_lai:
      HANDLE_CODE(c.get<lai_s>().unpack(bref));
      break;
    case types::add_cs_fallback_ind:
      HANDLE_CODE(c.get<add_cs_fallback_ind_e>().unpack(bref));
      break;
    case types::pro_se_authorized:
      HANDLE_CODE(c.get<pro_se_authorized_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::srvcc_operation_not_possible:
      HANDLE_CODE(c.get<srvcc_operation_not_possible_e>().unpack(bref));
      break;
    case types::v2xservices_authorized:
      HANDLE_CODE(c.get<v2xservices_authorized_s>().unpack(bref));
      break;
    case types::ue_sidelink_aggregate_maximum_bitrate:
      HANDLE_CODE(c.get<ue_sidelink_aggregate_maximum_bitrate_s>().unpack(bref));
      break;
    case types::nrue_security_cap:
      HANDLE_CODE(c.get<nrue_security_cap_s>().unpack(bref));
      break;
    case types::aerial_uesubscription_info:
      HANDLE_CODE(c.get<aerial_uesubscription_info_e>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "BIT STRING",
                                  "INTEGER (1..256)",
                                  "UEAggregateMaximumBitrate",
                                  "CSFallbackIndicator",
                                  "UESecurityCapabilities",
                                  "CSGMembershipStatus",
                                  "LAI",
                                  "AdditionalCSFallbackIndicator",
                                  "ProSeAuthorized",
                                  "SRVCCOperationPossible",
                                  "SRVCCOperationNotPossible",
                                  "V2XServicesAuthorized",
                                  "UESidelinkAggregateMaximumBitrate",
                                  "NRUESecurityCapabilities",
                                  "AerialUEsubscriptionInformation",
                                  "BIT STRING"};
  return convert_enum_idx(options, 18, value, "ue_context_mod_request_ies_o::value_c::types");
}

// UEContextModificationResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 58};
  return map_enum_number(options, 3, idx, "id");
}
bool ue_context_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_mod_resp_ies_o::value_c ue_context_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c::value_c(const ue_context_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c&
ue_context_mod_resp_ies_o::value_c::operator=(const ue_context_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_mod_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_mod_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 3, value, "ue_context_mod_resp_ies_o::value_c::types");
}

// UEContextReleaseCommand-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {99, 2};
  return map_enum_number(options, 2, idx, "id");
}
bool ue_context_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {99, 2};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 99:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_release_cmd_ies_o::value_c ue_context_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 99:
      ret.set(value_c::types::ue_s1ap_ids);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 99:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_s1ap_ids:
      c.destroy<ue_s1ap_ids_c>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_s1ap_ids:
      c.init<ue_s1ap_ids_c>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c::value_c(const ue_context_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_s1ap_ids:
      c.init(other.c.get<ue_s1ap_ids_c>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c&
ue_context_release_cmd_ies_o::value_c::operator=(const ue_context_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_s1ap_ids:
      c.set(other.c.get<ue_s1ap_ids_c>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }

  return *this;
}
ue_s1ap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_s1ap_ids()
{
  assert_choice_type(types::ue_s1ap_ids, type_, "Value");
  return c.get<ue_s1ap_ids_c>();
}
cause_c& ue_context_release_cmd_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_s1ap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_s1ap_ids() const
{
  assert_choice_type(types::ue_s1ap_ids, type_, "Value");
  return c.get<ue_s1ap_ids_c>();
}
const cause_c& ue_context_release_cmd_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_s1ap_ids:
      j.write_fieldname("UE-S1AP-IDs");
      c.get<ue_s1ap_ids_c>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_s1ap_ids:
      HANDLE_CODE(c.get<ue_s1ap_ids_c>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_s1ap_ids:
      HANDLE_CODE(c.get<ue_s1ap_ids_c>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"UE-S1AP-IDs", "Cause"};
  return convert_enum_idx(options, 2, value, "ue_context_release_cmd_ies_o::value_c::types");
}
uint8_t ue_context_release_cmd_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {1};
  return map_enum_number(options, 1, value, "ue_context_release_cmd_ies_o::value_c::types");
}

// UEContextReleaseComplete-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_release_complete_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 58, 189, 213, 212, 264, 297};
  return map_enum_number(options, 8, idx, "id");
}
bool ue_context_release_complete_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 58, 189, 213, 212, 264, 297};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_complete_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    case 297:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_release_complete_ies_o::value_c ue_context_release_complete_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    case 213:
      ret.set(value_c::types::info_on_recommended_cells_and_enbs_for_paging);
      break;
    case 212:
      ret.set(value_c::types::cell_id_and_ce_level_for_ce_capable_ues);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    case 297:
      ret.set(value_c::types::time_since_secondary_node_release);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_complete_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    case 189:
      return presence_e::optional;
    case 213:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 297:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_complete_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.destroy<info_on_recommended_cells_and_enbs_for_paging_s>();
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.destroy<cell_id_and_ce_level_for_ce_capable_ues_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    case types::time_since_secondary_node_release:
      c.destroy<fixed_octstring<4, true> >();
      break;
    default:
      break;
  }
}
void ue_context_release_complete_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.init<info_on_recommended_cells_and_enbs_for_paging_s>();
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.init<cell_id_and_ce_level_for_ce_capable_ues_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::time_since_secondary_node_release:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c::value_c(const ue_context_release_complete_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_enbs_for_paging_s>());
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.init(other.c.get<cell_id_and_ce_level_for_ce_capable_ues_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::time_since_secondary_node_release:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c&
ue_context_release_complete_ies_o::value_c::operator=(const ue_context_release_complete_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_enbs_for_paging_s>());
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.set(other.c.get<cell_id_and_ce_level_for_ce_capable_ues_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::time_since_secondary_node_release:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_complete_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_release_complete_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_s& ue_context_release_complete_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
info_on_recommended_cells_and_enbs_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_enbs_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_enbs_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_enbs_for_paging_s>();
}
cell_id_and_ce_level_for_ce_capable_ues_s&
ue_context_release_complete_ies_o::value_c::cell_id_and_ce_level_for_ce_capable_ues()
{
  assert_choice_type(types::cell_id_and_ce_level_for_ce_capable_ues, type_, "Value");
  return c.get<cell_id_and_ce_level_for_ce_capable_ues_s>();
}
secondary_rat_data_usage_report_list_l&
ue_context_release_complete_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
fixed_octstring<4, true>& ue_context_release_complete_ies_o::value_c::time_since_secondary_node_release()
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_release_complete_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_s& ue_context_release_complete_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const info_on_recommended_cells_and_enbs_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_enbs_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_enbs_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_enbs_for_paging_s>();
}
const cell_id_and_ce_level_for_ce_capable_ues_s&
ue_context_release_complete_ies_o::value_c::cell_id_and_ce_level_for_ce_capable_ues() const
{
  assert_choice_type(types::cell_id_and_ce_level_for_ce_capable_ues, type_, "Value");
  return c.get<cell_id_and_ce_level_for_ce_capable_ues_s>();
}
const secondary_rat_data_usage_report_list_l&
ue_context_release_complete_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const fixed_octstring<4, true>& ue_context_release_complete_ies_o::value_c::time_since_secondary_node_release() const
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
void ue_context_release_complete_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      j.write_fieldname("InformationOnRecommendedCellsAndENBsForPaging");
      c.get<info_on_recommended_cells_and_enbs_for_paging_s>().to_json(j);
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      j.write_fieldname("CellIdentifierAndCELevelForCECapableUEs");
      c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::time_since_secondary_node_release:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_enbs_for_paging_s>().pack(bref));
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      HANDLE_CODE(c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_enbs_for_paging_s>().unpack(bref));
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      HANDLE_CODE(c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_complete_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "CriticalityDiagnostics",
                                  "UserLocationInformation",
                                  "InformationOnRecommendedCellsAndENBsForPaging",
                                  "CellIdentifierAndCELevelForCECapableUEs",
                                  "SecondaryRATDataUsageReportList",
                                  "OCTET STRING"};
  return convert_enum_idx(options, 8, value, "ue_context_release_complete_ies_o::value_c::types");
}

// UEContextReleaseRequest-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 164, 264};
  return map_enum_number(options, 5, idx, "id");
}
bool ue_context_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 164, 264};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    case 164:
      return crit_e::reject;
    case 264:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_release_request_ies_o::value_c ue_context_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 164:
      ret.set(value_c::types::gw_context_release_ind);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 164:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    default:
      break;
  }
}
void ue_context_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::gw_context_release_ind:
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c::value_c(const ue_context_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::gw_context_release_ind:
      c.init(other.c.get<gw_context_release_ind_e>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c&
ue_context_release_request_ies_o::value_c::operator=(const ue_context_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::gw_context_release_ind:
      c.set(other.c.get<gw_context_release_ind_e>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_release_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& ue_context_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
gw_context_release_ind_e& ue_context_release_request_ies_o::value_c::gw_context_release_ind()
{
  assert_choice_type(types::gw_context_release_ind, type_, "Value");
  return c.get<gw_context_release_ind_e>();
}
secondary_rat_data_usage_report_list_l&
ue_context_release_request_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_release_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& ue_context_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const gw_context_release_ind_e& ue_context_release_request_ies_o::value_c::gw_context_release_ind() const
{
  assert_choice_type(types::gw_context_release_ind, type_, "Value");
  return c.get<gw_context_release_ind_e>();
}
const secondary_rat_data_usage_report_list_l&
ue_context_release_request_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
void ue_context_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::gw_context_release_ind:
      j.write_str("GWContextReleaseIndication", "true");
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::gw_context_release_ind:
      HANDLE_CODE(c.get<gw_context_release_ind_e>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::gw_context_release_ind:
      HANDLE_CODE(c.get<gw_context_release_ind_e>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "Cause",
                                  "GWContextReleaseIndication",
                                  "SecondaryRATDataUsageReportList"};
  return convert_enum_idx(options, 5, value, "ue_context_release_request_ies_o::value_c::types");
}

// UEContextResumeFailureIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_resume_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_context_resume_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 2, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 2:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_resume_fail_ies_o::value_c ue_context_resume_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 2:
      ret.set(value_c::types::cause);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 2:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c::value_c(const ue_context_resume_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c&
ue_context_resume_fail_ies_o::value_c::operator=(const ue_context_resume_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_fail_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_resume_fail_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& ue_context_resume_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_resume_fail_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& ue_context_resume_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "ue_context_resume_fail_ies_o::value_c::types");
}

// UEContextResumeRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_resume_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 235, 245};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_context_resume_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 235, 245};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 235:
      return crit_e::reject;
    case 245:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_resume_request_ies_o::value_c ue_context_resume_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 235:
      ret.set(value_c::types::erab_failed_to_resume_list_resume_req);
      break;
    case 245:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 235:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_failed_to_resume_list_resume_req:
      c.destroy<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >();
      break;
    default:
      break;
  }
}
void ue_context_resume_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_failed_to_resume_list_resume_req:
      c.init<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >();
      break;
    case types::rrc_resume_cause:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c::value_c(const ue_context_resume_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_req:
      c.init(other.c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c&
ue_context_resume_request_ies_o::value_c::operator=(const ue_context_resume_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_req:
      c.set(other.c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_resume_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o>&
ue_context_resume_request_ies_o::value_c::erab_failed_to_resume_list_resume_req()
{
  assert_choice_type(types::erab_failed_to_resume_list_resume_req, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >();
}
rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_resume_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o>&
ue_context_resume_request_ies_o::value_c::erab_failed_to_resume_list_resume_req() const
{
  assert_choice_type(types::erab_failed_to_resume_list_resume_req, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >();
}
const rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
void ue_context_resume_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_req:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABFailedToResumeItemResumeReqIEs}}");
      break;
    case types::rrc_resume_cause:
      j.write_str("RRC-Establishment-Cause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_failed_to_resume_list_resume_req:
      HANDLE_CODE(pack_dyn_seq_of(
          bref, c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >(), 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_failed_to_resume_list_resume_req:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_req_ies_o> >(), bref, 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABFailedToResumeItemResumeReqIEs}}",
                                  "RRC-Establishment-Cause"};
  return convert_enum_idx(options, 4, value, "ue_context_resume_request_ies_o::value_c::types");
}

// UEContextResumeResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_resume_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 237, 58, 40, 283};
  return map_enum_number(options, 6, idx, "id");
}
bool ue_context_resume_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 237, 58, 40, 283};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 237:
      return crit_e::reject;
    case 58:
      return crit_e::ignore;
    case 40:
      return crit_e::reject;
    case 283:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_resume_resp_ies_o::value_c ue_context_resume_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 237:
      ret.set(value_c::types::erab_failed_to_resume_list_resume_res);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 40:
      ret.set(value_c::types::security_context);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 237:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::erab_failed_to_resume_list_resume_res:
      c.destroy<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::erab_failed_to_resume_list_resume_res:
      c.init<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::pending_data_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c::value_c(const ue_context_resume_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_res:
      c.init(other.c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c&
ue_context_resume_resp_ies_o::value_c::operator=(const ue_context_resume_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_res:
      c.set(other.c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_resume_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o>&
ue_context_resume_resp_ies_o::value_c::erab_failed_to_resume_list_resume_res()
{
  assert_choice_type(types::erab_failed_to_resume_list_resume_res, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >();
}
crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
security_context_s& ue_context_resume_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
pending_data_ind_e& ue_context_resume_resp_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_resume_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o>&
ue_context_resume_resp_ies_o::value_c::erab_failed_to_resume_list_resume_res() const
{
  assert_choice_type(types::erab_failed_to_resume_list_resume_res, type_, "Value");
  return c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >();
}
const crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const security_context_s& ue_context_resume_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const pending_data_ind_e& ue_context_resume_resp_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
void ue_context_resume_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::erab_failed_to_resume_list_resume_res:
      j.write_fieldname("E-RAB-IE-ContainerList{{E-RABFailedToResumeItemResumeResIEs}}");
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_failed_to_resume_list_resume_res:
      HANDLE_CODE(pack_dyn_seq_of(
          bref, c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::erab_failed_to_resume_list_resume_res:
      HANDLE_CODE(unpack_dyn_seq_of(
          c.get<erab_ie_container_list_l<erab_failed_to_resume_item_resume_res_ies_o> >(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "E-RAB-IE-ContainerList{{E-RABFailedToResumeItemResumeResIEs}}",
                                  "CriticalityDiagnostics",
                                  "SecurityContext",
                                  "PendingDataIndication"};
  return convert_enum_idx(options, 6, value, "ue_context_resume_resp_ies_o::value_c::types");
}

// UEContextSuspendRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_suspend_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 213, 212, 264, 189, 297};
  return map_enum_number(options, 7, idx, "id");
}
bool ue_context_suspend_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 213, 212, 264, 189, 297};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 213:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 264:
      return crit_e::ignore;
    case 189:
      return crit_e::ignore;
    case 297:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_suspend_request_ies_o::value_c ue_context_suspend_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 213:
      ret.set(value_c::types::info_on_recommended_cells_and_enbs_for_paging);
      break;
    case 212:
      ret.set(value_c::types::cell_id_and_ce_level_for_ce_capable_ues);
      break;
    case 264:
      ret.set(value_c::types::secondary_rat_data_usage_report_list);
      break;
    case 189:
      ret.set(value_c::types::user_location_info);
      break;
    case 297:
      ret.set(value_c::types::time_since_secondary_node_release);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 213:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 189:
      return presence_e::optional;
    case 297:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.destroy<info_on_recommended_cells_and_enbs_for_paging_s>();
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.destroy<cell_id_and_ce_level_for_ce_capable_ues_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.destroy<secondary_rat_data_usage_report_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_s>();
      break;
    case types::time_since_secondary_node_release:
      c.destroy<fixed_octstring<4, true> >();
      break;
    default:
      break;
  }
}
void ue_context_suspend_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.init<info_on_recommended_cells_and_enbs_for_paging_s>();
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.init<cell_id_and_ce_level_for_ce_capable_ues_s>();
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init<secondary_rat_data_usage_report_list_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_s>();
      break;
    case types::time_since_secondary_node_release:
      c.init<fixed_octstring<4, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c::value_c(const ue_context_suspend_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_enbs_for_paging_s>());
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.init(other.c.get<cell_id_and_ce_level_for_ce_capable_ues_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.init(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_s>());
      break;
    case types::time_since_secondary_node_release:
      c.init(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c&
ue_context_suspend_request_ies_o::value_c::operator=(const ue_context_suspend_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_enbs_for_paging_s>());
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      c.set(other.c.get<cell_id_and_ce_level_for_ce_capable_ues_s>());
      break;
    case types::secondary_rat_data_usage_report_list:
      c.set(other.c.get<secondary_rat_data_usage_report_list_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_s>());
      break;
    case types::time_since_secondary_node_release:
      c.set(other.c.get<fixed_octstring<4, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_suspend_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
info_on_recommended_cells_and_enbs_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_enbs_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_enbs_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_enbs_for_paging_s>();
}
cell_id_and_ce_level_for_ce_capable_ues_s&
ue_context_suspend_request_ies_o::value_c::cell_id_and_ce_level_for_ce_capable_ues()
{
  assert_choice_type(types::cell_id_and_ce_level_for_ce_capable_ues, type_, "Value");
  return c.get<cell_id_and_ce_level_for_ce_capable_ues_s>();
}
secondary_rat_data_usage_report_list_l&
ue_context_suspend_request_ies_o::value_c::secondary_rat_data_usage_report_list()
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
user_location_info_s& ue_context_suspend_request_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
fixed_octstring<4, true>& ue_context_suspend_request_ies_o::value_c::time_since_secondary_node_release()
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_suspend_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const info_on_recommended_cells_and_enbs_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_enbs_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_enbs_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_enbs_for_paging_s>();
}
const cell_id_and_ce_level_for_ce_capable_ues_s&
ue_context_suspend_request_ies_o::value_c::cell_id_and_ce_level_for_ce_capable_ues() const
{
  assert_choice_type(types::cell_id_and_ce_level_for_ce_capable_ues, type_, "Value");
  return c.get<cell_id_and_ce_level_for_ce_capable_ues_s>();
}
const secondary_rat_data_usage_report_list_l&
ue_context_suspend_request_ies_o::value_c::secondary_rat_data_usage_report_list() const
{
  assert_choice_type(types::secondary_rat_data_usage_report_list, type_, "Value");
  return c.get<secondary_rat_data_usage_report_list_l>();
}
const user_location_info_s& ue_context_suspend_request_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_s>();
}
const fixed_octstring<4, true>& ue_context_suspend_request_ies_o::value_c::time_since_secondary_node_release() const
{
  assert_choice_type(types::time_since_secondary_node_release, type_, "Value");
  return c.get<fixed_octstring<4, true> >();
}
void ue_context_suspend_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      j.write_fieldname("InformationOnRecommendedCellsAndENBsForPaging");
      c.get<info_on_recommended_cells_and_enbs_for_paging_s>().to_json(j);
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      j.write_fieldname("CellIdentifierAndCELevelForCECapableUEs");
      c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report_list:
      j.start_array("SecondaryRATDataUsageReportList");
      for (const auto& e1 : c.get<secondary_rat_data_usage_report_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_s>().to_json(j);
      break;
    case types::time_since_secondary_node_release:
      j.write_str("OCTET STRING", c.get<fixed_octstring<4, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_enbs_for_paging_s>().pack(bref));
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      HANDLE_CODE(c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<secondary_rat_data_usage_report_list_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().pack(bref));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::info_on_recommended_cells_and_enbs_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_enbs_for_paging_s>().unpack(bref));
      break;
    case types::cell_id_and_ce_level_for_ce_capable_ues:
      HANDLE_CODE(c.get<cell_id_and_ce_level_for_ce_capable_ues_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<secondary_rat_data_usage_report_list_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_s>().unpack(bref));
      break;
    case types::time_since_secondary_node_release:
      HANDLE_CODE((c.get<fixed_octstring<4, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "InformationOnRecommendedCellsAndENBsForPaging",
                                  "CellIdentifierAndCELevelForCECapableUEs",
                                  "SecondaryRATDataUsageReportList",
                                  "UserLocationInformation",
                                  "OCTET STRING"};
  return convert_enum_idx(options, 7, value, "ue_context_suspend_request_ies_o::value_c::types");
}

// UEContextSuspendResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_context_suspend_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 58, 40};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_context_suspend_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 58, 40};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 40:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_context_suspend_resp_ies_o::value_c ue_context_suspend_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 40:
      ret.set(value_c::types::security_context);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c::value_c(const ue_context_suspend_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c&
ue_context_suspend_resp_ies_o::value_c::operator=(const ue_context_suspend_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_context_suspend_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_context_suspend_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
void ue_context_suspend_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "CriticalityDiagnostics", "SecurityContext"};
  return convert_enum_idx(options, 4, value, "ue_context_suspend_resp_ies_o::value_c::types");
}

// UEInformationTransferIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {96, 252, 74, 278, 283};
  return map_enum_number(options, 5, idx, "id");
}
bool ue_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {96, 252, 74, 278, 283};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 96:
      return crit_e::reject;
    case 252:
      return crit_e::ignore;
    case 74:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_info_transfer_ies_o::value_c ue_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 96:
      ret.set(value_c::types::s_tmsi);
      break;
    case 252:
      ret.set(value_c::types::ue_level_qos_params);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 278:
      ret.set(value_c::types::subscription_based_ue_differentiation_info);
      break;
    case 283:
      ret.set(value_c::types::pending_data_ind);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 96:
      return presence_e::mandatory;
    case 252:
      return presence_e::optional;
    case 74:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_info_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s_tmsi:
      c.destroy<s_tmsi_s>();
      break;
    case types::ue_level_qos_params:
      c.destroy<erab_level_qos_params_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.destroy<subscription_based_ue_differentiation_info_s>();
      break;
    default:
      break;
  }
}
void ue_info_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_tmsi:
      c.init<s_tmsi_s>();
      break;
    case types::ue_level_qos_params:
      c.init<erab_level_qos_params_s>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init<subscription_based_ue_differentiation_info_s>();
      break;
    case types::pending_data_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c::value_c(const ue_info_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_tmsi:
      c.init(other.c.get<s_tmsi_s>());
      break;
    case types::ue_level_qos_params:
      c.init(other.c.get<erab_level_qos_params_s>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.init(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::pending_data_ind:
      c.init(other.c.get<pending_data_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c&
ue_info_transfer_ies_o::value_c::operator=(const ue_info_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_tmsi:
      c.set(other.c.get<s_tmsi_s>());
      break;
    case types::ue_level_qos_params:
      c.set(other.c.get<erab_level_qos_params_s>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::subscription_based_ue_differentiation_info:
      c.set(other.c.get<subscription_based_ue_differentiation_info_s>());
      break;
    case types::pending_data_ind:
      c.set(other.c.get<pending_data_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }

  return *this;
}
s_tmsi_s& ue_info_transfer_ies_o::value_c::s_tmsi()
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
erab_level_qos_params_s& ue_info_transfer_ies_o::value_c::ue_level_qos_params()
{
  assert_choice_type(types::ue_level_qos_params, type_, "Value");
  return c.get<erab_level_qos_params_s>();
}
unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
subscription_based_ue_differentiation_info_s&
ue_info_transfer_ies_o::value_c::subscription_based_ue_differentiation_info()
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
pending_data_ind_e& ue_info_transfer_ies_o::value_c::pending_data_ind()
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
const s_tmsi_s& ue_info_transfer_ies_o::value_c::s_tmsi() const
{
  assert_choice_type(types::s_tmsi, type_, "Value");
  return c.get<s_tmsi_s>();
}
const erab_level_qos_params_s& ue_info_transfer_ies_o::value_c::ue_level_qos_params() const
{
  assert_choice_type(types::ue_level_qos_params, type_, "Value");
  return c.get<erab_level_qos_params_s>();
}
const unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const subscription_based_ue_differentiation_info_s&
ue_info_transfer_ies_o::value_c::subscription_based_ue_differentiation_info() const
{
  assert_choice_type(types::subscription_based_ue_differentiation_info, type_, "Value");
  return c.get<subscription_based_ue_differentiation_info_s>();
}
const pending_data_ind_e& ue_info_transfer_ies_o::value_c::pending_data_ind() const
{
  assert_choice_type(types::pending_data_ind, type_, "Value");
  return c.get<pending_data_ind_e>();
}
void ue_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_tmsi:
      j.write_fieldname("S-TMSI");
      c.get<s_tmsi_s>().to_json(j);
      break;
    case types::ue_level_qos_params:
      j.write_fieldname("E-RABLevelQoSParameters");
      c.get<erab_level_qos_params_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::subscription_based_ue_differentiation_info:
      j.write_fieldname("Subscription-Based-UE-DifferentiationInfo");
      c.get<subscription_based_ue_differentiation_info_s>().to_json(j);
      break;
    case types::pending_data_ind:
      j.write_str("PendingDataIndication", "true");
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().pack(bref));
      break;
    case types::ue_level_qos_params:
      HANDLE_CODE(c.get<erab_level_qos_params_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().pack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_tmsi:
      HANDLE_CODE(c.get<s_tmsi_s>().unpack(bref));
      break;
    case types::ue_level_qos_params:
      HANDLE_CODE(c.get<erab_level_qos_params_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::subscription_based_ue_differentiation_info:
      HANDLE_CODE(c.get<subscription_based_ue_differentiation_info_s>().unpack(bref));
      break;
    case types::pending_data_ind:
      HANDLE_CODE(c.get<pending_data_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"S-TMSI",
                                  "E-RABLevelQoSParameters",
                                  "OCTET STRING",
                                  "Subscription-Based-UE-DifferentiationInfo",
                                  "PendingDataIndication"};
  return convert_enum_idx(options, 5, value, "ue_info_transfer_ies_o::value_c::types");
}

// UERadioCapabilityMatchRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_radio_cap_match_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 74};
  return map_enum_number(options, 3, idx, "id");
}
bool ue_radio_cap_match_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 74};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_match_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 74:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_radio_cap_match_request_ies_o::value_c ue_radio_cap_match_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 74:
      ret.set(value_c::types::ue_radio_cap);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_match_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 74:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_match_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void ue_radio_cap_match_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
  }
}
ue_radio_cap_match_request_ies_o::value_c::value_c(const ue_radio_cap_match_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
  }
}
ue_radio_cap_match_request_ies_o::value_c&
ue_radio_cap_match_request_ies_o::value_c::operator=(const ue_radio_cap_match_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_match_request_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_radio_cap_match_request_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& ue_radio_cap_match_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint64_t& ue_radio_cap_match_request_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_radio_cap_match_request_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& ue_radio_cap_match_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void ue_radio_cap_match_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_match_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_match_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)", "INTEGER (0..16777215)", "OCTET STRING"};
  return convert_enum_idx(options, 3, value, "ue_radio_cap_match_request_ies_o::value_c::types");
}

// UERadioCapabilityMatchResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ue_radio_cap_match_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 169, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool ue_radio_cap_match_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 169, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_match_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 169:
      return crit_e::reject;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ue_radio_cap_match_resp_ies_o::value_c ue_radio_cap_match_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 169:
      ret.set(value_c::types::voice_support_match_ind);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_match_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 169:
      return presence_e::mandatory;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_match_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_match_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::voice_support_match_ind:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
  }
}
ue_radio_cap_match_resp_ies_o::value_c::value_c(const ue_radio_cap_match_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::voice_support_match_ind:
      c.init(other.c.get<voice_support_match_ind_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
  }
}
ue_radio_cap_match_resp_ies_o::value_c&
ue_radio_cap_match_resp_ies_o::value_c::operator=(const ue_radio_cap_match_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::voice_support_match_ind:
      c.set(other.c.get<voice_support_match_ind_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_match_resp_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ue_radio_cap_match_resp_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
voice_support_match_ind_e& ue_radio_cap_match_resp_ies_o::value_c::voice_support_match_ind()
{
  assert_choice_type(types::voice_support_match_ind, type_, "Value");
  return c.get<voice_support_match_ind_e>();
}
crit_diagnostics_s& ue_radio_cap_match_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_radio_cap_match_resp_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ue_radio_cap_match_resp_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const voice_support_match_ind_e& ue_radio_cap_match_resp_ies_o::value_c::voice_support_match_ind() const
{
  assert_choice_type(types::voice_support_match_ind, type_, "Value");
  return c.get<voice_support_match_ind_e>();
}
const crit_diagnostics_s& ue_radio_cap_match_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_match_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::voice_support_match_ind:
      j.write_str("VoiceSupportMatchIndicator", c.get<voice_support_match_ind_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_match_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::voice_support_match_ind:
      HANDLE_CODE(c.get<voice_support_match_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::voice_support_match_ind:
      HANDLE_CODE(c.get<voice_support_match_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_match_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_match_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "VoiceSupportMatchIndicator", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "ue_radio_cap_match_resp_ies_o::value_c::types");
}

// UplinkNASTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ul_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 26, 100, 67, 155, 184, 186, 288};
  return map_enum_number(options, 9, idx, "id");
}
bool ul_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 26, 100, 67, 155, 184, 186, 288};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 100:
      return crit_e::ignore;
    case 67:
      return crit_e::ignore;
    case 155:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ul_nas_transport_ies_o::value_c ul_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 26:
      ret.set(value_c::types::nas_pdu);
      break;
    case 100:
      ret.set(value_c::types::eutran_cgi);
      break;
    case 67:
      ret.set(value_c::types::tai);
      break;
    case 155:
      ret.set(value_c::types::gw_transport_layer_address);
      break;
    case 184:
      ret.set(value_c::types::sipto_l_gw_transport_layer_address);
      break;
    case 186:
      ret.set(value_c::types::lhn_id);
      break;
    case 288:
      ret.set(value_c::types::ps_cell_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ul_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 67:
      return presence_e::mandatory;
    case 155:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 288:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::eutran_cgi:
      c.destroy<eutran_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::gw_transport_layer_address:
      c.destroy<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.destroy<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::lhn_id:
      c.destroy<bounded_octstring<32, 256, true> >();
      break;
    case types::ps_cell_info:
      c.destroy<ps_cell_info_s>();
      break;
    default:
      break;
  }
}
void ul_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::eutran_cgi:
      c.init<eutran_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::gw_transport_layer_address:
      c.init<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.init<bounded_bitstring<1, 160, true, true> >();
      break;
    case types::lhn_id:
      c.init<bounded_octstring<32, 256, true> >();
      break;
    case types::ps_cell_info:
      c.init<ps_cell_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c::value_c(const ul_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::eutran_cgi:
      c.init(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::gw_transport_layer_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::lhn_id:
      c.init(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::ps_cell_info:
      c.init(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c&
ul_nas_transport_ies_o::value_c::operator=(const ul_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::eutran_cgi:
      c.set(other.c.get<eutran_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::gw_transport_layer_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::sipto_l_gw_transport_layer_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true> >());
      break;
    case types::lhn_id:
      c.set(other.c.get<bounded_octstring<32, 256, true> >());
      break;
    case types::ps_cell_info:
      c.set(other.c.get<ps_cell_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_nas_transport_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ul_nas_transport_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
eutran_cgi_s& ul_nas_transport_ies_o::value_c::eutran_cgi()
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
tai_s& ul_nas_transport_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
bounded_bitstring<1, 160, true, true>& ul_nas_transport_ies_o::value_c::gw_transport_layer_address()
{
  assert_choice_type(types::gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
bounded_bitstring<1, 160, true, true>& ul_nas_transport_ies_o::value_c::sipto_l_gw_transport_layer_address()
{
  assert_choice_type(types::sipto_l_gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
bounded_octstring<32, 256, true>& ul_nas_transport_ies_o::value_c::lhn_id()
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
ps_cell_info_s& ul_nas_transport_ies_o::value_c::ps_cell_info()
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ul_nas_transport_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const eutran_cgi_s& ul_nas_transport_ies_o::value_c::eutran_cgi() const
{
  assert_choice_type(types::eutran_cgi, type_, "Value");
  return c.get<eutran_cgi_s>();
}
const tai_s& ul_nas_transport_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const bounded_bitstring<1, 160, true, true>& ul_nas_transport_ies_o::value_c::gw_transport_layer_address() const
{
  assert_choice_type(types::gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
const bounded_bitstring<1, 160, true, true>& ul_nas_transport_ies_o::value_c::sipto_l_gw_transport_layer_address() const
{
  assert_choice_type(types::sipto_l_gw_transport_layer_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true> >();
}
const bounded_octstring<32, 256, true>& ul_nas_transport_ies_o::value_c::lhn_id() const
{
  assert_choice_type(types::lhn_id, type_, "Value");
  return c.get<bounded_octstring<32, 256, true> >();
}
const ps_cell_info_s& ul_nas_transport_ies_o::value_c::ps_cell_info() const
{
  assert_choice_type(types::ps_cell_info, type_, "Value");
  return c.get<ps_cell_info_s>();
}
void ul_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::eutran_cgi:
      j.write_fieldname("EUTRAN-CGI");
      c.get<eutran_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::gw_transport_layer_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true> >().to_string());
      break;
    case types::sipto_l_gw_transport_layer_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true> >().to_string());
      break;
    case types::lhn_id:
      j.write_str("OCTET STRING", c.get<bounded_octstring<32, 256, true> >().to_string());
      break;
    case types::ps_cell_info:
      j.write_fieldname("PSCellInformation");
      c.get<ps_cell_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().pack(bref)));
      break;
    case types::sipto_l_gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().pack(bref)));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().pack(bref)));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::eutran_cgi:
      HANDLE_CODE(c.get<eutran_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().unpack(bref)));
      break;
    case types::sipto_l_gw_transport_layer_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true> >().unpack(bref)));
      break;
    case types::lhn_id:
      HANDLE_CODE((c.get<bounded_octstring<32, 256, true> >().unpack(bref)));
      break;
    case types::ps_cell_info:
      HANDLE_CODE(c.get<ps_cell_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "OCTET STRING",
                                  "EUTRAN-CGI",
                                  "TAI",
                                  "BIT STRING",
                                  "BIT STRING",
                                  "OCTET STRING",
                                  "PSCellInformation"};
  return convert_enum_idx(options, 9, value, "ul_nas_transport_ies_o::value_c::types");
}

// UplinkNonUEAssociatedLPPaTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ul_non_ueassociated_lp_pa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {148, 147};
  return map_enum_number(options, 2, idx, "id");
}
bool ul_non_ueassociated_lp_pa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {148, 147};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_non_ueassociated_lp_pa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 148:
      return crit_e::reject;
    case 147:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ul_non_ueassociated_lp_pa_transport_ies_o::value_c
ul_non_ueassociated_lp_pa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 148:
      ret.set(value_c::types::routing_id);
      break;
    case 147:
      ret.set(value_c::types::lp_pa_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ul_non_ueassociated_lp_pa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 148:
      return presence_e::mandatory;
    case 147:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_non_ueassociated_lp_pa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::lp_pa_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void ul_non_ueassociated_lp_pa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      break;
    case types::lp_pa_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
ul_non_ueassociated_lp_pa_transport_ies_o::value_c::value_c(
    const ul_non_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
ul_non_ueassociated_lp_pa_transport_ies_o::value_c& ul_non_ueassociated_lp_pa_transport_ies_o::value_c::operator=(
    const ul_non_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }

  return *this;
}
uint16_t& ul_non_ueassociated_lp_pa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ul_non_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu()
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint16_t& ul_non_ueassociated_lp_pa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ul_non_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu() const
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void ul_non_ueassociated_lp_pa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_non_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..255)", "OCTET STRING"};
  return convert_enum_idx(options, 2, value, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c::types");
}
uint8_t ul_non_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t options[] = {0};
  return map_enum_number(options, 1, value, "ul_non_ueassociated_lp_pa_transport_ies_o::value_c::types");
}

// UplinkS1cdma2000tunnellingIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ul_s1cdma2000tunnelling_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 71, 72, 84, 102, 97, 70, 140};
  return map_enum_number(options, 9, idx, "id");
}
bool ul_s1cdma2000tunnelling_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 71, 72, 84, 102, 97, 70, 140};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_s1cdma2000tunnelling_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 72:
      return crit_e::reject;
    case 84:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 97:
      return crit_e::reject;
    case 70:
      return crit_e::reject;
    case 140:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ul_s1cdma2000tunnelling_ies_o::value_c ul_s1cdma2000tunnelling_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 71:
      ret.set(value_c::types::cdma2000_rat_type);
      break;
    case 72:
      ret.set(value_c::types::cdma2000_sector_id);
      break;
    case 84:
      ret.set(value_c::types::cdma2000_ho_required_ind);
      break;
    case 102:
      ret.set(value_c::types::cdma2000_one_xsrvcc_info);
      break;
    case 97:
      ret.set(value_c::types::cdma2000_one_xrand);
      break;
    case 70:
      ret.set(value_c::types::cdma2000_pdu);
      break;
    case 140:
      ret.set(value_c::types::eutran_round_trip_delay_estimation_info);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ul_s1cdma2000tunnelling_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 71:
      return presence_e::mandatory;
    case 72:
      return presence_e::mandatory;
    case 84:
      return presence_e::optional;
    case 102:
      return presence_e::optional;
    case 97:
      return presence_e::optional;
    case 70:
      return presence_e::mandatory;
    case 140:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_s1cdma2000tunnelling_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cdma2000_sector_id:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::cdma2000_one_xsrvcc_info:
      c.destroy<cdma2000_one_xsrvcc_info_s>();
      break;
    case types::cdma2000_one_xrand:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::cdma2000_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void ul_s1cdma2000tunnelling_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::cdma2000_rat_type:
      break;
    case types::cdma2000_sector_id:
      c.init<unbounded_octstring<true> >();
      break;
    case types::cdma2000_ho_required_ind:
      break;
    case types::cdma2000_one_xsrvcc_info:
      c.init<cdma2000_one_xsrvcc_info_s>();
      break;
    case types::cdma2000_one_xrand:
      c.init<unbounded_octstring<true> >();
      break;
    case types::cdma2000_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::eutran_round_trip_delay_estimation_info:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
  }
}
ul_s1cdma2000tunnelling_ies_o::value_c::value_c(const ul_s1cdma2000tunnelling_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cdma2000_rat_type:
      c.init(other.c.get<cdma2000_rat_type_e>());
      break;
    case types::cdma2000_sector_id:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cdma2000_ho_required_ind:
      c.init(other.c.get<cdma2000_ho_required_ind_e>());
      break;
    case types::cdma2000_one_xsrvcc_info:
      c.init(other.c.get<cdma2000_one_xsrvcc_info_s>());
      break;
    case types::cdma2000_one_xrand:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cdma2000_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::eutran_round_trip_delay_estimation_info:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
  }
}
ul_s1cdma2000tunnelling_ies_o::value_c&
ul_s1cdma2000tunnelling_ies_o::value_c::operator=(const ul_s1cdma2000tunnelling_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cdma2000_rat_type:
      c.set(other.c.get<cdma2000_rat_type_e>());
      break;
    case types::cdma2000_sector_id:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cdma2000_ho_required_ind:
      c.set(other.c.get<cdma2000_ho_required_ind_e>());
      break;
    case types::cdma2000_one_xsrvcc_info:
      c.set(other.c.get<cdma2000_one_xsrvcc_info_s>());
      break;
    case types::cdma2000_one_xrand:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::cdma2000_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::eutran_round_trip_delay_estimation_info:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_s1cdma2000tunnelling_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ul_s1cdma2000tunnelling_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
cdma2000_rat_type_e& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_rat_type()
{
  assert_choice_type(types::cdma2000_rat_type, type_, "Value");
  return c.get<cdma2000_rat_type_e>();
}
unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_sector_id()
{
  assert_choice_type(types::cdma2000_sector_id, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
cdma2000_ho_required_ind_e& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_ho_required_ind()
{
  assert_choice_type(types::cdma2000_ho_required_ind, type_, "Value");
  return c.get<cdma2000_ho_required_ind_e>();
}
cdma2000_one_xsrvcc_info_s& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_one_xsrvcc_info()
{
  assert_choice_type(types::cdma2000_one_xsrvcc_info, type_, "Value");
  return c.get<cdma2000_one_xsrvcc_info_s>();
}
unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_one_xrand()
{
  assert_choice_type(types::cdma2000_one_xrand, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_pdu()
{
  assert_choice_type(types::cdma2000_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
uint16_t& ul_s1cdma2000tunnelling_ies_o::value_c::eutran_round_trip_delay_estimation_info()
{
  assert_choice_type(types::eutran_round_trip_delay_estimation_info, type_, "Value");
  return c.get<uint16_t>();
}
const uint64_t& ul_s1cdma2000tunnelling_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ul_s1cdma2000tunnelling_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const cdma2000_rat_type_e& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_rat_type() const
{
  assert_choice_type(types::cdma2000_rat_type, type_, "Value");
  return c.get<cdma2000_rat_type_e>();
}
const unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_sector_id() const
{
  assert_choice_type(types::cdma2000_sector_id, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const cdma2000_ho_required_ind_e& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_ho_required_ind() const
{
  assert_choice_type(types::cdma2000_ho_required_ind, type_, "Value");
  return c.get<cdma2000_ho_required_ind_e>();
}
const cdma2000_one_xsrvcc_info_s& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_one_xsrvcc_info() const
{
  assert_choice_type(types::cdma2000_one_xsrvcc_info, type_, "Value");
  return c.get<cdma2000_one_xsrvcc_info_s>();
}
const unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_one_xrand() const
{
  assert_choice_type(types::cdma2000_one_xrand, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const unbounded_octstring<true>& ul_s1cdma2000tunnelling_ies_o::value_c::cdma2000_pdu() const
{
  assert_choice_type(types::cdma2000_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint16_t& ul_s1cdma2000tunnelling_ies_o::value_c::eutran_round_trip_delay_estimation_info() const
{
  assert_choice_type(types::eutran_round_trip_delay_estimation_info, type_, "Value");
  return c.get<uint16_t>();
}
void ul_s1cdma2000tunnelling_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::cdma2000_rat_type:
      j.write_str("Cdma2000RATType", c.get<cdma2000_rat_type_e>().to_string());
      break;
    case types::cdma2000_sector_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::cdma2000_ho_required_ind:
      j.write_str("Cdma2000HORequiredIndication", "true");
      break;
    case types::cdma2000_one_xsrvcc_info:
      j.write_fieldname("Cdma2000OneXSRVCCInfo");
      c.get<cdma2000_one_xsrvcc_info_s>().to_json(j);
      break;
    case types::cdma2000_one_xrand:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::cdma2000_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::eutran_round_trip_delay_estimation_info:
      j.write_int("INTEGER (0..2047)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_s1cdma2000tunnelling_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cdma2000_rat_type:
      HANDLE_CODE(c.get<cdma2000_rat_type_e>().pack(bref));
      break;
    case types::cdma2000_sector_id:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::cdma2000_ho_required_ind:
      HANDLE_CODE(c.get<cdma2000_ho_required_ind_e>().pack(bref));
      break;
    case types::cdma2000_one_xsrvcc_info:
      HANDLE_CODE(c.get<cdma2000_one_xsrvcc_info_s>().pack(bref));
      break;
    case types::cdma2000_one_xrand:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::cdma2000_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::eutran_round_trip_delay_estimation_info:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)2047u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_s1cdma2000tunnelling_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::cdma2000_rat_type:
      HANDLE_CODE(c.get<cdma2000_rat_type_e>().unpack(bref));
      break;
    case types::cdma2000_sector_id:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::cdma2000_ho_required_ind:
      HANDLE_CODE(c.get<cdma2000_ho_required_ind_e>().unpack(bref));
      break;
    case types::cdma2000_one_xsrvcc_info:
      HANDLE_CODE(c.get<cdma2000_one_xsrvcc_info_s>().unpack(bref));
      break;
    case types::cdma2000_one_xrand:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::cdma2000_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::eutran_round_trip_delay_estimation_info:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)2047u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ul_s1cdma2000tunnelling_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_s1cdma2000tunnelling_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..4294967295)",
                                  "INTEGER (0..16777215)",
                                  "Cdma2000RATType",
                                  "OCTET STRING",
                                  "Cdma2000HORequiredIndication",
                                  "Cdma2000OneXSRVCCInfo",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "INTEGER (0..2047)"};
  return convert_enum_idx(options, 9, value, "ul_s1cdma2000tunnelling_ies_o::value_c::types");
}

// UplinkUEAssociatedLPPaTransport-IEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t ul_ueassociated_lp_pa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {0, 8, 148, 147};
  return map_enum_number(options, 4, idx, "id");
}
bool ul_ueassociated_lp_pa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {0, 8, 148, 147};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ueassociated_lp_pa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 0:
      return crit_e::reject;
    case 8:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 147:
      return crit_e::reject;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
ul_ueassociated_lp_pa_transport_ies_o::value_c ul_ueassociated_lp_pa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 0:
      ret.set(value_c::types::mme_ue_s1ap_id);
      break;
    case 8:
      ret.set(value_c::types::enb_ue_s1ap_id);
      break;
    case 148:
      ret.set(value_c::types::routing_id);
      break;
    case 147:
      ret.set(value_c::types::lp_pa_pdu);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e ul_ueassociated_lp_pa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 0:
      return presence_e::mandatory;
    case 8:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 147:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ueassociated_lp_pa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::lp_pa_pdu:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void ul_ueassociated_lp_pa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mme_ue_s1ap_id:
      break;
    case types::enb_ue_s1ap_id:
      break;
    case types::routing_id:
      break;
    case types::lp_pa_pdu:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
ul_ueassociated_lp_pa_transport_ies_o::value_c::value_c(const ul_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
  }
}
ul_ueassociated_lp_pa_transport_ies_o::value_c&
ul_ueassociated_lp_pa_transport_ies_o::value_c::operator=(const ul_ueassociated_lp_pa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mme_ue_s1ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::mme_ue_s1ap_id()
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint32_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::enb_ue_s1ap_id()
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
uint16_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ul_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu()
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
const uint64_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::mme_ue_s1ap_id() const
{
  assert_choice_type(types::mme_ue_s1ap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint32_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::enb_ue_s1ap_id() const
{
  assert_choice_type(types::enb_ue_s1ap_id, type_, "Value");
  return c.get<uint32_t>();
}
const uint16_t& ul_ueassociated_lp_pa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ul_ueassociated_lp_pa_transport_ies_o::value_c::lp_pa_pdu() const
{
  assert_choice_type(types::lp_pa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true> >();
}
void ul_ueassociated_lp_pa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mme_ue_s1ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::enb_ue_s1ap_id:
      j.write_int("INTEGER (0..16777215)", c.get<uint32_t>());
      break;
    case types::routing_id:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::lp_pa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ueassociated_lp_pa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ueassociated_lp_pa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mme_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::enb_ue_s1ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)16777215u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::lp_pa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ueassociated_lp_pa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ueassociated_lp_pa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {
      "INTEGER (0..4294967295)", "INTEGER (0..16777215)", "INTEGER (0..255)", "OCTET STRING"};
  return convert_enum_idx(options, 4, value, "ul_ueassociated_lp_pa_transport_ies_o::value_c::types");
}

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t write_replace_warning_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {111, 112, 113, 114, 144, 115, 116, 117, 118, 119, 142, 286};
  return map_enum_number(options, 12, idx, "id");
}
bool write_replace_warning_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {111, 112, 113, 114, 144, 115, 116, 117, 118, 119, 142, 286};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::reject;
    case 112:
      return crit_e::reject;
    case 113:
      return crit_e::ignore;
    case 114:
      return crit_e::reject;
    case 144:
      return crit_e::reject;
    case 115:
      return crit_e::reject;
    case 116:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 119:
      return crit_e::ignore;
    case 142:
      return crit_e::reject;
    case 286:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
write_replace_warning_request_ies_o::value_c write_replace_warning_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::msg_id);
      break;
    case 112:
      ret.set(value_c::types::serial_num);
      break;
    case 113:
      ret.set(value_c::types::warning_area_list);
      break;
    case 114:
      ret.set(value_c::types::repeat_period);
      break;
    case 144:
      ret.set(value_c::types::extended_repeat_period);
      break;
    case 115:
      ret.set(value_c::types::numof_broadcast_request);
      break;
    case 116:
      ret.set(value_c::types::warning_type);
      break;
    case 117:
      ret.set(value_c::types::warning_security_info);
      break;
    case 118:
      ret.set(value_c::types::data_coding_scheme);
      break;
    case 119:
      ret.set(value_c::types::warning_msg_contents);
      break;
    case 142:
      ret.set(value_c::types::concurrent_warning_msg_ind);
      break;
    case 286:
      ret.set(value_c::types::warning_area_coordinates);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::mandatory;
    case 112:
      return presence_e::mandatory;
    case 113:
      return presence_e::optional;
    case 114:
      return presence_e::mandatory;
    case 144:
      return presence_e::optional;
    case 115:
      return presence_e::mandatory;
    case 116:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 119:
      return presence_e::optional;
    case 142:
      return presence_e::optional;
    case 286:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    case types::warning_type:
      c.destroy<fixed_octstring<2, true> >();
      break;
    case types::warning_security_info:
      c.destroy<fixed_octstring<50, true> >();
      break;
    case types::data_coding_scheme:
      c.destroy<fixed_bitstring<8, false, true> >();
      break;
    case types::warning_msg_contents:
      c.destroy<bounded_octstring<1, 9600, true> >();
      break;
    case types::warning_area_coordinates:
      c.destroy<bounded_octstring<1, 1024, true> >();
      break;
    default:
      break;
  }
}
void write_replace_warning_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::repeat_period:
      break;
    case types::extended_repeat_period:
      break;
    case types::numof_broadcast_request:
      break;
    case types::warning_type:
      c.init<fixed_octstring<2, true> >();
      break;
    case types::warning_security_info:
      c.init<fixed_octstring<50, true> >();
      break;
    case types::data_coding_scheme:
      c.init<fixed_bitstring<8, false, true> >();
      break;
    case types::warning_msg_contents:
      c.init<bounded_octstring<1, 9600, true> >();
      break;
    case types::concurrent_warning_msg_ind:
      break;
    case types::warning_area_coordinates:
      c.init<bounded_octstring<1, 1024, true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c::value_c(const write_replace_warning_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.init(other.c.get<uint16_t>());
      break;
    case types::extended_repeat_period:
      c.init(other.c.get<uint32_t>());
      break;
    case types::numof_broadcast_request:
      c.init(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.init(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::warning_security_info:
      c.init(other.c.get<fixed_octstring<50, true> >());
      break;
    case types::data_coding_scheme:
      c.init(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::warning_msg_contents:
      c.init(other.c.get<bounded_octstring<1, 9600, true> >());
      break;
    case types::concurrent_warning_msg_ind:
      c.init(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.init(other.c.get<bounded_octstring<1, 1024, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c&
write_replace_warning_request_ies_o::value_c::operator=(const write_replace_warning_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.set(other.c.get<uint16_t>());
      break;
    case types::extended_repeat_period:
      c.set(other.c.get<uint32_t>());
      break;
    case types::numof_broadcast_request:
      c.set(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.set(other.c.get<fixed_octstring<2, true> >());
      break;
    case types::warning_security_info:
      c.set(other.c.get<fixed_octstring<50, true> >());
      break;
    case types::data_coding_scheme:
      c.set(other.c.get<fixed_bitstring<8, false, true> >());
      break;
    case types::warning_msg_contents:
      c.set(other.c.get<bounded_octstring<1, 9600, true> >());
      break;
    case types::concurrent_warning_msg_ind:
      c.set(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.set(other.c.get<bounded_octstring<1, 1024, true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
uint16_t& write_replace_warning_request_ies_o::value_c::repeat_period()
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint16_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::extended_repeat_period()
{
  assert_choice_type(types::extended_repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::numof_broadcast_request()
{
  assert_choice_type(types::numof_broadcast_request, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type()
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info()
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true> >();
}
fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme()
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents()
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true> >();
}
concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind()
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates()
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true> >();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const uint16_t& write_replace_warning_request_ies_o::value_c::repeat_period() const
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint16_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::extended_repeat_period() const
{
  assert_choice_type(types::extended_repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::numof_broadcast_request() const
{
  assert_choice_type(types::numof_broadcast_request, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type() const
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true> >();
}
const fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info() const
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true> >();
}
const fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme() const
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true> >();
}
const bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents() const
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true> >();
}
const concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind() const
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
const bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates() const
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true> >();
}
void write_replace_warning_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::repeat_period:
      j.write_int("INTEGER (0..4095)", c.get<uint16_t>());
      break;
    case types::extended_repeat_period:
      j.write_int("INTEGER (4096..131071)", c.get<uint32_t>());
      break;
    case types::numof_broadcast_request:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::warning_type:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true> >().to_string());
      break;
    case types::warning_security_info:
      j.write_str("OCTET STRING", c.get<fixed_octstring<50, true> >().to_string());
      break;
    case types::data_coding_scheme:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true> >().to_string());
      break;
    case types::warning_msg_contents:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 9600, true> >().to_string());
      break;
    case types::concurrent_warning_msg_ind:
      j.write_str("ConcurrentWarningMessageIndicator", "true");
      break;
    case types::warning_area_coordinates:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 1024, true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::extended_repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)4096u, (uint32_t)131071u, false, true));
      break;
    case types::numof_broadcast_request:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().pack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true> >().pack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().pack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true> >().pack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().pack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true> >().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::extended_repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)4096u, (uint32_t)131071u, false, true));
      break;
    case types::numof_broadcast_request:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true> >().unpack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true> >().unpack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true> >().unpack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true> >().unpack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().unpack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true> >().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"BIT STRING",
                                  "BIT STRING",
                                  "WarningAreaList",
                                  "INTEGER (0..4095)",
                                  "INTEGER (4096..131071)",
                                  "INTEGER (0..65535)",
                                  "OCTET STRING",
                                  "OCTET STRING",
                                  "BIT STRING",
                                  "OCTET STRING",
                                  "ConcurrentWarningMessageIndicator",
                                  "OCTET STRING"};
  return convert_enum_idx(options, 12, value, "write_replace_warning_request_ies_o::value_c::types");
}

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF S1AP-PROTOCOL-IES
uint32_t write_replace_warning_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {111, 112, 120, 58};
  return map_enum_number(options, 4, idx, "id");
}
bool write_replace_warning_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {111, 112, 120, 58};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::reject;
    case 112:
      return crit_e::reject;
    case 120:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
write_replace_warning_resp_ies_o::value_c write_replace_warning_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::msg_id);
      break;
    case 112:
      ret.set(value_c::types::serial_num);
      break;
    case 120:
      ret.set(value_c::types::broadcast_completed_area_list);
      break;
    case 58:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::mandatory;
    case 112:
      return presence_e::mandatory;
    case 120:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true> >();
      break;
    case types::broadcast_completed_area_list:
      c.destroy<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void write_replace_warning_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true> >();
      break;
    case types::broadcast_completed_area_list:
      c.init<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c::value_c(const write_replace_warning_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::broadcast_completed_area_list:
      c.init(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c&
write_replace_warning_resp_ies_o::value_c::operator=(const write_replace_warning_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true> >());
      break;
    case types::broadcast_completed_area_list:
      c.set(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list()
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true> >();
}
const broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list() const
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
const crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void write_replace_warning_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true> >().to_string());
      break;
    case types::broadcast_completed_area_list:
      j.write_fieldname("BroadcastCompletedAreaList");
      c.get<broadcast_completed_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().pack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true> >().unpack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* options[] = {"BIT STRING", "BIT STRING", "BroadcastCompletedAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(options, 4, value, "write_replace_warning_resp_ies_o::value_c::types");
}

template struct asn1::s1ap::protocol_ie_field_s<kill_request_ies_o>;

kill_request_ies_container::kill_request_ies_container() :
  msg_id(111, crit_e::reject),
  serial_num(112, crit_e::reject),
  warning_area_list(113, crit_e::ignore),
  kill_all_warning_msgs(191, crit_e::reject)
{}
SRSASN_CODE kill_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += kill_all_warning_msgs_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  if (kill_all_warning_msgs_present) {
    HANDLE_CODE(kill_all_warning_msgs.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<kill_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 111:
        nof_mandatory_ies--;
        msg_id.id    = c.id;
        msg_id.crit  = c.crit;
        msg_id.value = c.value.msg_id();
        break;
      case 112:
        nof_mandatory_ies--;
        serial_num.id    = c.id;
        serial_num.crit  = c.crit;
        serial_num.value = c.value.serial_num();
        break;
      case 113:
        warning_area_list_present = true;
        warning_area_list.id      = c.id;
        warning_area_list.crit    = c.crit;
        warning_area_list.value   = c.value.warning_area_list();
        break;
      case 191:
        kill_all_warning_msgs_present = true;
        kill_all_warning_msgs.id      = c.id;
        kill_all_warning_msgs.crit    = c.crit;
        kill_all_warning_msgs.value   = c.value.kill_all_warning_msgs();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void kill_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  if (kill_all_warning_msgs_present) {
    j.write_fieldname("");
    kill_all_warning_msgs.to_json(j);
  }
  j.end_obj();
}

// KillRequest ::= SEQUENCE
SRSASN_CODE kill_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void kill_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<kill_resp_ies_o>;

kill_resp_ies_container::kill_resp_ies_container() :
  msg_id(111, crit_e::reject),
  serial_num(112, crit_e::reject),
  broadcast_cancelled_area_list(141, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE kill_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_cancelled_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_cancelled_area_list_present) {
    HANDLE_CODE(broadcast_cancelled_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<kill_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 111:
        nof_mandatory_ies--;
        msg_id.id    = c.id;
        msg_id.crit  = c.crit;
        msg_id.value = c.value.msg_id();
        break;
      case 112:
        nof_mandatory_ies--;
        serial_num.id    = c.id;
        serial_num.crit  = c.crit;
        serial_num.value = c.value.serial_num();
        break;
      case 141:
        broadcast_cancelled_area_list_present = true;
        broadcast_cancelled_area_list.id      = c.id;
        broadcast_cancelled_area_list.crit    = c.crit;
        broadcast_cancelled_area_list.value   = c.value.broadcast_cancelled_area_list();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void kill_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_cancelled_area_list_present) {
    j.write_fieldname("");
    broadcast_cancelled_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// KillResponse ::= SEQUENCE
SRSASN_CODE kill_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE kill_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void kill_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<location_report_ies_o>;

location_report_ies_container::location_report_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  tai(67, crit_e::ignore),
  request_type(98, crit_e::ignore),
  ps_cell_info(288, crit_e::ignore)
{}
SRSASN_CODE location_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += ps_cell_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(request_type.pack(bref));
  if (ps_cell_info_present) {
    HANDLE_CODE(ps_cell_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<location_report_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 98:
        nof_mandatory_ies--;
        request_type.id    = c.id;
        request_type.crit  = c.crit;
        request_type.value = c.value.request_type();
        break;
      case 288:
        ps_cell_info_present = true;
        ps_cell_info.id      = c.id;
        ps_cell_info.crit    = c.crit;
        ps_cell_info.value   = c.value.ps_cell_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  request_type.to_json(j);
  if (ps_cell_info_present) {
    j.write_fieldname("");
    ps_cell_info.to_json(j);
  }
  j.end_obj();
}

// LocationReport ::= SEQUENCE
SRSASN_CODE location_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void location_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<location_report_ctrl_ies_o>;

location_report_ctrl_ies_container::location_report_ctrl_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), request_type(98, crit_e::ignore)
{}
SRSASN_CODE location_report_ctrl_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(request_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<location_report_ctrl_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 98:
        nof_mandatory_ies--;
        request_type.id    = c.id;
        request_type.crit  = c.crit;
        request_type.value = c.value.request_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ctrl_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  request_type.to_json(j);
  j.end_obj();
}

// LocationReportingControl ::= SEQUENCE
SRSASN_CODE location_report_ctrl_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void location_report_ctrl_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<location_report_fail_ind_ies_o>;

location_report_fail_ind_ies_container::location_report_fail_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), cause(2, crit_e::ignore)
{}
SRSASN_CODE location_report_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<location_report_fail_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// LocationReportingFailureIndication ::= SEQUENCE
SRSASN_CODE location_report_fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void location_report_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<mmecp_relocation_ind_ies_o>;

mmecp_relocation_ind_ies_container::mmecp_relocation_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject)
{}
SRSASN_CODE mmecp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mmecp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<mmecp_relocation_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void mmecp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.end_obj();
}

// MMECPRelocationIndication ::= SEQUENCE
SRSASN_CODE mmecp_relocation_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mmecp_relocation_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void mmecp_relocation_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<mme_cfg_transfer_ies_o>;

mme_cfg_transfer_ies_container::mme_cfg_transfer_ies_container() :
  son_cfg_transfer_mct(130, crit_e::ignore), en_dcson_cfg_transfer_mct(295, crit_e::ignore)
{}
SRSASN_CODE mme_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_mct_present ? 1 : 0;
  nof_ies += en_dcson_cfg_transfer_mct_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_mct_present) {
    HANDLE_CODE(son_cfg_transfer_mct.pack(bref));
  }
  if (en_dcson_cfg_transfer_mct_present) {
    HANDLE_CODE(en_dcson_cfg_transfer_mct.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<mme_cfg_transfer_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 130:
        son_cfg_transfer_mct_present = true;
        son_cfg_transfer_mct.id      = c.id;
        son_cfg_transfer_mct.crit    = c.crit;
        son_cfg_transfer_mct.value   = c.value.son_cfg_transfer_mct();
        break;
      case 295:
        en_dcson_cfg_transfer_mct_present = true;
        en_dcson_cfg_transfer_mct.id      = c.id;
        en_dcson_cfg_transfer_mct.crit    = c.crit;
        en_dcson_cfg_transfer_mct.value   = c.value.en_dcson_cfg_transfer_mct();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void mme_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_mct_present) {
    j.write_fieldname("");
    son_cfg_transfer_mct.to_json(j);
  }
  if (en_dcson_cfg_transfer_mct_present) {
    j.write_fieldname("");
    en_dcson_cfg_transfer_mct.to_json(j);
  }
  j.end_obj();
}

// MMEConfigurationTransfer ::= SEQUENCE
SRSASN_CODE mme_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void mme_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<mme_cfg_upd_ies_o>;

mme_cfg_upd_ies_container::mme_cfg_upd_ies_container() :
  mm_ename(61, crit_e::ignore),
  served_gummeis(105, crit_e::reject),
  relative_mme_capacity(87, crit_e::reject),
  served_dcns(247, crit_e::ignore)
{}
SRSASN_CODE mme_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mm_ename_present ? 1 : 0;
  nof_ies += served_gummeis_present ? 1 : 0;
  nof_ies += relative_mme_capacity_present ? 1 : 0;
  nof_ies += served_dcns_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (mm_ename_present) {
    HANDLE_CODE(mm_ename.pack(bref));
  }
  if (served_gummeis_present) {
    HANDLE_CODE(served_gummeis.pack(bref));
  }
  if (relative_mme_capacity_present) {
    HANDLE_CODE(relative_mme_capacity.pack(bref));
  }
  if (served_dcns_present) {
    HANDLE_CODE(served_dcns.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<mme_cfg_upd_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 61:
        mm_ename_present = true;
        mm_ename.id      = c.id;
        mm_ename.crit    = c.crit;
        mm_ename.value   = c.value.mm_ename();
        break;
      case 105:
        served_gummeis_present = true;
        served_gummeis.id      = c.id;
        served_gummeis.crit    = c.crit;
        served_gummeis.value   = c.value.served_gummeis();
        break;
      case 87:
        relative_mme_capacity_present = true;
        relative_mme_capacity.id      = c.id;
        relative_mme_capacity.crit    = c.crit;
        relative_mme_capacity.value   = c.value.relative_mme_capacity();
        break;
      case 247:
        served_dcns_present = true;
        served_dcns.id      = c.id;
        served_dcns.crit    = c.crit;
        served_dcns.value   = c.value.served_dcns();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void mme_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mm_ename_present) {
    j.write_fieldname("");
    mm_ename.to_json(j);
  }
  if (served_gummeis_present) {
    j.write_fieldname("");
    served_gummeis.to_json(j);
  }
  if (relative_mme_capacity_present) {
    j.write_fieldname("");
    relative_mme_capacity.to_json(j);
  }
  if (served_dcns_present) {
    j.write_fieldname("");
    served_dcns.to_json(j);
  }
  j.end_obj();
}

// MMEConfigurationUpdate ::= SEQUENCE
SRSASN_CODE mme_cfg_upd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void mme_cfg_upd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// MMEConfigurationUpdateAcknowledge ::= SEQUENCE
SRSASN_CODE mme_cfg_upd_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void mme_cfg_upd_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<mme_cfg_upd_fail_ies_o>;

mme_cfg_upd_fail_ies_container::mme_cfg_upd_fail_ies_container() :
  cause(2, crit_e::ignore), time_to_wait(65, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE mme_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<mme_cfg_upd_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 65:
        time_to_wait_present = true;
        time_to_wait.id      = c.id;
        time_to_wait.crit    = c.crit;
        time_to_wait.value   = c.value.time_to_wait();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void mme_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// MMEConfigurationUpdateFailure ::= SEQUENCE
SRSASN_CODE mme_cfg_upd_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_cfg_upd_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void mme_cfg_upd_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// MMEDirectInformationTransfer ::= SEQUENCE
SRSASN_CODE mme_direct_info_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_direct_info_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void mme_direct_info_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<mme_status_transfer_ies_o>;

mme_status_transfer_ies_container::mme_status_transfer_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  enb_status_transfer_transparent_container(90, crit_e::reject)
{}
SRSASN_CODE mme_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<mme_status_transfer_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 90:
        nof_mandatory_ies--;
        enb_status_transfer_transparent_container.id    = c.id;
        enb_status_transfer_transparent_container.crit  = c.crit;
        enb_status_transfer_transparent_container.value = c.value.enb_status_transfer_transparent_container();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void mme_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// MMEStatusTransfer ::= SEQUENCE
SRSASN_CODE mme_status_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE mme_status_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void mme_status_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<nas_delivery_ind_ies_o>;

nas_delivery_ind_ies_container::nas_delivery_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject)
{}
SRSASN_CODE nas_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<nas_delivery_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.end_obj();
}

// NASDeliveryIndication ::= SEQUENCE
SRSASN_CODE nas_delivery_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_delivery_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void nas_delivery_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<nas_non_delivery_ind_ies_o>;

nas_non_delivery_ind_ies_container::nas_non_delivery_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  nas_pdu(26, crit_e::ignore),
  cause(2, crit_e::ignore)
{}
SRSASN_CODE nas_non_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<nas_non_delivery_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 26:
        nof_mandatory_ies--;
        nas_pdu.id    = c.id;
        nas_pdu.crit  = c.crit;
        nas_pdu.value = c.value.nas_pdu();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// NASNonDeliveryIndication ::= SEQUENCE
SRSASN_CODE nas_non_delivery_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<overload_start_ies_o>;

overload_start_ies_container::overload_start_ies_container() :
  overload_resp(101, crit_e::reject), gummei_list(154, crit_e::ignore), traffic_load_reduction_ind(161, crit_e::ignore)
{}
SRSASN_CODE overload_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += gummei_list_present ? 1 : 0;
  nof_ies += traffic_load_reduction_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(overload_resp.pack(bref));
  if (gummei_list_present) {
    HANDLE_CODE(gummei_list.pack(bref));
  }
  if (traffic_load_reduction_ind_present) {
    HANDLE_CODE(traffic_load_reduction_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<overload_start_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 101:
        nof_mandatory_ies--;
        overload_resp.id    = c.id;
        overload_resp.crit  = c.crit;
        overload_resp.value = c.value.overload_resp();
        break;
      case 154:
        gummei_list_present = true;
        gummei_list.id      = c.id;
        gummei_list.crit    = c.crit;
        gummei_list.value   = c.value.gummei_list();
        break;
      case 161:
        traffic_load_reduction_ind_present = true;
        traffic_load_reduction_ind.id      = c.id;
        traffic_load_reduction_ind.crit    = c.crit;
        traffic_load_reduction_ind.value   = c.value.traffic_load_reduction_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void overload_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  overload_resp.to_json(j);
  if (gummei_list_present) {
    j.write_fieldname("");
    gummei_list.to_json(j);
  }
  if (traffic_load_reduction_ind_present) {
    j.write_fieldname("");
    traffic_load_reduction_ind.to_json(j);
  }
  j.end_obj();
}

// OverloadStart ::= SEQUENCE
SRSASN_CODE overload_start_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void overload_start_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// OverloadStop ::= SEQUENCE
SRSASN_CODE overload_stop_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_stop_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void overload_stop_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<pws_fail_ind_ies_o>;

pws_fail_ind_ies_container::pws_fail_ind_ies_container() :
  pw_sfailed_ecgi_list(222, crit_e::reject), global_enb_id(59, crit_e::reject)
{}
SRSASN_CODE pws_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(pw_sfailed_ecgi_list.pack(bref));
  HANDLE_CODE(global_enb_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<pws_fail_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 222:
        nof_mandatory_ies--;
        pw_sfailed_ecgi_list.id    = c.id;
        pw_sfailed_ecgi_list.crit  = c.crit;
        pw_sfailed_ecgi_list.value = c.value.pw_sfailed_ecgi_list();
        break;
      case 59:
        nof_mandatory_ies--;
        global_enb_id.id    = c.id;
        global_enb_id.crit  = c.crit;
        global_enb_id.value = c.value.global_enb_id();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  pw_sfailed_ecgi_list.to_json(j);
  j.write_fieldname("");
  global_enb_id.to_json(j);
  j.end_obj();
}

// PWSFailureIndication ::= SEQUENCE
SRSASN_CODE pws_fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void pws_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<pws_restart_ind_ies_o>;

pws_restart_ind_ies_container::pws_restart_ind_ies_container() :
  ecgi_list_for_restart(182, crit_e::reject),
  global_enb_id(59, crit_e::reject),
  tai_list_for_restart(188, crit_e::reject),
  emergency_area_id_list_for_restart(190, crit_e::reject)
{}
SRSASN_CODE pws_restart_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += emergency_area_id_list_for_restart_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ecgi_list_for_restart.pack(bref));
  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(tai_list_for_restart.pack(bref));
  if (emergency_area_id_list_for_restart_present) {
    HANDLE_CODE(emergency_area_id_list_for_restart.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<pws_restart_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 182:
        nof_mandatory_ies--;
        ecgi_list_for_restart.id    = c.id;
        ecgi_list_for_restart.crit  = c.crit;
        ecgi_list_for_restart.value = c.value.ecgi_list_for_restart();
        break;
      case 59:
        nof_mandatory_ies--;
        global_enb_id.id    = c.id;
        global_enb_id.crit  = c.crit;
        global_enb_id.value = c.value.global_enb_id();
        break;
      case 188:
        nof_mandatory_ies--;
        tai_list_for_restart.id    = c.id;
        tai_list_for_restart.crit  = c.crit;
        tai_list_for_restart.value = c.value.tai_list_for_restart();
        break;
      case 190:
        emergency_area_id_list_for_restart_present = true;
        emergency_area_id_list_for_restart.id      = c.id;
        emergency_area_id_list_for_restart.crit    = c.crit;
        emergency_area_id_list_for_restart.value   = c.value.emergency_area_id_list_for_restart();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_restart_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ecgi_list_for_restart.to_json(j);
  j.write_fieldname("");
  global_enb_id.to_json(j);
  j.write_fieldname("");
  tai_list_for_restart.to_json(j);
  if (emergency_area_id_list_for_restart_present) {
    j.write_fieldname("");
    emergency_area_id_list_for_restart.to_json(j);
  }
  j.end_obj();
}

// PWSRestartIndication ::= SEQUENCE
SRSASN_CODE pws_restart_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void pws_restart_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<paging_ies_o>;

paging_ies_container::paging_ies_container() :
  ue_id_idx_value(80, crit_e::ignore),
  ue_paging_id(43, crit_e::ignore),
  paging_drx(44, crit_e::ignore),
  cn_domain(109, crit_e::ignore),
  tai_list(46, crit_e::ignore),
  csg_id_list(128, crit_e::ignore),
  paging_prio(151, crit_e::ignore),
  ue_radio_cap_for_paging(198, crit_e::ignore),
  assist_data_for_paging(211, crit_e::ignore),
  paging_e_drx_info(227, crit_e::ignore),
  extended_ue_id_idx_value(231, crit_e::ignore),
  nb_io_t_paging_e_drx_info(239, crit_e::ignore),
  nb_io_t_ue_id_idx_value(244, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore)
{}
SRSASN_CODE paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += paging_drx_present ? 1 : 0;
  nof_ies += csg_id_list_present ? 1 : 0;
  nof_ies += paging_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += assist_data_for_paging_present ? 1 : 0;
  nof_ies += paging_e_drx_info_present ? 1 : 0;
  nof_ies += extended_ue_id_idx_value_present ? 1 : 0;
  nof_ies += nb_io_t_paging_e_drx_info_present ? 1 : 0;
  nof_ies += nb_io_t_ue_id_idx_value_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  HANDLE_CODE(ue_paging_id.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  HANDLE_CODE(cn_domain.pack(bref));
  HANDLE_CODE(tai_list.pack(bref));
  if (csg_id_list_present) {
    HANDLE_CODE(csg_id_list.pack(bref));
  }
  if (paging_prio_present) {
    HANDLE_CODE(paging_prio.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (assist_data_for_paging_present) {
    HANDLE_CODE(assist_data_for_paging.pack(bref));
  }
  if (paging_e_drx_info_present) {
    HANDLE_CODE(paging_e_drx_info.pack(bref));
  }
  if (extended_ue_id_idx_value_present) {
    HANDLE_CODE(extended_ue_id_idx_value.pack(bref));
  }
  if (nb_io_t_paging_e_drx_info_present) {
    HANDLE_CODE(nb_io_t_paging_e_drx_info.pack(bref));
  }
  if (nb_io_t_ue_id_idx_value_present) {
    HANDLE_CODE(nb_io_t_ue_id_idx_value.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<paging_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 80:
        nof_mandatory_ies--;
        ue_id_idx_value.id    = c.id;
        ue_id_idx_value.crit  = c.crit;
        ue_id_idx_value.value = c.value.ue_id_idx_value();
        break;
      case 43:
        nof_mandatory_ies--;
        ue_paging_id.id    = c.id;
        ue_paging_id.crit  = c.crit;
        ue_paging_id.value = c.value.ue_paging_id();
        break;
      case 44:
        paging_drx_present = true;
        paging_drx.id      = c.id;
        paging_drx.crit    = c.crit;
        paging_drx.value   = c.value.paging_drx();
        break;
      case 109:
        nof_mandatory_ies--;
        cn_domain.id    = c.id;
        cn_domain.crit  = c.crit;
        cn_domain.value = c.value.cn_domain();
        break;
      case 46:
        nof_mandatory_ies--;
        tai_list.id    = c.id;
        tai_list.crit  = c.crit;
        tai_list.value = c.value.tai_list();
        break;
      case 128:
        csg_id_list_present = true;
        csg_id_list.id      = c.id;
        csg_id_list.crit    = c.crit;
        csg_id_list.value   = c.value.csg_id_list();
        break;
      case 151:
        paging_prio_present = true;
        paging_prio.id      = c.id;
        paging_prio.crit    = c.crit;
        paging_prio.value   = c.value.paging_prio();
        break;
      case 198:
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = c.id;
        ue_radio_cap_for_paging.crit    = c.crit;
        ue_radio_cap_for_paging.value   = c.value.ue_radio_cap_for_paging();
        break;
      case 211:
        assist_data_for_paging_present = true;
        assist_data_for_paging.id      = c.id;
        assist_data_for_paging.crit    = c.crit;
        assist_data_for_paging.value   = c.value.assist_data_for_paging();
        break;
      case 227:
        paging_e_drx_info_present = true;
        paging_e_drx_info.id      = c.id;
        paging_e_drx_info.crit    = c.crit;
        paging_e_drx_info.value   = c.value.paging_e_drx_info();
        break;
      case 231:
        extended_ue_id_idx_value_present = true;
        extended_ue_id_idx_value.id      = c.id;
        extended_ue_id_idx_value.crit    = c.crit;
        extended_ue_id_idx_value.value   = c.value.extended_ue_id_idx_value();
        break;
      case 239:
        nb_io_t_paging_e_drx_info_present = true;
        nb_io_t_paging_e_drx_info.id      = c.id;
        nb_io_t_paging_e_drx_info.crit    = c.crit;
        nb_io_t_paging_e_drx_info.value   = c.value.nb_io_t_paging_e_drx_info();
        break;
      case 244:
        nb_io_t_ue_id_idx_value_present = true;
        nb_io_t_ue_id_idx_value.id      = c.id;
        nb_io_t_ue_id_idx_value.crit    = c.crit;
        nb_io_t_ue_id_idx_value.value   = c.value.nb_io_t_ue_id_idx_value();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_id_idx_value.to_json(j);
  j.write_fieldname("");
  ue_paging_id.to_json(j);
  if (paging_drx_present) {
    j.write_fieldname("");
    paging_drx.to_json(j);
  }
  j.write_fieldname("");
  cn_domain.to_json(j);
  j.write_fieldname("");
  tai_list.to_json(j);
  if (csg_id_list_present) {
    j.write_fieldname("");
    csg_id_list.to_json(j);
  }
  if (paging_prio_present) {
    j.write_fieldname("");
    paging_prio.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (assist_data_for_paging_present) {
    j.write_fieldname("");
    assist_data_for_paging.to_json(j);
  }
  if (paging_e_drx_info_present) {
    j.write_fieldname("");
    paging_e_drx_info.to_json(j);
  }
  if (extended_ue_id_idx_value_present) {
    j.write_fieldname("");
    extended_ue_id_idx_value.to_json(j);
  }
  if (nb_io_t_paging_e_drx_info_present) {
    j.write_fieldname("");
    nb_io_t_paging_e_drx_info.to_json(j);
  }
  if (nb_io_t_ue_id_idx_value_present) {
    j.write_fieldname("");
    nb_io_t_ue_id_idx_value.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  j.end_obj();
}

// Paging ::= SEQUENCE
SRSASN_CODE paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<path_switch_request_ies_o>;

path_switch_request_ies_container::path_switch_request_ies_container() :
  enb_ue_s1ap_id(8, crit_e::reject),
  erab_to_be_switched_dl_list(22, crit_e::reject),
  source_mme_ue_s1ap_id(88, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  tai(67, crit_e::ignore),
  ue_security_cap(107, crit_e::ignore),
  csg_id(127, crit_e::ignore),
  cell_access_mode(145, crit_e::ignore),
  source_mme_gummei(157, crit_e::ignore),
  csg_membership_status(146, crit_e::ignore),
  tunnel_info_for_bbf(176, crit_e::ignore),
  lhn_id(186, crit_e::ignore),
  rrc_resume_cause(245, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  ps_cell_info(288, crit_e::ignore)
{}
SRSASN_CODE path_switch_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += csg_id_present ? 1 : 0;
  nof_ies += cell_access_mode_present ? 1 : 0;
  nof_ies += source_mme_gummei_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += tunnel_info_for_bbf_present ? 1 : 0;
  nof_ies += lhn_id_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += ps_cell_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(erab_to_be_switched_dl_list.pack(bref));
  HANDLE_CODE(source_mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  if (csg_id_present) {
    HANDLE_CODE(csg_id.pack(bref));
  }
  if (cell_access_mode_present) {
    HANDLE_CODE(cell_access_mode.pack(bref));
  }
  if (source_mme_gummei_present) {
    HANDLE_CODE(source_mme_gummei.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (tunnel_info_for_bbf_present) {
    HANDLE_CODE(tunnel_info_for_bbf.pack(bref));
  }
  if (lhn_id_present) {
    HANDLE_CODE(lhn_id.pack(bref));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (ps_cell_info_present) {
    HANDLE_CODE(ps_cell_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<path_switch_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 22:
        nof_mandatory_ies--;
        erab_to_be_switched_dl_list.id    = c.id;
        erab_to_be_switched_dl_list.crit  = c.crit;
        erab_to_be_switched_dl_list.value = c.value.erab_to_be_switched_dl_list();
        break;
      case 88:
        nof_mandatory_ies--;
        source_mme_ue_s1ap_id.id    = c.id;
        source_mme_ue_s1ap_id.crit  = c.crit;
        source_mme_ue_s1ap_id.value = c.value.source_mme_ue_s1ap_id();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 107:
        nof_mandatory_ies--;
        ue_security_cap.id    = c.id;
        ue_security_cap.crit  = c.crit;
        ue_security_cap.value = c.value.ue_security_cap();
        break;
      case 127:
        csg_id_present = true;
        csg_id.id      = c.id;
        csg_id.crit    = c.crit;
        csg_id.value   = c.value.csg_id();
        break;
      case 145:
        cell_access_mode_present = true;
        cell_access_mode.id      = c.id;
        cell_access_mode.crit    = c.crit;
        cell_access_mode.value   = c.value.cell_access_mode();
        break;
      case 157:
        source_mme_gummei_present = true;
        source_mme_gummei.id      = c.id;
        source_mme_gummei.crit    = c.crit;
        source_mme_gummei.value   = c.value.source_mme_gummei();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 176:
        tunnel_info_for_bbf_present = true;
        tunnel_info_for_bbf.id      = c.id;
        tunnel_info_for_bbf.crit    = c.crit;
        tunnel_info_for_bbf.value   = c.value.tunnel_info_for_bbf();
        break;
      case 186:
        lhn_id_present = true;
        lhn_id.id      = c.id;
        lhn_id.crit    = c.crit;
        lhn_id.value   = c.value.lhn_id();
        break;
      case 245:
        rrc_resume_cause_present = true;
        rrc_resume_cause.id      = c.id;
        rrc_resume_cause.crit    = c.crit;
        rrc_resume_cause.value   = c.value.rrc_resume_cause();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 288:
        ps_cell_info_present = true;
        ps_cell_info.id      = c.id;
        ps_cell_info.crit    = c.crit;
        ps_cell_info.value   = c.value.ps_cell_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  erab_to_be_switched_dl_list.to_json(j);
  j.write_fieldname("");
  source_mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  if (csg_id_present) {
    j.write_fieldname("");
    csg_id.to_json(j);
  }
  if (cell_access_mode_present) {
    j.write_fieldname("");
    cell_access_mode.to_json(j);
  }
  if (source_mme_gummei_present) {
    j.write_fieldname("");
    source_mme_gummei.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (tunnel_info_for_bbf_present) {
    j.write_fieldname("");
    tunnel_info_for_bbf.to_json(j);
  }
  if (lhn_id_present) {
    j.write_fieldname("");
    lhn_id.to_json(j);
  }
  if (rrc_resume_cause_present) {
    j.write_fieldname("");
    rrc_resume_cause.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (ps_cell_info_present) {
    j.write_fieldname("");
    ps_cell_info.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequest ::= SEQUENCE
SRSASN_CODE path_switch_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void path_switch_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<path_switch_request_ack_ies_o>;

path_switch_request_ack_ies_container::path_switch_request_ack_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  ueaggregate_maximum_bitrate(66, crit_e::ignore),
  erab_to_be_switched_ul_list(95, crit_e::ignore),
  erab_to_be_released_list(33, crit_e::ignore),
  security_context(40, crit_e::reject),
  crit_diagnostics(58, crit_e::ignore),
  mme_ue_s1ap_id_minus2(158, crit_e::ignore),
  csg_membership_status(146, crit_e::ignore),
  pro_se_authorized(195, crit_e::ignore),
  ueuser_plane_cio_tsupport_ind(241, crit_e::ignore),
  v2xservices_authorized(240, crit_e::ignore),
  ue_sidelink_aggregate_maximum_bitrate(248, crit_e::ignore),
  enhanced_coverage_restricted(251, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  ce_mode_brestricted(271, crit_e::ignore),
  aerial_uesubscription_info(277, crit_e::ignore),
  pending_data_ind(283, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  ho_restrict_list(41, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore)
{}
SRSASN_CODE path_switch_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ueaggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += erab_to_be_switched_ul_list_present ? 1 : 0;
  nof_ies += erab_to_be_released_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += mme_ue_s1ap_id_minus2_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += pro_se_authorized_present ? 1 : 0;
  nof_ies += ueuser_plane_cio_tsupport_ind_present ? 1 : 0;
  nof_ies += v2xservices_authorized_present ? 1 : 0;
  nof_ies += ue_sidelink_aggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += enhanced_coverage_restricted_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += aerial_uesubscription_info_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += ho_restrict_list_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ueaggregate_maximum_bitrate_present) {
    HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  }
  if (erab_to_be_switched_ul_list_present) {
    HANDLE_CODE(erab_to_be_switched_ul_list.pack(bref));
  }
  if (erab_to_be_released_list_present) {
    HANDLE_CODE(erab_to_be_released_list.pack(bref));
  }
  HANDLE_CODE(security_context.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (mme_ue_s1ap_id_minus2_present) {
    HANDLE_CODE(mme_ue_s1ap_id_minus2.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (pro_se_authorized_present) {
    HANDLE_CODE(pro_se_authorized.pack(bref));
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    HANDLE_CODE(ueuser_plane_cio_tsupport_ind.pack(bref));
  }
  if (v2xservices_authorized_present) {
    HANDLE_CODE(v2xservices_authorized.pack(bref));
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    HANDLE_CODE(ue_sidelink_aggregate_maximum_bitrate.pack(bref));
  }
  if (enhanced_coverage_restricted_present) {
    HANDLE_CODE(enhanced_coverage_restricted.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (aerial_uesubscription_info_present) {
    HANDLE_CODE(aerial_uesubscription_info.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (ho_restrict_list_present) {
    HANDLE_CODE(ho_restrict_list.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<path_switch_request_ack_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 66:
        ueaggregate_maximum_bitrate_present = true;
        ueaggregate_maximum_bitrate.id      = c.id;
        ueaggregate_maximum_bitrate.crit    = c.crit;
        ueaggregate_maximum_bitrate.value   = c.value.ueaggregate_maximum_bitrate();
        break;
      case 95:
        erab_to_be_switched_ul_list_present = true;
        erab_to_be_switched_ul_list.id      = c.id;
        erab_to_be_switched_ul_list.crit    = c.crit;
        erab_to_be_switched_ul_list.value   = c.value.erab_to_be_switched_ul_list();
        break;
      case 33:
        erab_to_be_released_list_present = true;
        erab_to_be_released_list.id      = c.id;
        erab_to_be_released_list.crit    = c.crit;
        erab_to_be_released_list.value   = c.value.erab_to_be_released_list();
        break;
      case 40:
        nof_mandatory_ies--;
        security_context.id    = c.id;
        security_context.crit  = c.crit;
        security_context.value = c.value.security_context();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 158:
        mme_ue_s1ap_id_minus2_present = true;
        mme_ue_s1ap_id_minus2.id      = c.id;
        mme_ue_s1ap_id_minus2.crit    = c.crit;
        mme_ue_s1ap_id_minus2.value   = c.value.mme_ue_s1ap_id_minus2();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 195:
        pro_se_authorized_present = true;
        pro_se_authorized.id      = c.id;
        pro_se_authorized.crit    = c.crit;
        pro_se_authorized.value   = c.value.pro_se_authorized();
        break;
      case 241:
        ueuser_plane_cio_tsupport_ind_present = true;
        ueuser_plane_cio_tsupport_ind.id      = c.id;
        ueuser_plane_cio_tsupport_ind.crit    = c.crit;
        ueuser_plane_cio_tsupport_ind.value   = c.value.ueuser_plane_cio_tsupport_ind();
        break;
      case 240:
        v2xservices_authorized_present = true;
        v2xservices_authorized.id      = c.id;
        v2xservices_authorized.crit    = c.crit;
        v2xservices_authorized.value   = c.value.v2xservices_authorized();
        break;
      case 248:
        ue_sidelink_aggregate_maximum_bitrate_present = true;
        ue_sidelink_aggregate_maximum_bitrate.id      = c.id;
        ue_sidelink_aggregate_maximum_bitrate.crit    = c.crit;
        ue_sidelink_aggregate_maximum_bitrate.value   = c.value.ue_sidelink_aggregate_maximum_bitrate();
        break;
      case 251:
        enhanced_coverage_restricted_present = true;
        enhanced_coverage_restricted.id      = c.id;
        enhanced_coverage_restricted.crit    = c.crit;
        enhanced_coverage_restricted.value   = c.value.enhanced_coverage_restricted();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 271:
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = c.id;
        ce_mode_brestricted.crit    = c.crit;
        ce_mode_brestricted.value   = c.value.ce_mode_brestricted();
        break;
      case 277:
        aerial_uesubscription_info_present = true;
        aerial_uesubscription_info.id      = c.id;
        aerial_uesubscription_info.crit    = c.crit;
        aerial_uesubscription_info.value   = c.value.aerial_uesubscription_info();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 41:
        ho_restrict_list_present = true;
        ho_restrict_list.id      = c.id;
        ho_restrict_list.crit    = c.crit;
        ho_restrict_list.value   = c.value.ho_restrict_list();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.value   = c.value.add_rrm_prio_idx();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ueaggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ueaggregate_maximum_bitrate.to_json(j);
  }
  if (erab_to_be_switched_ul_list_present) {
    j.write_fieldname("");
    erab_to_be_switched_ul_list.to_json(j);
  }
  if (erab_to_be_released_list_present) {
    j.write_fieldname("");
    erab_to_be_released_list.to_json(j);
  }
  j.write_fieldname("");
  security_context.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (mme_ue_s1ap_id_minus2_present) {
    j.write_fieldname("");
    mme_ue_s1ap_id_minus2.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (pro_se_authorized_present) {
    j.write_fieldname("");
    pro_se_authorized.to_json(j);
  }
  if (ueuser_plane_cio_tsupport_ind_present) {
    j.write_fieldname("");
    ueuser_plane_cio_tsupport_ind.to_json(j);
  }
  if (v2xservices_authorized_present) {
    j.write_fieldname("");
    v2xservices_authorized.to_json(j);
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ue_sidelink_aggregate_maximum_bitrate.to_json(j);
  }
  if (enhanced_coverage_restricted_present) {
    j.write_fieldname("");
    enhanced_coverage_restricted.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (aerial_uesubscription_info_present) {
    j.write_fieldname("");
    aerial_uesubscription_info.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (ho_restrict_list_present) {
    j.write_fieldname("");
    ho_restrict_list.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestAcknowledge ::= SEQUENCE
SRSASN_CODE path_switch_request_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void path_switch_request_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<path_switch_request_fail_ies_o>;

path_switch_request_fail_ies_container::path_switch_request_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE path_switch_request_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<path_switch_request_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestFailure ::= SEQUENCE
SRSASN_CODE path_switch_request_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void path_switch_request_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template <class valueT_>
private_ie_container_item_s<valueT_>::private_ie_container_item_s(private_ie_id_c id_, crit_e crit_) :
  id(id_), crit(crit_)

{}
template <class valueT_>
SRSASN_CODE private_ie_container_item_s<valueT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(id.pack(bref));
  HANDLE_CODE(crit.pack(bref));
  {
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.pack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
SRSASN_CODE private_ie_container_item_s<valueT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(id.unpack(bref));
  HANDLE_CODE(crit.unpack(bref));
  {
    varlength_field_unpack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.unpack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
void private_ie_container_item_s<valueT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("id");
  id.to_json(j);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

SRSASN_CODE private_ie_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void private_ie_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// PrivateMessage ::= SEQUENCE
SRSASN_CODE private_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(private_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(private_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void private_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("PrivateMessage");
  j.write_fieldname("privateIEs");
  private_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

template struct asn1::s1ap::protocol_ie_field_s<reroute_nas_request_ies_o>;

reroute_nas_request_ies_container::reroute_nas_request_ies_container() :
  enb_ue_s1ap_id(8, crit_e::reject),
  mme_ue_s1ap_id(0, crit_e::ignore),
  s1_msg(225, crit_e::reject),
  mme_group_id(223, crit_e::reject),
  add_guti(224, crit_e::ignore),
  ue_usage_type(230, crit_e::ignore)
{}
SRSASN_CODE reroute_nas_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mme_ue_s1ap_id_present ? 1 : 0;
  nof_ies += add_guti_present ? 1 : 0;
  nof_ies += ue_usage_type_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (mme_ue_s1ap_id_present) {
    HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  }
  HANDLE_CODE(s1_msg.pack(bref));
  HANDLE_CODE(mme_group_id.pack(bref));
  if (add_guti_present) {
    HANDLE_CODE(add_guti.pack(bref));
  }
  if (ue_usage_type_present) {
    HANDLE_CODE(ue_usage_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<reroute_nas_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 0:
        mme_ue_s1ap_id_present = true;
        mme_ue_s1ap_id.id      = c.id;
        mme_ue_s1ap_id.crit    = c.crit;
        mme_ue_s1ap_id.value   = c.value.mme_ue_s1ap_id();
        break;
      case 225:
        nof_mandatory_ies--;
        s1_msg.id    = c.id;
        s1_msg.crit  = c.crit;
        s1_msg.value = c.value.s1_msg();
        break;
      case 223:
        nof_mandatory_ies--;
        mme_group_id.id    = c.id;
        mme_group_id.crit  = c.crit;
        mme_group_id.value = c.value.mme_group_id();
        break;
      case 224:
        add_guti_present = true;
        add_guti.id      = c.id;
        add_guti.crit    = c.crit;
        add_guti.value   = c.value.add_guti();
        break;
      case 230:
        ue_usage_type_present = true;
        ue_usage_type.id      = c.id;
        ue_usage_type.crit    = c.crit;
        ue_usage_type.value   = c.value.ue_usage_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reroute_nas_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (mme_ue_s1ap_id_present) {
    j.write_fieldname("");
    mme_ue_s1ap_id.to_json(j);
  }
  j.write_fieldname("");
  s1_msg.to_json(j);
  j.write_fieldname("");
  mme_group_id.to_json(j);
  if (add_guti_present) {
    j.write_fieldname("");
    add_guti.to_json(j);
  }
  if (ue_usage_type_present) {
    j.write_fieldname("");
    ue_usage_type.to_json(j);
  }
  j.end_obj();
}

// RerouteNASRequest ::= SEQUENCE
SRSASN_CODE reroute_nas_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void reroute_nas_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<reset_ies_o>;

reset_ies_container::reset_ies_container() : cause(2, crit_e::ignore), reset_type(92, crit_e::reject) {}
SRSASN_CODE reset_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(reset_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<reset_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 92:
        nof_mandatory_ies--;
        reset_type.id    = c.id;
        reset_type.crit  = c.crit;
        reset_type.value = c.value.reset_type();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reset_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  reset_type.to_json(j);
  j.end_obj();
}

// Reset ::= SEQUENCE
SRSASN_CODE reset_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void reset_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<reset_ack_ies_o>;

reset_ack_ies_container::reset_ack_ies_container() :
  ue_associated_lc_s1_conn_list_res_ack(93, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE reset_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ue_associated_lc_s1_conn_list_res_ack_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ue_associated_lc_s1_conn_list_res_ack_present) {
    HANDLE_CODE(ue_associated_lc_s1_conn_list_res_ack.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<reset_ack_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 93:
        ue_associated_lc_s1_conn_list_res_ack_present = true;
        ue_associated_lc_s1_conn_list_res_ack.id      = c.id;
        ue_associated_lc_s1_conn_list_res_ack.crit    = c.crit;
        ue_associated_lc_s1_conn_list_res_ack.value   = c.value.ue_associated_lc_s1_conn_list_res_ack();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void reset_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_associated_lc_s1_conn_list_res_ack_present) {
    j.write_fieldname("");
    ue_associated_lc_s1_conn_list_res_ack.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// ResetAcknowledge ::= SEQUENCE
SRSASN_CODE reset_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void reset_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// RetrieveUEInformation ::= SEQUENCE
SRSASN_CODE retrieve_ue_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, protocol_ies, 0, 65535, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(protocol_ies, bref, 0, 65535, true));

  return SRSASN_SUCCESS;
}
void retrieve_ue_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<s1_setup_fail_ies_o>;

s1_setup_fail_ies_container::s1_setup_fail_ies_container() :
  cause(2, crit_e::ignore), time_to_wait(65, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE s1_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<s1_setup_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 65:
        time_to_wait_present = true;
        time_to_wait.id      = c.id;
        time_to_wait.crit    = c.crit;
        time_to_wait.value   = c.value.time_to_wait();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void s1_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// S1SetupFailure ::= SEQUENCE
SRSASN_CODE s1_setup_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void s1_setup_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<s1_setup_request_ies_o>;

s1_setup_request_ies_container::s1_setup_request_ies_container() :
  global_enb_id(59, crit_e::reject),
  enbname(60, crit_e::ignore),
  supported_tas(64, crit_e::reject),
  default_paging_drx(137, crit_e::ignore),
  csg_id_list(128, crit_e::reject),
  ue_retention_info(228, crit_e::ignore),
  nb_io_t_default_paging_drx(234, crit_e::ignore),
  connectedeng_nb_list(291, crit_e::ignore)
{}
SRSASN_CODE s1_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += enbname_present ? 1 : 0;
  nof_ies += csg_id_list_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += nb_io_t_default_paging_drx_present ? 1 : 0;
  nof_ies += connectedeng_nb_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(global_enb_id.pack(bref));
  if (enbname_present) {
    HANDLE_CODE(enbname.pack(bref));
  }
  HANDLE_CODE(supported_tas.pack(bref));
  HANDLE_CODE(default_paging_drx.pack(bref));
  if (csg_id_list_present) {
    HANDLE_CODE(csg_id_list.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (nb_io_t_default_paging_drx_present) {
    HANDLE_CODE(nb_io_t_default_paging_drx.pack(bref));
  }
  if (connectedeng_nb_list_present) {
    HANDLE_CODE(connectedeng_nb_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<s1_setup_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 59:
        nof_mandatory_ies--;
        global_enb_id.id    = c.id;
        global_enb_id.crit  = c.crit;
        global_enb_id.value = c.value.global_enb_id();
        break;
      case 60:
        enbname_present = true;
        enbname.id      = c.id;
        enbname.crit    = c.crit;
        enbname.value   = c.value.enbname();
        break;
      case 64:
        nof_mandatory_ies--;
        supported_tas.id    = c.id;
        supported_tas.crit  = c.crit;
        supported_tas.value = c.value.supported_tas();
        break;
      case 137:
        nof_mandatory_ies--;
        default_paging_drx.id    = c.id;
        default_paging_drx.crit  = c.crit;
        default_paging_drx.value = c.value.default_paging_drx();
        break;
      case 128:
        csg_id_list_present = true;
        csg_id_list.id      = c.id;
        csg_id_list.crit    = c.crit;
        csg_id_list.value   = c.value.csg_id_list();
        break;
      case 228:
        ue_retention_info_present = true;
        ue_retention_info.id      = c.id;
        ue_retention_info.crit    = c.crit;
        ue_retention_info.value   = c.value.ue_retention_info();
        break;
      case 234:
        nb_io_t_default_paging_drx_present = true;
        nb_io_t_default_paging_drx.id      = c.id;
        nb_io_t_default_paging_drx.crit    = c.crit;
        nb_io_t_default_paging_drx.value   = c.value.nb_io_t_default_paging_drx();
        break;
      case 291:
        connectedeng_nb_list_present = true;
        connectedeng_nb_list.id      = c.id;
        connectedeng_nb_list.crit    = c.crit;
        connectedeng_nb_list.value   = c.value.connectedeng_nb_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void s1_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  global_enb_id.to_json(j);
  if (enbname_present) {
    j.write_fieldname("");
    enbname.to_json(j);
  }
  j.write_fieldname("");
  supported_tas.to_json(j);
  j.write_fieldname("");
  default_paging_drx.to_json(j);
  if (csg_id_list_present) {
    j.write_fieldname("");
    csg_id_list.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (nb_io_t_default_paging_drx_present) {
    j.write_fieldname("");
    nb_io_t_default_paging_drx.to_json(j);
  }
  if (connectedeng_nb_list_present) {
    j.write_fieldname("");
    connectedeng_nb_list.to_json(j);
  }
  j.end_obj();
}

// S1SetupRequest ::= SEQUENCE
SRSASN_CODE s1_setup_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void s1_setup_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<s1_setup_resp_ies_o>;

s1_setup_resp_ies_container::s1_setup_resp_ies_container() :
  mm_ename(61, crit_e::ignore),
  served_gummeis(105, crit_e::reject),
  relative_mme_capacity(87, crit_e::ignore),
  mme_relay_support_ind(163, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  ue_retention_info(228, crit_e::ignore),
  served_dcns(247, crit_e::ignore)
{}
SRSASN_CODE s1_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mm_ename_present ? 1 : 0;
  nof_ies += mme_relay_support_ind_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += served_dcns_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (mm_ename_present) {
    HANDLE_CODE(mm_ename.pack(bref));
  }
  HANDLE_CODE(served_gummeis.pack(bref));
  HANDLE_CODE(relative_mme_capacity.pack(bref));
  if (mme_relay_support_ind_present) {
    HANDLE_CODE(mme_relay_support_ind.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (served_dcns_present) {
    HANDLE_CODE(served_dcns.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<s1_setup_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 61:
        mm_ename_present = true;
        mm_ename.id      = c.id;
        mm_ename.crit    = c.crit;
        mm_ename.value   = c.value.mm_ename();
        break;
      case 105:
        nof_mandatory_ies--;
        served_gummeis.id    = c.id;
        served_gummeis.crit  = c.crit;
        served_gummeis.value = c.value.served_gummeis();
        break;
      case 87:
        nof_mandatory_ies--;
        relative_mme_capacity.id    = c.id;
        relative_mme_capacity.crit  = c.crit;
        relative_mme_capacity.value = c.value.relative_mme_capacity();
        break;
      case 163:
        mme_relay_support_ind_present = true;
        mme_relay_support_ind.id      = c.id;
        mme_relay_support_ind.crit    = c.crit;
        mme_relay_support_ind.value   = c.value.mme_relay_support_ind();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 228:
        ue_retention_info_present = true;
        ue_retention_info.id      = c.id;
        ue_retention_info.crit    = c.crit;
        ue_retention_info.value   = c.value.ue_retention_info();
        break;
      case 247:
        served_dcns_present = true;
        served_dcns.id      = c.id;
        served_dcns.crit    = c.crit;
        served_dcns.value   = c.value.served_dcns();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void s1_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mm_ename_present) {
    j.write_fieldname("");
    mm_ename.to_json(j);
  }
  j.write_fieldname("");
  served_gummeis.to_json(j);
  j.write_fieldname("");
  relative_mme_capacity.to_json(j);
  if (mme_relay_support_ind_present) {
    j.write_fieldname("");
    mme_relay_support_ind.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (served_dcns_present) {
    j.write_fieldname("");
    served_dcns.to_json(j);
  }
  j.end_obj();
}

// S1SetupResponse ::= SEQUENCE
SRSASN_CODE s1_setup_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE s1_setup_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void s1_setup_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<secondary_rat_data_usage_report_ies_o>;

secondary_rat_data_usage_report_ies_container::secondary_rat_data_usage_report_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore),
  ho_flag(266, crit_e::ignore),
  user_location_info(189, crit_e::ignore),
  time_since_secondary_node_release(297, crit_e::ignore)
{}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_flag_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += time_since_secondary_node_release_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  if (ho_flag_present) {
    HANDLE_CODE(ho_flag.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (time_since_secondary_node_release_present) {
    HANDLE_CODE(time_since_secondary_node_release.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<secondary_rat_data_usage_report_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 264:
        nof_mandatory_ies--;
        secondary_rat_data_usage_report_list.id    = c.id;
        secondary_rat_data_usage_report_list.crit  = c.crit;
        secondary_rat_data_usage_report_list.value = c.value.secondary_rat_data_usage_report_list();
        break;
      case 266:
        ho_flag_present = true;
        ho_flag.id      = c.id;
        ho_flag.crit    = c.crit;
        ho_flag.value   = c.value.ho_flag();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      case 297:
        time_since_secondary_node_release_present = true;
        time_since_secondary_node_release.id      = c.id;
        time_since_secondary_node_release.crit    = c.crit;
        time_since_secondary_node_release.value   = c.value.time_since_secondary_node_release();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  secondary_rat_data_usage_report_list.to_json(j);
  if (ho_flag_present) {
    j.write_fieldname("");
    ho_flag.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (time_since_secondary_node_release_present) {
    j.write_fieldname("");
    time_since_secondary_node_release.to_json(j);
  }
  j.end_obj();
}

// SecondaryRATDataUsageReport ::= SEQUENCE
SRSASN_CODE secondary_rat_data_usage_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<trace_fail_ind_ies_o>;

trace_fail_ind_ies_container::trace_fail_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  e_utran_trace_id(86, crit_e::ignore),
  cause(2, crit_e::ignore)
{}
SRSASN_CODE trace_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(e_utran_trace_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<trace_fail_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 86:
        nof_mandatory_ies--;
        e_utran_trace_id.id    = c.id;
        e_utran_trace_id.crit  = c.crit;
        e_utran_trace_id.value = c.value.e_utran_trace_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  e_utran_trace_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// TraceFailureIndication ::= SEQUENCE
SRSASN_CODE trace_fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void trace_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<trace_start_ies_o>;

trace_start_ies_container::trace_start_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), trace_activation(25, crit_e::ignore)
{}
SRSASN_CODE trace_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(trace_activation.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<trace_start_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 25:
        nof_mandatory_ies--;
        trace_activation.id    = c.id;
        trace_activation.crit  = c.crit;
        trace_activation.value = c.value.trace_activation();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  trace_activation.to_json(j);
  j.end_obj();
}

// TraceStart ::= SEQUENCE
SRSASN_CODE trace_start_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void trace_start_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_cap_info_ind_ies_o>;

ue_cap_info_ind_ies_container::ue_cap_info_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  ue_radio_cap(74, crit_e::ignore),
  ue_radio_cap_for_paging(198, crit_e::ignore),
  ue_application_layer_meas_cap(263, crit_e::ignore),
  lte_m_ind(272, crit_e::ignore)
{}
SRSASN_CODE ue_cap_info_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += ue_application_layer_meas_cap_present ? 1 : 0;
  nof_ies += lte_m_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(ue_radio_cap.pack(bref));
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (ue_application_layer_meas_cap_present) {
    HANDLE_CODE(ue_application_layer_meas_cap.pack(bref));
  }
  if (lte_m_ind_present) {
    HANDLE_CODE(lte_m_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_cap_info_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_cap_info_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 74:
        nof_mandatory_ies--;
        ue_radio_cap.id    = c.id;
        ue_radio_cap.crit  = c.crit;
        ue_radio_cap.value = c.value.ue_radio_cap();
        break;
      case 198:
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = c.id;
        ue_radio_cap_for_paging.crit    = c.crit;
        ue_radio_cap_for_paging.value   = c.value.ue_radio_cap_for_paging();
        break;
      case 263:
        ue_application_layer_meas_cap_present = true;
        ue_application_layer_meas_cap.id      = c.id;
        ue_application_layer_meas_cap.crit    = c.crit;
        ue_application_layer_meas_cap.value   = c.value.ue_application_layer_meas_cap();
        break;
      case 272:
        lte_m_ind_present = true;
        lte_m_ind.id      = c.id;
        lte_m_ind.crit    = c.crit;
        lte_m_ind.value   = c.value.lte_m_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_cap_info_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  ue_radio_cap.to_json(j);
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (ue_application_layer_meas_cap_present) {
    j.write_fieldname("");
    ue_application_layer_meas_cap.to_json(j);
  }
  if (lte_m_ind_present) {
    j.write_fieldname("");
    lte_m_ind.to_json(j);
  }
  j.end_obj();
}

// UECapabilityInfoIndication ::= SEQUENCE
SRSASN_CODE ue_cap_info_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_cap_info_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_cap_info_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_mod_confirm_ies_o>;

ue_context_mod_confirm_ies_container::ue_context_mod_confirm_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  csg_membership_status(146, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ue_context_mod_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_mod_confirm_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// UEContextModificationConfirm ::= SEQUENCE
SRSASN_CODE ue_context_mod_confirm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_confirm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_mod_confirm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_mod_fail_ies_o>;

ue_context_mod_fail_ies_container::ue_context_mod_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ue_context_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_mod_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// UEContextModificationFailure ::= SEQUENCE
SRSASN_CODE ue_context_mod_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_mod_ind_ies_o>;

ue_context_mod_ind_ies_container::ue_context_mod_ind_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), csg_membership_info(226, crit_e::reject)
{}
SRSASN_CODE ue_context_mod_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += csg_membership_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (csg_membership_info_present) {
    HANDLE_CODE(csg_membership_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_mod_ind_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 226:
        csg_membership_info_present = true;
        csg_membership_info.id      = c.id;
        csg_membership_info.crit    = c.crit;
        csg_membership_info.value   = c.value.csg_membership_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (csg_membership_info_present) {
    j.write_fieldname("");
    csg_membership_info.to_json(j);
  }
  j.end_obj();
}

// UEContextModificationIndication ::= SEQUENCE
SRSASN_CODE ue_context_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_mod_request_ies_o>;

ue_context_mod_request_ies_container::ue_context_mod_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  security_key(73, crit_e::reject),
  subscriber_profile_idfor_rfp(106, crit_e::ignore),
  ueaggregate_maximum_bitrate(66, crit_e::ignore),
  cs_fallback_ind(108, crit_e::reject),
  ue_security_cap(107, crit_e::reject),
  csg_membership_status(146, crit_e::ignore),
  registered_lai(159, crit_e::ignore),
  add_cs_fallback_ind(187, crit_e::ignore),
  pro_se_authorized(195, crit_e::ignore),
  srvcc_operation_possible(124, crit_e::ignore),
  srvcc_operation_not_possible(243, crit_e::ignore),
  v2xservices_authorized(240, crit_e::ignore),
  ue_sidelink_aggregate_maximum_bitrate(248, crit_e::ignore),
  nrue_security_cap(269, crit_e::ignore),
  aerial_uesubscription_info(277, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore)
{}
SRSASN_CODE ue_context_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += security_key_present ? 1 : 0;
  nof_ies += subscriber_profile_idfor_rfp_present ? 1 : 0;
  nof_ies += ueaggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += cs_fallback_ind_present ? 1 : 0;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += csg_membership_status_present ? 1 : 0;
  nof_ies += registered_lai_present ? 1 : 0;
  nof_ies += add_cs_fallback_ind_present ? 1 : 0;
  nof_ies += pro_se_authorized_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += srvcc_operation_not_possible_present ? 1 : 0;
  nof_ies += v2xservices_authorized_present ? 1 : 0;
  nof_ies += ue_sidelink_aggregate_maximum_bitrate_present ? 1 : 0;
  nof_ies += nrue_security_cap_present ? 1 : 0;
  nof_ies += aerial_uesubscription_info_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (security_key_present) {
    HANDLE_CODE(security_key.pack(bref));
  }
  if (subscriber_profile_idfor_rfp_present) {
    HANDLE_CODE(subscriber_profile_idfor_rfp.pack(bref));
  }
  if (ueaggregate_maximum_bitrate_present) {
    HANDLE_CODE(ueaggregate_maximum_bitrate.pack(bref));
  }
  if (cs_fallback_ind_present) {
    HANDLE_CODE(cs_fallback_ind.pack(bref));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  if (csg_membership_status_present) {
    HANDLE_CODE(csg_membership_status.pack(bref));
  }
  if (registered_lai_present) {
    HANDLE_CODE(registered_lai.pack(bref));
  }
  if (add_cs_fallback_ind_present) {
    HANDLE_CODE(add_cs_fallback_ind.pack(bref));
  }
  if (pro_se_authorized_present) {
    HANDLE_CODE(pro_se_authorized.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (srvcc_operation_not_possible_present) {
    HANDLE_CODE(srvcc_operation_not_possible.pack(bref));
  }
  if (v2xservices_authorized_present) {
    HANDLE_CODE(v2xservices_authorized.pack(bref));
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    HANDLE_CODE(ue_sidelink_aggregate_maximum_bitrate.pack(bref));
  }
  if (nrue_security_cap_present) {
    HANDLE_CODE(nrue_security_cap.pack(bref));
  }
  if (aerial_uesubscription_info_present) {
    HANDLE_CODE(aerial_uesubscription_info.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_mod_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 73:
        security_key_present = true;
        security_key.id      = c.id;
        security_key.crit    = c.crit;
        security_key.value   = c.value.security_key();
        break;
      case 106:
        subscriber_profile_idfor_rfp_present = true;
        subscriber_profile_idfor_rfp.id      = c.id;
        subscriber_profile_idfor_rfp.crit    = c.crit;
        subscriber_profile_idfor_rfp.value   = c.value.subscriber_profile_idfor_rfp();
        break;
      case 66:
        ueaggregate_maximum_bitrate_present = true;
        ueaggregate_maximum_bitrate.id      = c.id;
        ueaggregate_maximum_bitrate.crit    = c.crit;
        ueaggregate_maximum_bitrate.value   = c.value.ueaggregate_maximum_bitrate();
        break;
      case 108:
        cs_fallback_ind_present = true;
        cs_fallback_ind.id      = c.id;
        cs_fallback_ind.crit    = c.crit;
        cs_fallback_ind.value   = c.value.cs_fallback_ind();
        break;
      case 107:
        ue_security_cap_present = true;
        ue_security_cap.id      = c.id;
        ue_security_cap.crit    = c.crit;
        ue_security_cap.value   = c.value.ue_security_cap();
        break;
      case 146:
        csg_membership_status_present = true;
        csg_membership_status.id      = c.id;
        csg_membership_status.crit    = c.crit;
        csg_membership_status.value   = c.value.csg_membership_status();
        break;
      case 159:
        registered_lai_present = true;
        registered_lai.id      = c.id;
        registered_lai.crit    = c.crit;
        registered_lai.value   = c.value.registered_lai();
        break;
      case 187:
        add_cs_fallback_ind_present = true;
        add_cs_fallback_ind.id      = c.id;
        add_cs_fallback_ind.crit    = c.crit;
        add_cs_fallback_ind.value   = c.value.add_cs_fallback_ind();
        break;
      case 195:
        pro_se_authorized_present = true;
        pro_se_authorized.id      = c.id;
        pro_se_authorized.crit    = c.crit;
        pro_se_authorized.value   = c.value.pro_se_authorized();
        break;
      case 124:
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = c.id;
        srvcc_operation_possible.crit    = c.crit;
        srvcc_operation_possible.value   = c.value.srvcc_operation_possible();
        break;
      case 243:
        srvcc_operation_not_possible_present = true;
        srvcc_operation_not_possible.id      = c.id;
        srvcc_operation_not_possible.crit    = c.crit;
        srvcc_operation_not_possible.value   = c.value.srvcc_operation_not_possible();
        break;
      case 240:
        v2xservices_authorized_present = true;
        v2xservices_authorized.id      = c.id;
        v2xservices_authorized.crit    = c.crit;
        v2xservices_authorized.value   = c.value.v2xservices_authorized();
        break;
      case 248:
        ue_sidelink_aggregate_maximum_bitrate_present = true;
        ue_sidelink_aggregate_maximum_bitrate.id      = c.id;
        ue_sidelink_aggregate_maximum_bitrate.crit    = c.crit;
        ue_sidelink_aggregate_maximum_bitrate.value   = c.value.ue_sidelink_aggregate_maximum_bitrate();
        break;
      case 269:
        nrue_security_cap_present = true;
        nrue_security_cap.id      = c.id;
        nrue_security_cap.crit    = c.crit;
        nrue_security_cap.value   = c.value.nrue_security_cap();
        break;
      case 277:
        aerial_uesubscription_info_present = true;
        aerial_uesubscription_info.id      = c.id;
        aerial_uesubscription_info.crit    = c.crit;
        aerial_uesubscription_info.value   = c.value.aerial_uesubscription_info();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.value   = c.value.add_rrm_prio_idx();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (security_key_present) {
    j.write_fieldname("");
    security_key.to_json(j);
  }
  if (subscriber_profile_idfor_rfp_present) {
    j.write_fieldname("");
    subscriber_profile_idfor_rfp.to_json(j);
  }
  if (ueaggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ueaggregate_maximum_bitrate.to_json(j);
  }
  if (cs_fallback_ind_present) {
    j.write_fieldname("");
    cs_fallback_ind.to_json(j);
  }
  if (ue_security_cap_present) {
    j.write_fieldname("");
    ue_security_cap.to_json(j);
  }
  if (csg_membership_status_present) {
    j.write_fieldname("");
    csg_membership_status.to_json(j);
  }
  if (registered_lai_present) {
    j.write_fieldname("");
    registered_lai.to_json(j);
  }
  if (add_cs_fallback_ind_present) {
    j.write_fieldname("");
    add_cs_fallback_ind.to_json(j);
  }
  if (pro_se_authorized_present) {
    j.write_fieldname("");
    pro_se_authorized.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (srvcc_operation_not_possible_present) {
    j.write_fieldname("");
    srvcc_operation_not_possible.to_json(j);
  }
  if (v2xservices_authorized_present) {
    j.write_fieldname("");
    v2xservices_authorized.to_json(j);
  }
  if (ue_sidelink_aggregate_maximum_bitrate_present) {
    j.write_fieldname("");
    ue_sidelink_aggregate_maximum_bitrate.to_json(j);
  }
  if (nrue_security_cap_present) {
    j.write_fieldname("");
    nrue_security_cap.to_json(j);
  }
  if (aerial_uesubscription_info_present) {
    j.write_fieldname("");
    aerial_uesubscription_info.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  j.end_obj();
}

// UEContextModificationRequest ::= SEQUENCE
SRSASN_CODE ue_context_mod_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_mod_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_mod_resp_ies_o>;

ue_context_mod_resp_ies_container::ue_context_mod_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore), enb_ue_s1ap_id(8, crit_e::ignore), crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ue_context_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_mod_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// UEContextModificationResponse ::= SEQUENCE
SRSASN_CODE ue_context_mod_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_release_cmd_ies_o>;

ue_context_release_cmd_ies_container::ue_context_release_cmd_ies_container() :
  ue_s1ap_ids(99, crit_e::reject), cause(2, crit_e::ignore)
{}
SRSASN_CODE ue_context_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_s1ap_ids.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_release_cmd_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 99:
        nof_mandatory_ies--;
        ue_s1ap_ids.id    = c.id;
        ue_s1ap_ids.crit  = c.crit;
        ue_s1ap_ids.value = c.value.ue_s1ap_ids();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_s1ap_ids.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// UEContextReleaseCommand ::= SEQUENCE
SRSASN_CODE ue_context_release_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_release_complete_ies_o>;

ue_context_release_complete_ies_container::ue_context_release_complete_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  user_location_info(189, crit_e::ignore),
  info_on_recommended_cells_and_enbs_for_paging(213, crit_e::ignore),
  cell_id_and_ce_level_for_ce_capable_ues(212, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore),
  time_since_secondary_node_release(297, crit_e::ignore)
{}
SRSASN_CODE ue_context_release_complete_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_enbs_for_paging_present ? 1 : 0;
  nof_ies += cell_id_and_ce_level_for_ce_capable_ues_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  nof_ies += time_since_secondary_node_release_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (info_on_recommended_cells_and_enbs_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_enbs_for_paging.pack(bref));
  }
  if (cell_id_and_ce_level_for_ce_capable_ues_present) {
    HANDLE_CODE(cell_id_and_ce_level_for_ce_capable_ues.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }
  if (time_since_secondary_node_release_present) {
    HANDLE_CODE(time_since_secondary_node_release.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_release_complete_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      case 213:
        info_on_recommended_cells_and_enbs_for_paging_present = true;
        info_on_recommended_cells_and_enbs_for_paging.id      = c.id;
        info_on_recommended_cells_and_enbs_for_paging.crit    = c.crit;
        info_on_recommended_cells_and_enbs_for_paging.value   = c.value.info_on_recommended_cells_and_enbs_for_paging();
        break;
      case 212:
        cell_id_and_ce_level_for_ce_capable_ues_present = true;
        cell_id_and_ce_level_for_ce_capable_ues.id      = c.id;
        cell_id_and_ce_level_for_ce_capable_ues.crit    = c.crit;
        cell_id_and_ce_level_for_ce_capable_ues.value   = c.value.cell_id_and_ce_level_for_ce_capable_ues();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      case 297:
        time_since_secondary_node_release_present = true;
        time_since_secondary_node_release.id      = c.id;
        time_since_secondary_node_release.crit    = c.crit;
        time_since_secondary_node_release.value   = c.value.time_since_secondary_node_release();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_complete_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (info_on_recommended_cells_and_enbs_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_enbs_for_paging.to_json(j);
  }
  if (cell_id_and_ce_level_for_ce_capable_ues_present) {
    j.write_fieldname("");
    cell_id_and_ce_level_for_ce_capable_ues.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  if (time_since_secondary_node_release_present) {
    j.write_fieldname("");
    time_since_secondary_node_release.to_json(j);
  }
  j.end_obj();
}

// UEContextReleaseComplete ::= SEQUENCE
SRSASN_CODE ue_context_release_complete_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_release_complete_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_release_request_ies_o>;

ue_context_release_request_ies_container::ue_context_release_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  cause(2, crit_e::ignore),
  gw_context_release_ind(164, crit_e::reject),
  secondary_rat_data_usage_report_list(264, crit_e::ignore)
{}
SRSASN_CODE ue_context_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += gw_context_release_ind_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (gw_context_release_ind_present) {
    HANDLE_CODE(gw_context_release_ind.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_release_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 164:
        gw_context_release_ind_present = true;
        gw_context_release_ind.id      = c.id;
        gw_context_release_ind.crit    = c.crit;
        gw_context_release_ind.value   = c.value.gw_context_release_ind();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (gw_context_release_ind_present) {
    j.write_fieldname("");
    gw_context_release_ind.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  j.end_obj();
}

// UEContextReleaseRequest ::= SEQUENCE
SRSASN_CODE ue_context_release_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_release_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_resume_fail_ies_o>;

ue_context_resume_fail_ies_container::ue_context_resume_fail_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  cause(2, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ue_context_resume_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_resume_fail_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 2:
        nof_mandatory_ies--;
        cause.id    = c.id;
        cause.crit  = c.crit;
        cause.value = c.value.cause();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeFailure ::= SEQUENCE
SRSASN_CODE ue_context_resume_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_resume_request_ies_o>;

ue_context_resume_request_ies_container::ue_context_resume_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  erab_failed_to_resume_list_resume_req(235, crit_e::reject),
  rrc_resume_cause(245, crit_e::ignore)
{}
SRSASN_CODE ue_context_resume_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_failed_to_resume_list_resume_req_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_failed_to_resume_list_resume_req_present) {
    HANDLE_CODE(erab_failed_to_resume_list_resume_req.pack(bref));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_resume_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 235:
        erab_failed_to_resume_list_resume_req_present = true;
        erab_failed_to_resume_list_resume_req.id      = c.id;
        erab_failed_to_resume_list_resume_req.crit    = c.crit;
        erab_failed_to_resume_list_resume_req.value   = c.value.erab_failed_to_resume_list_resume_req();
        break;
      case 245:
        rrc_resume_cause_present = true;
        rrc_resume_cause.id      = c.id;
        rrc_resume_cause.crit    = c.crit;
        rrc_resume_cause.value   = c.value.rrc_resume_cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_failed_to_resume_list_resume_req_present) {
    j.write_fieldname("");
    erab_failed_to_resume_list_resume_req.to_json(j);
  }
  if (rrc_resume_cause_present) {
    j.write_fieldname("");
    rrc_resume_cause.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeRequest ::= SEQUENCE
SRSASN_CODE ue_context_resume_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_resume_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_resume_resp_ies_o>;

ue_context_resume_resp_ies_container::ue_context_resume_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  erab_failed_to_resume_list_resume_res(237, crit_e::reject),
  crit_diagnostics(58, crit_e::ignore),
  security_context(40, crit_e::reject),
  pending_data_ind(283, crit_e::ignore)
{}
SRSASN_CODE ue_context_resume_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += erab_failed_to_resume_list_resume_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (erab_failed_to_resume_list_resume_res_present) {
    HANDLE_CODE(erab_failed_to_resume_list_resume_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_resume_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 237:
        erab_failed_to_resume_list_resume_res_present = true;
        erab_failed_to_resume_list_resume_res.id      = c.id;
        erab_failed_to_resume_list_resume_res.crit    = c.crit;
        erab_failed_to_resume_list_resume_res.value   = c.value.erab_failed_to_resume_list_resume_res();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 40:
        security_context_present = true;
        security_context.id      = c.id;
        security_context.crit    = c.crit;
        security_context.value   = c.value.security_context();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (erab_failed_to_resume_list_resume_res_present) {
    j.write_fieldname("");
    erab_failed_to_resume_list_resume_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeResponse ::= SEQUENCE
SRSASN_CODE ue_context_resume_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_suspend_request_ies_o>;

ue_context_suspend_request_ies_container::ue_context_suspend_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  info_on_recommended_cells_and_enbs_for_paging(213, crit_e::ignore),
  cell_id_and_ce_level_for_ce_capable_ues(212, crit_e::ignore),
  secondary_rat_data_usage_report_list(264, crit_e::ignore),
  user_location_info(189, crit_e::ignore),
  time_since_secondary_node_release(297, crit_e::ignore)
{}
SRSASN_CODE ue_context_suspend_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += info_on_recommended_cells_and_enbs_for_paging_present ? 1 : 0;
  nof_ies += cell_id_and_ce_level_for_ce_capable_ues_present ? 1 : 0;
  nof_ies += secondary_rat_data_usage_report_list_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += time_since_secondary_node_release_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (info_on_recommended_cells_and_enbs_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_enbs_for_paging.pack(bref));
  }
  if (cell_id_and_ce_level_for_ce_capable_ues_present) {
    HANDLE_CODE(cell_id_and_ce_level_for_ce_capable_ues.pack(bref));
  }
  if (secondary_rat_data_usage_report_list_present) {
    HANDLE_CODE(secondary_rat_data_usage_report_list.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (time_since_secondary_node_release_present) {
    HANDLE_CODE(time_since_secondary_node_release.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_suspend_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 213:
        info_on_recommended_cells_and_enbs_for_paging_present = true;
        info_on_recommended_cells_and_enbs_for_paging.id      = c.id;
        info_on_recommended_cells_and_enbs_for_paging.crit    = c.crit;
        info_on_recommended_cells_and_enbs_for_paging.value   = c.value.info_on_recommended_cells_and_enbs_for_paging();
        break;
      case 212:
        cell_id_and_ce_level_for_ce_capable_ues_present = true;
        cell_id_and_ce_level_for_ce_capable_ues.id      = c.id;
        cell_id_and_ce_level_for_ce_capable_ues.crit    = c.crit;
        cell_id_and_ce_level_for_ce_capable_ues.value   = c.value.cell_id_and_ce_level_for_ce_capable_ues();
        break;
      case 264:
        secondary_rat_data_usage_report_list_present = true;
        secondary_rat_data_usage_report_list.id      = c.id;
        secondary_rat_data_usage_report_list.crit    = c.crit;
        secondary_rat_data_usage_report_list.value   = c.value.secondary_rat_data_usage_report_list();
        break;
      case 189:
        user_location_info_present = true;
        user_location_info.id      = c.id;
        user_location_info.crit    = c.crit;
        user_location_info.value   = c.value.user_location_info();
        break;
      case 297:
        time_since_secondary_node_release_present = true;
        time_since_secondary_node_release.id      = c.id;
        time_since_secondary_node_release.crit    = c.crit;
        time_since_secondary_node_release.value   = c.value.time_since_secondary_node_release();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (info_on_recommended_cells_and_enbs_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_enbs_for_paging.to_json(j);
  }
  if (cell_id_and_ce_level_for_ce_capable_ues_present) {
    j.write_fieldname("");
    cell_id_and_ce_level_for_ce_capable_ues.to_json(j);
  }
  if (secondary_rat_data_usage_report_list_present) {
    j.write_fieldname("");
    secondary_rat_data_usage_report_list.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (time_since_secondary_node_release_present) {
    j.write_fieldname("");
    time_since_secondary_node_release.to_json(j);
  }
  j.end_obj();
}

// UEContextSuspendRequest ::= SEQUENCE
SRSASN_CODE ue_context_suspend_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_context_suspend_resp_ies_o>;

ue_context_suspend_resp_ies_container::ue_context_suspend_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore),
  security_context(40, crit_e::reject)
{}
SRSASN_CODE ue_context_suspend_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_context_suspend_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      case 40:
        security_context_present = true;
        security_context.id      = c.id;
        security_context.crit    = c.crit;
        security_context.value   = c.value.security_context();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  j.end_obj();
}

// UEContextSuspendResponse ::= SEQUENCE
SRSASN_CODE ue_context_suspend_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_info_transfer_ies_o>;

ue_info_transfer_ies_container::ue_info_transfer_ies_container() :
  s_tmsi(96, crit_e::reject),
  ue_level_qos_params(252, crit_e::ignore),
  ue_radio_cap(74, crit_e::ignore),
  subscription_based_ue_differentiation_info(278, crit_e::ignore),
  pending_data_ind(283, crit_e::ignore)
{}
SRSASN_CODE ue_info_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += ue_level_qos_params_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += subscription_based_ue_differentiation_info_present ? 1 : 0;
  nof_ies += pending_data_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(s_tmsi.pack(bref));
  if (ue_level_qos_params_present) {
    HANDLE_CODE(ue_level_qos_params.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (subscription_based_ue_differentiation_info_present) {
    HANDLE_CODE(subscription_based_ue_differentiation_info.pack(bref));
  }
  if (pending_data_ind_present) {
    HANDLE_CODE(pending_data_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_info_transfer_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 96:
        nof_mandatory_ies--;
        s_tmsi.id    = c.id;
        s_tmsi.crit  = c.crit;
        s_tmsi.value = c.value.s_tmsi();
        break;
      case 252:
        ue_level_qos_params_present = true;
        ue_level_qos_params.id      = c.id;
        ue_level_qos_params.crit    = c.crit;
        ue_level_qos_params.value   = c.value.ue_level_qos_params();
        break;
      case 74:
        ue_radio_cap_present = true;
        ue_radio_cap.id      = c.id;
        ue_radio_cap.crit    = c.crit;
        ue_radio_cap.value   = c.value.ue_radio_cap();
        break;
      case 278:
        subscription_based_ue_differentiation_info_present = true;
        subscription_based_ue_differentiation_info.id      = c.id;
        subscription_based_ue_differentiation_info.crit    = c.crit;
        subscription_based_ue_differentiation_info.value   = c.value.subscription_based_ue_differentiation_info();
        break;
      case 283:
        pending_data_ind_present = true;
        pending_data_ind.id      = c.id;
        pending_data_ind.crit    = c.crit;
        pending_data_ind.value   = c.value.pending_data_ind();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_info_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  s_tmsi.to_json(j);
  if (ue_level_qos_params_present) {
    j.write_fieldname("");
    ue_level_qos_params.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (subscription_based_ue_differentiation_info_present) {
    j.write_fieldname("");
    subscription_based_ue_differentiation_info.to_json(j);
  }
  if (pending_data_ind_present) {
    j.write_fieldname("");
    pending_data_ind.to_json(j);
  }
  j.end_obj();
}

// UEInformationTransfer ::= SEQUENCE
SRSASN_CODE ue_info_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_info_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_radio_cap_match_request_ies_o>;

ue_radio_cap_match_request_ies_container::ue_radio_cap_match_request_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject), enb_ue_s1ap_id(8, crit_e::reject), ue_radio_cap(74, crit_e::ignore)
{}
SRSASN_CODE ue_radio_cap_match_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_radio_cap_match_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 74:
        ue_radio_cap_present = true;
        ue_radio_cap.id      = c.id;
        ue_radio_cap.crit    = c.crit;
        ue_radio_cap.value   = c.value.ue_radio_cap();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_match_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  j.end_obj();
}

// UERadioCapabilityMatchRequest ::= SEQUENCE
SRSASN_CODE ue_radio_cap_match_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_radio_cap_match_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ue_radio_cap_match_resp_ies_o>;

ue_radio_cap_match_resp_ies_container::ue_radio_cap_match_resp_ies_container() :
  mme_ue_s1ap_id(0, crit_e::ignore),
  enb_ue_s1ap_id(8, crit_e::ignore),
  voice_support_match_ind(169, crit_e::reject),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE ue_radio_cap_match_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(voice_support_match_ind.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ue_radio_cap_match_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 169:
        nof_mandatory_ies--;
        voice_support_match_ind.id    = c.id;
        voice_support_match_ind.crit  = c.crit;
        voice_support_match_ind.value = c.value.voice_support_match_ind();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_match_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  voice_support_match_ind.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// UERadioCapabilityMatchResponse ::= SEQUENCE
SRSASN_CODE ue_radio_cap_match_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_match_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ue_radio_cap_match_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ul_nas_transport_ies_o>;

ul_nas_transport_ies_container::ul_nas_transport_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  nas_pdu(26, crit_e::reject),
  eutran_cgi(100, crit_e::ignore),
  tai(67, crit_e::ignore),
  gw_transport_layer_address(155, crit_e::ignore),
  sipto_l_gw_transport_layer_address(184, crit_e::ignore),
  lhn_id(186, crit_e::ignore),
  ps_cell_info(288, crit_e::ignore)
{}
SRSASN_CODE ul_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += gw_transport_layer_address_present ? 1 : 0;
  nof_ies += sipto_l_gw_transport_layer_address_present ? 1 : 0;
  nof_ies += lhn_id_present ? 1 : 0;
  nof_ies += ps_cell_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(eutran_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (gw_transport_layer_address_present) {
    HANDLE_CODE(gw_transport_layer_address.pack(bref));
  }
  if (sipto_l_gw_transport_layer_address_present) {
    HANDLE_CODE(sipto_l_gw_transport_layer_address.pack(bref));
  }
  if (lhn_id_present) {
    HANDLE_CODE(lhn_id.pack(bref));
  }
  if (ps_cell_info_present) {
    HANDLE_CODE(ps_cell_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ul_nas_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 26:
        nof_mandatory_ies--;
        nas_pdu.id    = c.id;
        nas_pdu.crit  = c.crit;
        nas_pdu.value = c.value.nas_pdu();
        break;
      case 100:
        nof_mandatory_ies--;
        eutran_cgi.id    = c.id;
        eutran_cgi.crit  = c.crit;
        eutran_cgi.value = c.value.eutran_cgi();
        break;
      case 67:
        nof_mandatory_ies--;
        tai.id    = c.id;
        tai.crit  = c.crit;
        tai.value = c.value.tai();
        break;
      case 155:
        gw_transport_layer_address_present = true;
        gw_transport_layer_address.id      = c.id;
        gw_transport_layer_address.crit    = c.crit;
        gw_transport_layer_address.value   = c.value.gw_transport_layer_address();
        break;
      case 184:
        sipto_l_gw_transport_layer_address_present = true;
        sipto_l_gw_transport_layer_address.id      = c.id;
        sipto_l_gw_transport_layer_address.crit    = c.crit;
        sipto_l_gw_transport_layer_address.value   = c.value.sipto_l_gw_transport_layer_address();
        break;
      case 186:
        lhn_id_present = true;
        lhn_id.id      = c.id;
        lhn_id.crit    = c.crit;
        lhn_id.value   = c.value.lhn_id();
        break;
      case 288:
        ps_cell_info_present = true;
        ps_cell_info.id      = c.id;
        ps_cell_info.crit    = c.crit;
        ps_cell_info.value   = c.value.ps_cell_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  eutran_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  if (gw_transport_layer_address_present) {
    j.write_fieldname("");
    gw_transport_layer_address.to_json(j);
  }
  if (sipto_l_gw_transport_layer_address_present) {
    j.write_fieldname("");
    sipto_l_gw_transport_layer_address.to_json(j);
  }
  if (lhn_id_present) {
    j.write_fieldname("");
    lhn_id.to_json(j);
  }
  if (ps_cell_info_present) {
    j.write_fieldname("");
    ps_cell_info.to_json(j);
  }
  j.end_obj();
}

// UplinkNASTransport ::= SEQUENCE
SRSASN_CODE ul_nas_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ul_nas_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ul_non_ueassociated_lp_pa_transport_ies_o>;

ul_non_ueassociated_lp_pa_transport_ies_container::ul_non_ueassociated_lp_pa_transport_ies_container() :
  routing_id(148, crit_e::reject), lp_pa_pdu(147, crit_e::reject)
{}
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(lp_pa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ul_non_ueassociated_lp_pa_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 148:
        nof_mandatory_ies--;
        routing_id.id    = c.id;
        routing_id.crit  = c.crit;
        routing_id.value = c.value.routing_id();
        break;
      case 147:
        nof_mandatory_ies--;
        lp_pa_pdu.id    = c.id;
        lp_pa_pdu.crit  = c.crit;
        lp_pa_pdu.value = c.value.lp_pa_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_non_ueassociated_lp_pa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  lp_pa_pdu.to_json(j);
  j.end_obj();
}

// UplinkNonUEAssociatedLPPaTransport ::= SEQUENCE
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ueassociated_lp_pa_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ul_non_ueassociated_lp_pa_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ul_s1cdma2000tunnelling_ies_o>;

ul_s1cdma2000tunnelling_ies_container::ul_s1cdma2000tunnelling_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  cdma2000_rat_type(71, crit_e::reject),
  cdma2000_sector_id(72, crit_e::reject),
  cdma2000_ho_required_ind(84, crit_e::ignore),
  cdma2000_one_xsrvcc_info(102, crit_e::reject),
  cdma2000_one_xrand(97, crit_e::reject),
  cdma2000_pdu(70, crit_e::reject),
  eutran_round_trip_delay_estimation_info(140, crit_e::ignore)
{}
SRSASN_CODE ul_s1cdma2000tunnelling_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += cdma2000_ho_required_ind_present ? 1 : 0;
  nof_ies += cdma2000_one_xsrvcc_info_present ? 1 : 0;
  nof_ies += cdma2000_one_xrand_present ? 1 : 0;
  nof_ies += eutran_round_trip_delay_estimation_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(cdma2000_rat_type.pack(bref));
  HANDLE_CODE(cdma2000_sector_id.pack(bref));
  if (cdma2000_ho_required_ind_present) {
    HANDLE_CODE(cdma2000_ho_required_ind.pack(bref));
  }
  if (cdma2000_one_xsrvcc_info_present) {
    HANDLE_CODE(cdma2000_one_xsrvcc_info.pack(bref));
  }
  if (cdma2000_one_xrand_present) {
    HANDLE_CODE(cdma2000_one_xrand.pack(bref));
  }
  HANDLE_CODE(cdma2000_pdu.pack(bref));
  if (eutran_round_trip_delay_estimation_info_present) {
    HANDLE_CODE(eutran_round_trip_delay_estimation_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_s1cdma2000tunnelling_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ul_s1cdma2000tunnelling_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 71:
        nof_mandatory_ies--;
        cdma2000_rat_type.id    = c.id;
        cdma2000_rat_type.crit  = c.crit;
        cdma2000_rat_type.value = c.value.cdma2000_rat_type();
        break;
      case 72:
        nof_mandatory_ies--;
        cdma2000_sector_id.id    = c.id;
        cdma2000_sector_id.crit  = c.crit;
        cdma2000_sector_id.value = c.value.cdma2000_sector_id();
        break;
      case 84:
        cdma2000_ho_required_ind_present = true;
        cdma2000_ho_required_ind.id      = c.id;
        cdma2000_ho_required_ind.crit    = c.crit;
        cdma2000_ho_required_ind.value   = c.value.cdma2000_ho_required_ind();
        break;
      case 102:
        cdma2000_one_xsrvcc_info_present = true;
        cdma2000_one_xsrvcc_info.id      = c.id;
        cdma2000_one_xsrvcc_info.crit    = c.crit;
        cdma2000_one_xsrvcc_info.value   = c.value.cdma2000_one_xsrvcc_info();
        break;
      case 97:
        cdma2000_one_xrand_present = true;
        cdma2000_one_xrand.id      = c.id;
        cdma2000_one_xrand.crit    = c.crit;
        cdma2000_one_xrand.value   = c.value.cdma2000_one_xrand();
        break;
      case 70:
        nof_mandatory_ies--;
        cdma2000_pdu.id    = c.id;
        cdma2000_pdu.crit  = c.crit;
        cdma2000_pdu.value = c.value.cdma2000_pdu();
        break;
      case 140:
        eutran_round_trip_delay_estimation_info_present = true;
        eutran_round_trip_delay_estimation_info.id      = c.id;
        eutran_round_trip_delay_estimation_info.crit    = c.crit;
        eutran_round_trip_delay_estimation_info.value   = c.value.eutran_round_trip_delay_estimation_info();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_s1cdma2000tunnelling_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  cdma2000_rat_type.to_json(j);
  j.write_fieldname("");
  cdma2000_sector_id.to_json(j);
  if (cdma2000_ho_required_ind_present) {
    j.write_fieldname("");
    cdma2000_ho_required_ind.to_json(j);
  }
  if (cdma2000_one_xsrvcc_info_present) {
    j.write_fieldname("");
    cdma2000_one_xsrvcc_info.to_json(j);
  }
  if (cdma2000_one_xrand_present) {
    j.write_fieldname("");
    cdma2000_one_xrand.to_json(j);
  }
  j.write_fieldname("");
  cdma2000_pdu.to_json(j);
  if (eutran_round_trip_delay_estimation_info_present) {
    j.write_fieldname("");
    eutran_round_trip_delay_estimation_info.to_json(j);
  }
  j.end_obj();
}

// UplinkS1cdma2000tunnelling ::= SEQUENCE
SRSASN_CODE ul_s1cdma2000tunnelling_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_s1cdma2000tunnelling_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ul_s1cdma2000tunnelling_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<ul_ueassociated_lp_pa_transport_ies_o>;

ul_ueassociated_lp_pa_transport_ies_container::ul_ueassociated_lp_pa_transport_ies_container() :
  mme_ue_s1ap_id(0, crit_e::reject),
  enb_ue_s1ap_id(8, crit_e::reject),
  routing_id(148, crit_e::reject),
  lp_pa_pdu(147, crit_e::reject)
{}
SRSASN_CODE ul_ueassociated_lp_pa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mme_ue_s1ap_id.pack(bref));
  HANDLE_CODE(enb_ue_s1ap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(lp_pa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ueassociated_lp_pa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<ul_ueassociated_lp_pa_transport_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 0:
        nof_mandatory_ies--;
        mme_ue_s1ap_id.id    = c.id;
        mme_ue_s1ap_id.crit  = c.crit;
        mme_ue_s1ap_id.value = c.value.mme_ue_s1ap_id();
        break;
      case 8:
        nof_mandatory_ies--;
        enb_ue_s1ap_id.id    = c.id;
        enb_ue_s1ap_id.crit  = c.crit;
        enb_ue_s1ap_id.value = c.value.enb_ue_s1ap_id();
        break;
      case 148:
        nof_mandatory_ies--;
        routing_id.id    = c.id;
        routing_id.crit  = c.crit;
        routing_id.value = c.value.routing_id();
        break;
      case 147:
        nof_mandatory_ies--;
        lp_pa_pdu.id    = c.id;
        lp_pa_pdu.crit  = c.crit;
        lp_pa_pdu.value = c.value.lp_pa_pdu();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ueassociated_lp_pa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mme_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  enb_ue_s1ap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  lp_pa_pdu.to_json(j);
  j.end_obj();
}

// UplinkUEAssociatedLPPaTransport ::= SEQUENCE
SRSASN_CODE ul_ueassociated_lp_pa_transport_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ueassociated_lp_pa_transport_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void ul_ueassociated_lp_pa_transport_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<write_replace_warning_request_ies_o>;

write_replace_warning_request_ies_container::write_replace_warning_request_ies_container() :
  msg_id(111, crit_e::reject),
  serial_num(112, crit_e::reject),
  warning_area_list(113, crit_e::ignore),
  repeat_period(114, crit_e::reject),
  extended_repeat_period(144, crit_e::reject),
  numof_broadcast_request(115, crit_e::reject),
  warning_type(116, crit_e::ignore),
  warning_security_info(117, crit_e::ignore),
  data_coding_scheme(118, crit_e::ignore),
  warning_msg_contents(119, crit_e::ignore),
  concurrent_warning_msg_ind(142, crit_e::reject),
  warning_area_coordinates(286, crit_e::ignore)
{}
SRSASN_CODE write_replace_warning_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += extended_repeat_period_present ? 1 : 0;
  nof_ies += warning_type_present ? 1 : 0;
  nof_ies += warning_security_info_present ? 1 : 0;
  nof_ies += data_coding_scheme_present ? 1 : 0;
  nof_ies += warning_msg_contents_present ? 1 : 0;
  nof_ies += concurrent_warning_msg_ind_present ? 1 : 0;
  nof_ies += warning_area_coordinates_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  HANDLE_CODE(repeat_period.pack(bref));
  if (extended_repeat_period_present) {
    HANDLE_CODE(extended_repeat_period.pack(bref));
  }
  HANDLE_CODE(numof_broadcast_request.pack(bref));
  if (warning_type_present) {
    HANDLE_CODE(warning_type.pack(bref));
  }
  if (warning_security_info_present) {
    HANDLE_CODE(warning_security_info.pack(bref));
  }
  if (data_coding_scheme_present) {
    HANDLE_CODE(data_coding_scheme.pack(bref));
  }
  if (warning_msg_contents_present) {
    HANDLE_CODE(warning_msg_contents.pack(bref));
  }
  if (concurrent_warning_msg_ind_present) {
    HANDLE_CODE(concurrent_warning_msg_ind.pack(bref));
  }
  if (warning_area_coordinates_present) {
    HANDLE_CODE(warning_area_coordinates.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<write_replace_warning_request_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 111:
        nof_mandatory_ies--;
        msg_id.id    = c.id;
        msg_id.crit  = c.crit;
        msg_id.value = c.value.msg_id();
        break;
      case 112:
        nof_mandatory_ies--;
        serial_num.id    = c.id;
        serial_num.crit  = c.crit;
        serial_num.value = c.value.serial_num();
        break;
      case 113:
        warning_area_list_present = true;
        warning_area_list.id      = c.id;
        warning_area_list.crit    = c.crit;
        warning_area_list.value   = c.value.warning_area_list();
        break;
      case 114:
        nof_mandatory_ies--;
        repeat_period.id    = c.id;
        repeat_period.crit  = c.crit;
        repeat_period.value = c.value.repeat_period();
        break;
      case 144:
        extended_repeat_period_present = true;
        extended_repeat_period.id      = c.id;
        extended_repeat_period.crit    = c.crit;
        extended_repeat_period.value   = c.value.extended_repeat_period();
        break;
      case 115:
        nof_mandatory_ies--;
        numof_broadcast_request.id    = c.id;
        numof_broadcast_request.crit  = c.crit;
        numof_broadcast_request.value = c.value.numof_broadcast_request();
        break;
      case 116:
        warning_type_present = true;
        warning_type.id      = c.id;
        warning_type.crit    = c.crit;
        warning_type.value   = c.value.warning_type();
        break;
      case 117:
        warning_security_info_present = true;
        warning_security_info.id      = c.id;
        warning_security_info.crit    = c.crit;
        warning_security_info.value   = c.value.warning_security_info();
        break;
      case 118:
        data_coding_scheme_present = true;
        data_coding_scheme.id      = c.id;
        data_coding_scheme.crit    = c.crit;
        data_coding_scheme.value   = c.value.data_coding_scheme();
        break;
      case 119:
        warning_msg_contents_present = true;
        warning_msg_contents.id      = c.id;
        warning_msg_contents.crit    = c.crit;
        warning_msg_contents.value   = c.value.warning_msg_contents();
        break;
      case 142:
        concurrent_warning_msg_ind_present = true;
        concurrent_warning_msg_ind.id      = c.id;
        concurrent_warning_msg_ind.crit    = c.crit;
        concurrent_warning_msg_ind.value   = c.value.concurrent_warning_msg_ind();
        break;
      case 286:
        warning_area_coordinates_present = true;
        warning_area_coordinates.id      = c.id;
        warning_area_coordinates.crit    = c.crit;
        warning_area_coordinates.value   = c.value.warning_area_coordinates();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  j.write_fieldname("");
  repeat_period.to_json(j);
  if (extended_repeat_period_present) {
    j.write_fieldname("");
    extended_repeat_period.to_json(j);
  }
  j.write_fieldname("");
  numof_broadcast_request.to_json(j);
  if (warning_type_present) {
    j.write_fieldname("");
    warning_type.to_json(j);
  }
  if (warning_security_info_present) {
    j.write_fieldname("");
    warning_security_info.to_json(j);
  }
  if (data_coding_scheme_present) {
    j.write_fieldname("");
    data_coding_scheme.to_json(j);
  }
  if (warning_msg_contents_present) {
    j.write_fieldname("");
    warning_msg_contents.to_json(j);
  }
  if (concurrent_warning_msg_ind_present) {
    j.write_fieldname("");
    concurrent_warning_msg_ind.to_json(j);
  }
  if (warning_area_coordinates_present) {
    j.write_fieldname("");
    warning_area_coordinates.to_json(j);
  }
  j.end_obj();
}

// WriteReplaceWarningRequest ::= SEQUENCE
SRSASN_CODE write_replace_warning_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void write_replace_warning_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

template struct asn1::s1ap::protocol_ie_field_s<write_replace_warning_resp_ies_o>;

write_replace_warning_resp_ies_container::write_replace_warning_resp_ies_container() :
  msg_id(111, crit_e::reject),
  serial_num(112, crit_e::reject),
  broadcast_completed_area_list(120, crit_e::ignore),
  crit_diagnostics(58, crit_e::ignore)
{}
SRSASN_CODE write_replace_warning_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_completed_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_completed_area_list_present) {
    HANDLE_CODE(broadcast_completed_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    protocol_ie_field_s<write_replace_warning_resp_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 111:
        nof_mandatory_ies--;
        msg_id.id    = c.id;
        msg_id.crit  = c.crit;
        msg_id.value = c.value.msg_id();
        break;
      case 112:
        nof_mandatory_ies--;
        serial_num.id    = c.id;
        serial_num.crit  = c.crit;
        serial_num.value = c.value.serial_num();
        break;
      case 120:
        broadcast_completed_area_list_present = true;
        broadcast_completed_area_list.id      = c.id;
        broadcast_completed_area_list.crit    = c.crit;
        broadcast_completed_area_list.value   = c.value.broadcast_completed_area_list();
        break;
      case 58:
        crit_diagnostics_present = true;
        crit_diagnostics.id      = c.id;
        crit_diagnostics.crit    = c.crit;
        crit_diagnostics.value   = c.value.crit_diagnostics();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_completed_area_list_present) {
    j.write_fieldname("");
    broadcast_completed_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// WriteReplaceWarningResponse ::= SEQUENCE
SRSASN_CODE write_replace_warning_resp_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(protocol_ies.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(protocol_ies.unpack(bref));

  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("protocolIEs");
  protocol_ies.to_json(j);
  j.end_obj();
}

// S1AP-ELEMENTARY-PROCEDURES ::= OBJECT SET OF S1AP-ELEMENTARY-PROCEDURE
uint16_t s1ap_elem_procs_o::idx_to_proc_code(uint32_t idx)
{
  static const uint16_t options[] = {0,  1,  3,  5,  6,  7,  9,  4,  43, 14, 17, 21, 23, 29, 30,
                                     36, 2,  8,  10, 11, 12, 13, 15, 16, 18, 19, 20, 22, 24, 25,
                                     26, 27, 28, 42, 31, 32, 33, 34, 35, 37, 38, 40, 41, 39};
  return map_enum_number(options, 44, idx, "proc_code");
}
bool s1ap_elem_procs_o::is_proc_code_valid(const uint16_t& proc_code)
{
  static const uint16_t options[] = {0,  1,  3,  5,  6,  7,  9,  4,  43, 14, 17, 21, 23, 29, 30,
                                     36, 2,  8,  10, 11, 12, 13, 15, 16, 18, 19, 20, 22, 24, 25,
                                     26, 27, 28, 42, 31, 32, 33, 34, 35, 37, 38, 40, 41, 39};
  for (const auto& o : options) {
    if (o == proc_code) {
      return true;
    }
  }
  return false;
}
s1ap_elem_procs_o::init_msg_c s1ap_elem_procs_o::get_init_msg(const uint16_t& proc_code)
{
  init_msg_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(init_msg_c::types::ho_required);
      break;
    case 1:
      ret.set(init_msg_c::types::ho_request);
      break;
    case 3:
      ret.set(init_msg_c::types::path_switch_request);
      break;
    case 5:
      ret.set(init_msg_c::types::erab_setup_request);
      break;
    case 6:
      ret.set(init_msg_c::types::erab_modify_request);
      break;
    case 7:
      ret.set(init_msg_c::types::erab_release_cmd);
      break;
    case 9:
      ret.set(init_msg_c::types::init_context_setup_request);
      break;
    case 4:
      ret.set(init_msg_c::types::ho_cancel);
      break;
    case 43:
      ret.set(init_msg_c::types::kill_request);
      break;
    case 14:
      ret.set(init_msg_c::types::reset);
      break;
    case 17:
      ret.set(init_msg_c::types::s1_setup_request);
      break;
    case 21:
      ret.set(init_msg_c::types::ue_context_mod_request);
      break;
    case 23:
      ret.set(init_msg_c::types::ue_context_release_cmd);
      break;
    case 29:
      ret.set(init_msg_c::types::enb_cfg_upd);
      break;
    case 30:
      ret.set(init_msg_c::types::mme_cfg_upd);
      break;
    case 36:
      ret.set(init_msg_c::types::write_replace_warning_request);
      break;
    case 2:
      ret.set(init_msg_c::types::ho_notify);
      break;
    case 8:
      ret.set(init_msg_c::types::erab_release_ind);
      break;
    case 10:
      ret.set(init_msg_c::types::paging);
      break;
    case 11:
      ret.set(init_msg_c::types::dl_nas_transport);
      break;
    case 12:
      ret.set(init_msg_c::types::init_ue_msg);
      break;
    case 13:
      ret.set(init_msg_c::types::ul_nas_transport);
      break;
    case 15:
      ret.set(init_msg_c::types::error_ind);
      break;
    case 16:
      ret.set(init_msg_c::types::nas_non_delivery_ind);
      break;
    case 18:
      ret.set(init_msg_c::types::ue_context_release_request);
      break;
    case 19:
      ret.set(init_msg_c::types::dl_s1cdma2000tunnelling);
      break;
    case 20:
      ret.set(init_msg_c::types::ul_s1cdma2000tunnelling);
      break;
    case 22:
      ret.set(init_msg_c::types::ue_cap_info_ind);
      break;
    case 24:
      ret.set(init_msg_c::types::enb_status_transfer);
      break;
    case 25:
      ret.set(init_msg_c::types::mme_status_transfer);
      break;
    case 26:
      ret.set(init_msg_c::types::deactiv_trace);
      break;
    case 27:
      ret.set(init_msg_c::types::trace_start);
      break;
    case 28:
      ret.set(init_msg_c::types::trace_fail_ind);
      break;
    case 42:
      ret.set(init_msg_c::types::cell_traffic_trace);
      break;
    case 31:
      ret.set(init_msg_c::types::location_report_ctrl);
      break;
    case 32:
      ret.set(init_msg_c::types::location_report_fail_ind);
      break;
    case 33:
      ret.set(init_msg_c::types::location_report);
      break;
    case 34:
      ret.set(init_msg_c::types::overload_start);
      break;
    case 35:
      ret.set(init_msg_c::types::overload_stop);
      break;
    case 37:
      ret.set(init_msg_c::types::enb_direct_info_transfer);
      break;
    case 38:
      ret.set(init_msg_c::types::mme_direct_info_transfer);
      break;
    case 40:
      ret.set(init_msg_c::types::enb_cfg_transfer);
      break;
    case 41:
      ret.set(init_msg_c::types::mme_cfg_transfer);
      break;
    case 39:
      ret.set(init_msg_c::types::private_msg);
      break;
    default:
      asn1::log_error("The proc_code=%d is not recognized", proc_code);
  }
  return ret;
}
s1ap_elem_procs_o::successful_outcome_c s1ap_elem_procs_o::get_successful_outcome(const uint16_t& proc_code)
{
  successful_outcome_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(successful_outcome_c::types::ho_cmd);
      break;
    case 1:
      ret.set(successful_outcome_c::types::ho_request_ack);
      break;
    case 3:
      ret.set(successful_outcome_c::types::path_switch_request_ack);
      break;
    case 5:
      ret.set(successful_outcome_c::types::erab_setup_resp);
      break;
    case 6:
      ret.set(successful_outcome_c::types::erab_modify_resp);
      break;
    case 7:
      ret.set(successful_outcome_c::types::erab_release_resp);
      break;
    case 9:
      ret.set(successful_outcome_c::types::init_context_setup_resp);
      break;
    case 4:
      ret.set(successful_outcome_c::types::ho_cancel_ack);
      break;
    case 43:
      ret.set(successful_outcome_c::types::kill_resp);
      break;
    case 14:
      ret.set(successful_outcome_c::types::reset_ack);
      break;
    case 17:
      ret.set(successful_outcome_c::types::s1_setup_resp);
      break;
    case 21:
      ret.set(successful_outcome_c::types::ue_context_mod_resp);
      break;
    case 23:
      ret.set(successful_outcome_c::types::ue_context_release_complete);
      break;
    case 29:
      ret.set(successful_outcome_c::types::enb_cfg_upd_ack);
      break;
    case 30:
      ret.set(successful_outcome_c::types::mme_cfg_upd_ack);
      break;
    case 36:
      ret.set(successful_outcome_c::types::write_replace_warning_resp);
      break;
    default:
      asn1::log_error("The proc_code=%d is not recognized", proc_code);
  }
  return ret;
}
s1ap_elem_procs_o::unsuccessful_outcome_c s1ap_elem_procs_o::get_unsuccessful_outcome(const uint16_t& proc_code)
{
  unsuccessful_outcome_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(unsuccessful_outcome_c::types::ho_prep_fail);
      break;
    case 1:
      ret.set(unsuccessful_outcome_c::types::ho_fail);
      break;
    case 3:
      ret.set(unsuccessful_outcome_c::types::path_switch_request_fail);
      break;
    case 9:
      ret.set(unsuccessful_outcome_c::types::init_context_setup_fail);
      break;
    case 17:
      ret.set(unsuccessful_outcome_c::types::s1_setup_fail);
      break;
    case 21:
      ret.set(unsuccessful_outcome_c::types::ue_context_mod_fail);
      break;
    case 29:
      ret.set(unsuccessful_outcome_c::types::enb_cfg_upd_fail);
      break;
    case 30:
      ret.set(unsuccessful_outcome_c::types::mme_cfg_upd_fail);
      break;
    default:
      asn1::log_error("The proc_code=%d is not recognized", proc_code);
  }
  return ret;
}
crit_e s1ap_elem_procs_o::get_crit(const uint16_t& proc_code)
{
  switch (proc_code) {
    case 0:
      return crit_e::reject;
    case 1:
      return crit_e::reject;
    case 3:
      return crit_e::reject;
    case 5:
      return crit_e::reject;
    case 6:
      return crit_e::reject;
    case 7:
      return crit_e::reject;
    case 9:
      return crit_e::reject;
    case 4:
      return crit_e::reject;
    case 43:
      return crit_e::reject;
    case 14:
      return crit_e::reject;
    case 17:
      return crit_e::reject;
    case 21:
      return crit_e::reject;
    case 23:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 30:
      return crit_e::reject;
    case 36:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 10:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 12:
      return crit_e::ignore;
    case 13:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 16:
      return crit_e::ignore;
    case 18:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 20:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 24:
      return crit_e::ignore;
    case 25:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 28:
      return crit_e::ignore;
    case 42:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 35:
      return crit_e::reject;
    case 37:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 40:
      return crit_e::ignore;
    case 41:
      return crit_e::ignore;
    case 39:
      return crit_e::ignore;
    default:
      asn1::log_error("The proc_code=%d is not recognized", proc_code);
  }
  return {};
}

// InitiatingMessage ::= OPEN TYPE
void s1ap_elem_procs_o::init_msg_c::destroy_()
{
  switch (type_) {
    case types::ho_required:
      c.destroy<ho_required_s>();
      break;
    case types::ho_request:
      c.destroy<ho_request_s>();
      break;
    case types::path_switch_request:
      c.destroy<path_switch_request_s>();
      break;
    case types::erab_setup_request:
      c.destroy<erab_setup_request_s>();
      break;
    case types::erab_modify_request:
      c.destroy<erab_modify_request_s>();
      break;
    case types::erab_release_cmd:
      c.destroy<erab_release_cmd_s>();
      break;
    case types::init_context_setup_request:
      c.destroy<init_context_setup_request_s>();
      break;
    case types::ho_cancel:
      c.destroy<ho_cancel_s>();
      break;
    case types::kill_request:
      c.destroy<kill_request_s>();
      break;
    case types::reset:
      c.destroy<reset_s>();
      break;
    case types::s1_setup_request:
      c.destroy<s1_setup_request_s>();
      break;
    case types::ue_context_mod_request:
      c.destroy<ue_context_mod_request_s>();
      break;
    case types::ue_context_release_cmd:
      c.destroy<ue_context_release_cmd_s>();
      break;
    case types::enb_cfg_upd:
      c.destroy<enb_cfg_upd_s>();
      break;
    case types::mme_cfg_upd:
      c.destroy<mme_cfg_upd_s>();
      break;
    case types::write_replace_warning_request:
      c.destroy<write_replace_warning_request_s>();
      break;
    case types::ho_notify:
      c.destroy<ho_notify_s>();
      break;
    case types::erab_release_ind:
      c.destroy<erab_release_ind_s>();
      break;
    case types::paging:
      c.destroy<paging_s>();
      break;
    case types::dl_nas_transport:
      c.destroy<dl_nas_transport_s>();
      break;
    case types::init_ue_msg:
      c.destroy<init_ue_msg_s>();
      break;
    case types::ul_nas_transport:
      c.destroy<ul_nas_transport_s>();
      break;
    case types::error_ind:
      c.destroy<error_ind_s>();
      break;
    case types::nas_non_delivery_ind:
      c.destroy<nas_non_delivery_ind_s>();
      break;
    case types::ue_context_release_request:
      c.destroy<ue_context_release_request_s>();
      break;
    case types::dl_s1cdma2000tunnelling:
      c.destroy<dl_s1cdma2000tunnelling_s>();
      break;
    case types::ul_s1cdma2000tunnelling:
      c.destroy<ul_s1cdma2000tunnelling_s>();
      break;
    case types::ue_cap_info_ind:
      c.destroy<ue_cap_info_ind_s>();
      break;
    case types::enb_status_transfer:
      c.destroy<enb_status_transfer_s>();
      break;
    case types::mme_status_transfer:
      c.destroy<mme_status_transfer_s>();
      break;
    case types::deactiv_trace:
      c.destroy<deactiv_trace_s>();
      break;
    case types::trace_start:
      c.destroy<trace_start_s>();
      break;
    case types::trace_fail_ind:
      c.destroy<trace_fail_ind_s>();
      break;
    case types::cell_traffic_trace:
      c.destroy<cell_traffic_trace_s>();
      break;
    case types::location_report_ctrl:
      c.destroy<location_report_ctrl_s>();
      break;
    case types::location_report_fail_ind:
      c.destroy<location_report_fail_ind_s>();
      break;
    case types::location_report:
      c.destroy<location_report_s>();
      break;
    case types::overload_start:
      c.destroy<overload_start_s>();
      break;
    case types::overload_stop:
      c.destroy<overload_stop_s>();
      break;
    case types::enb_direct_info_transfer:
      c.destroy<enb_direct_info_transfer_s>();
      break;
    case types::mme_direct_info_transfer:
      c.destroy<mme_direct_info_transfer_s>();
      break;
    case types::enb_cfg_transfer:
      c.destroy<enb_cfg_transfer_s>();
      break;
    case types::mme_cfg_transfer:
      c.destroy<mme_cfg_transfer_s>();
      break;
    case types::private_msg:
      c.destroy<private_msg_s>();
      break;
    default:
      break;
  }
}
void s1ap_elem_procs_o::init_msg_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_required:
      c.init<ho_required_s>();
      break;
    case types::ho_request:
      c.init<ho_request_s>();
      break;
    case types::path_switch_request:
      c.init<path_switch_request_s>();
      break;
    case types::erab_setup_request:
      c.init<erab_setup_request_s>();
      break;
    case types::erab_modify_request:
      c.init<erab_modify_request_s>();
      break;
    case types::erab_release_cmd:
      c.init<erab_release_cmd_s>();
      break;
    case types::init_context_setup_request:
      c.init<init_context_setup_request_s>();
      break;
    case types::ho_cancel:
      c.init<ho_cancel_s>();
      break;
    case types::kill_request:
      c.init<kill_request_s>();
      break;
    case types::reset:
      c.init<reset_s>();
      break;
    case types::s1_setup_request:
      c.init<s1_setup_request_s>();
      break;
    case types::ue_context_mod_request:
      c.init<ue_context_mod_request_s>();
      break;
    case types::ue_context_release_cmd:
      c.init<ue_context_release_cmd_s>();
      break;
    case types::enb_cfg_upd:
      c.init<enb_cfg_upd_s>();
      break;
    case types::mme_cfg_upd:
      c.init<mme_cfg_upd_s>();
      break;
    case types::write_replace_warning_request:
      c.init<write_replace_warning_request_s>();
      break;
    case types::ho_notify:
      c.init<ho_notify_s>();
      break;
    case types::erab_release_ind:
      c.init<erab_release_ind_s>();
      break;
    case types::paging:
      c.init<paging_s>();
      break;
    case types::dl_nas_transport:
      c.init<dl_nas_transport_s>();
      break;
    case types::init_ue_msg:
      c.init<init_ue_msg_s>();
      break;
    case types::ul_nas_transport:
      c.init<ul_nas_transport_s>();
      break;
    case types::error_ind:
      c.init<error_ind_s>();
      break;
    case types::nas_non_delivery_ind:
      c.init<nas_non_delivery_ind_s>();
      break;
    case types::ue_context_release_request:
      c.init<ue_context_release_request_s>();
      break;
    case types::dl_s1cdma2000tunnelling:
      c.init<dl_s1cdma2000tunnelling_s>();
      break;
    case types::ul_s1cdma2000tunnelling:
      c.init<ul_s1cdma2000tunnelling_s>();
      break;
    case types::ue_cap_info_ind:
      c.init<ue_cap_info_ind_s>();
      break;
    case types::enb_status_transfer:
      c.init<enb_status_transfer_s>();
      break;
    case types::mme_status_transfer:
      c.init<mme_status_transfer_s>();
      break;
    case types::deactiv_trace:
      c.init<deactiv_trace_s>();
      break;
    case types::trace_start:
      c.init<trace_start_s>();
      break;
    case types::trace_fail_ind:
      c.init<trace_fail_ind_s>();
      break;
    case types::cell_traffic_trace:
      c.init<cell_traffic_trace_s>();
      break;
    case types::location_report_ctrl:
      c.init<location_report_ctrl_s>();
      break;
    case types::location_report_fail_ind:
      c.init<location_report_fail_ind_s>();
      break;
    case types::location_report:
      c.init<location_report_s>();
      break;
    case types::overload_start:
      c.init<overload_start_s>();
      break;
    case types::overload_stop:
      c.init<overload_stop_s>();
      break;
    case types::enb_direct_info_transfer:
      c.init<enb_direct_info_transfer_s>();
      break;
    case types::mme_direct_info_transfer:
      c.init<mme_direct_info_transfer_s>();
      break;
    case types::enb_cfg_transfer:
      c.init<enb_cfg_transfer_s>();
      break;
    case types::mme_cfg_transfer:
      c.init<mme_cfg_transfer_s>();
      break;
    case types::private_msg:
      c.init<private_msg_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
  }
}
s1ap_elem_procs_o::init_msg_c::init_msg_c(const s1ap_elem_procs_o::init_msg_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_required:
      c.init(other.c.get<ho_required_s>());
      break;
    case types::ho_request:
      c.init(other.c.get<ho_request_s>());
      break;
    case types::path_switch_request:
      c.init(other.c.get<path_switch_request_s>());
      break;
    case types::erab_setup_request:
      c.init(other.c.get<erab_setup_request_s>());
      break;
    case types::erab_modify_request:
      c.init(other.c.get<erab_modify_request_s>());
      break;
    case types::erab_release_cmd:
      c.init(other.c.get<erab_release_cmd_s>());
      break;
    case types::init_context_setup_request:
      c.init(other.c.get<init_context_setup_request_s>());
      break;
    case types::ho_cancel:
      c.init(other.c.get<ho_cancel_s>());
      break;
    case types::kill_request:
      c.init(other.c.get<kill_request_s>());
      break;
    case types::reset:
      c.init(other.c.get<reset_s>());
      break;
    case types::s1_setup_request:
      c.init(other.c.get<s1_setup_request_s>());
      break;
    case types::ue_context_mod_request:
      c.init(other.c.get<ue_context_mod_request_s>());
      break;
    case types::ue_context_release_cmd:
      c.init(other.c.get<ue_context_release_cmd_s>());
      break;
    case types::enb_cfg_upd:
      c.init(other.c.get<enb_cfg_upd_s>());
      break;
    case types::mme_cfg_upd:
      c.init(other.c.get<mme_cfg_upd_s>());
      break;
    case types::write_replace_warning_request:
      c.init(other.c.get<write_replace_warning_request_s>());
      break;
    case types::ho_notify:
      c.init(other.c.get<ho_notify_s>());
      break;
    case types::erab_release_ind:
      c.init(other.c.get<erab_release_ind_s>());
      break;
    case types::paging:
      c.init(other.c.get<paging_s>());
      break;
    case types::dl_nas_transport:
      c.init(other.c.get<dl_nas_transport_s>());
      break;
    case types::init_ue_msg:
      c.init(other.c.get<init_ue_msg_s>());
      break;
    case types::ul_nas_transport:
      c.init(other.c.get<ul_nas_transport_s>());
      break;
    case types::error_ind:
      c.init(other.c.get<error_ind_s>());
      break;
    case types::nas_non_delivery_ind:
      c.init(other.c.get<nas_non_delivery_ind_s>());
      break;
    case types::ue_context_release_request:
      c.init(other.c.get<ue_context_release_request_s>());
      break;
    case types::dl_s1cdma2000tunnelling:
      c.init(other.c.get<dl_s1cdma2000tunnelling_s>());
      break;
    case types::ul_s1cdma2000tunnelling:
      c.init(other.c.get<ul_s1cdma2000tunnelling_s>());
      break;
    case types::ue_cap_info_ind:
      c.init(other.c.get<ue_cap_info_ind_s>());
      break;
    case types::enb_status_transfer:
      c.init(other.c.get<enb_status_transfer_s>());
      break;
    case types::mme_status_transfer:
      c.init(other.c.get<mme_status_transfer_s>());
      break;
    case types::deactiv_trace:
      c.init(other.c.get<deactiv_trace_s>());
      break;
    case types::trace_start:
      c.init(other.c.get<trace_start_s>());
      break;
    case types::trace_fail_ind:
      c.init(other.c.get<trace_fail_ind_s>());
      break;
    case types::cell_traffic_trace:
      c.init(other.c.get<cell_traffic_trace_s>());
      break;
    case types::location_report_ctrl:
      c.init(other.c.get<location_report_ctrl_s>());
      break;
    case types::location_report_fail_ind:
      c.init(other.c.get<location_report_fail_ind_s>());
      break;
    case types::location_report:
      c.init(other.c.get<location_report_s>());
      break;
    case types::overload_start:
      c.init(other.c.get<overload_start_s>());
      break;
    case types::overload_stop:
      c.init(other.c.get<overload_stop_s>());
      break;
    case types::enb_direct_info_transfer:
      c.init(other.c.get<enb_direct_info_transfer_s>());
      break;
    case types::mme_direct_info_transfer:
      c.init(other.c.get<mme_direct_info_transfer_s>());
      break;
    case types::enb_cfg_transfer:
      c.init(other.c.get<enb_cfg_transfer_s>());
      break;
    case types::mme_cfg_transfer:
      c.init(other.c.get<mme_cfg_transfer_s>());
      break;
    case types::private_msg:
      c.init(other.c.get<private_msg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
  }
}
s1ap_elem_procs_o::init_msg_c& s1ap_elem_procs_o::init_msg_c::operator=(const s1ap_elem_procs_o::init_msg_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_required:
      c.set(other.c.get<ho_required_s>());
      break;
    case types::ho_request:
      c.set(other.c.get<ho_request_s>());
      break;
    case types::path_switch_request:
      c.set(other.c.get<path_switch_request_s>());
      break;
    case types::erab_setup_request:
      c.set(other.c.get<erab_setup_request_s>());
      break;
    case types::erab_modify_request:
      c.set(other.c.get<erab_modify_request_s>());
      break;
    case types::erab_release_cmd:
      c.set(other.c.get<erab_release_cmd_s>());
      break;
    case types::init_context_setup_request:
      c.set(other.c.get<init_context_setup_request_s>());
      break;
    case types::ho_cancel:
      c.set(other.c.get<ho_cancel_s>());
      break;
    case types::kill_request:
      c.set(other.c.get<kill_request_s>());
      break;
    case types::reset:
      c.set(other.c.get<reset_s>());
      break;
    case types::s1_setup_request:
      c.set(other.c.get<s1_setup_request_s>());
      break;
    case types::ue_context_mod_request:
      c.set(other.c.get<ue_context_mod_request_s>());
      break;
    case types::ue_context_release_cmd:
      c.set(other.c.get<ue_context_release_cmd_s>());
      break;
    case types::enb_cfg_upd:
      c.set(other.c.get<enb_cfg_upd_s>());
      break;
    case types::mme_cfg_upd:
      c.set(other.c.get<mme_cfg_upd_s>());
      break;
    case types::write_replace_warning_request:
      c.set(other.c.get<write_replace_warning_request_s>());
      break;
    case types::ho_notify:
      c.set(other.c.get<ho_notify_s>());
      break;
    case types::erab_release_ind:
      c.set(other.c.get<erab_release_ind_s>());
      break;
    case types::paging:
      c.set(other.c.get<paging_s>());
      break;
    case types::dl_nas_transport:
      c.set(other.c.get<dl_nas_transport_s>());
      break;
    case types::init_ue_msg:
      c.set(other.c.get<init_ue_msg_s>());
      break;
    case types::ul_nas_transport:
      c.set(other.c.get<ul_nas_transport_s>());
      break;
    case types::error_ind:
      c.set(other.c.get<error_ind_s>());
      break;
    case types::nas_non_delivery_ind:
      c.set(other.c.get<nas_non_delivery_ind_s>());
      break;
    case types::ue_context_release_request:
      c.set(other.c.get<ue_context_release_request_s>());
      break;
    case types::dl_s1cdma2000tunnelling:
      c.set(other.c.get<dl_s1cdma2000tunnelling_s>());
      break;
    case types::ul_s1cdma2000tunnelling:
      c.set(other.c.get<ul_s1cdma2000tunnelling_s>());
      break;
    case types::ue_cap_info_ind:
      c.set(other.c.get<ue_cap_info_ind_s>());
      break;
    case types::enb_status_transfer:
      c.set(other.c.get<enb_status_transfer_s>());
      break;
    case types::mme_status_transfer:
      c.set(other.c.get<mme_status_transfer_s>());
      break;
    case types::deactiv_trace:
      c.set(other.c.get<deactiv_trace_s>());
      break;
    case types::trace_start:
      c.set(other.c.get<trace_start_s>());
      break;
    case types::trace_fail_ind:
      c.set(other.c.get<trace_fail_ind_s>());
      break;
    case types::cell_traffic_trace:
      c.set(other.c.get<cell_traffic_trace_s>());
      break;
    case types::location_report_ctrl:
      c.set(other.c.get<location_report_ctrl_s>());
      break;
    case types::location_report_fail_ind:
      c.set(other.c.get<location_report_fail_ind_s>());
      break;
    case types::location_report:
      c.set(other.c.get<location_report_s>());
      break;
    case types::overload_start:
      c.set(other.c.get<overload_start_s>());
      break;
    case types::overload_stop:
      c.set(other.c.get<overload_stop_s>());
      break;
    case types::enb_direct_info_transfer:
      c.set(other.c.get<enb_direct_info_transfer_s>());
      break;
    case types::mme_direct_info_transfer:
      c.set(other.c.get<mme_direct_info_transfer_s>());
      break;
    case types::enb_cfg_transfer:
      c.set(other.c.get<enb_cfg_transfer_s>());
      break;
    case types::mme_cfg_transfer:
      c.set(other.c.get<mme_cfg_transfer_s>());
      break;
    case types::private_msg:
      c.set(other.c.get<private_msg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
  }

  return *this;
}
ho_required_s& s1ap_elem_procs_o::init_msg_c::ho_required()
{
  assert_choice_type(types::ho_required, type_, "InitiatingMessage");
  return c.get<ho_required_s>();
}
ho_request_s& s1ap_elem_procs_o::init_msg_c::ho_request()
{
  assert_choice_type(types::ho_request, type_, "InitiatingMessage");
  return c.get<ho_request_s>();
}
path_switch_request_s& s1ap_elem_procs_o::init_msg_c::path_switch_request()
{
  assert_choice_type(types::path_switch_request, type_, "InitiatingMessage");
  return c.get<path_switch_request_s>();
}
erab_setup_request_s& s1ap_elem_procs_o::init_msg_c::erab_setup_request()
{
  assert_choice_type(types::erab_setup_request, type_, "InitiatingMessage");
  return c.get<erab_setup_request_s>();
}
erab_modify_request_s& s1ap_elem_procs_o::init_msg_c::erab_modify_request()
{
  assert_choice_type(types::erab_modify_request, type_, "InitiatingMessage");
  return c.get<erab_modify_request_s>();
}
erab_release_cmd_s& s1ap_elem_procs_o::init_msg_c::erab_release_cmd()
{
  assert_choice_type(types::erab_release_cmd, type_, "InitiatingMessage");
  return c.get<erab_release_cmd_s>();
}
init_context_setup_request_s& s1ap_elem_procs_o::init_msg_c::init_context_setup_request()
{
  assert_choice_type(types::init_context_setup_request, type_, "InitiatingMessage");
  return c.get<init_context_setup_request_s>();
}
ho_cancel_s& s1ap_elem_procs_o::init_msg_c::ho_cancel()
{
  assert_choice_type(types::ho_cancel, type_, "InitiatingMessage");
  return c.get<ho_cancel_s>();
}
kill_request_s& s1ap_elem_procs_o::init_msg_c::kill_request()
{
  assert_choice_type(types::kill_request, type_, "InitiatingMessage");
  return c.get<kill_request_s>();
}
reset_s& s1ap_elem_procs_o::init_msg_c::reset()
{
  assert_choice_type(types::reset, type_, "InitiatingMessage");
  return c.get<reset_s>();
}
s1_setup_request_s& s1ap_elem_procs_o::init_msg_c::s1_setup_request()
{
  assert_choice_type(types::s1_setup_request, type_, "InitiatingMessage");
  return c.get<s1_setup_request_s>();
}
ue_context_mod_request_s& s1ap_elem_procs_o::init_msg_c::ue_context_mod_request()
{
  assert_choice_type(types::ue_context_mod_request, type_, "InitiatingMessage");
  return c.get<ue_context_mod_request_s>();
}
ue_context_release_cmd_s& s1ap_elem_procs_o::init_msg_c::ue_context_release_cmd()
{
  assert_choice_type(types::ue_context_release_cmd, type_, "InitiatingMessage");
  return c.get<ue_context_release_cmd_s>();
}
enb_cfg_upd_s& s1ap_elem_procs_o::init_msg_c::enb_cfg_upd()
{
  assert_choice_type(types::enb_cfg_upd, type_, "InitiatingMessage");
  return c.get<enb_cfg_upd_s>();
}
mme_cfg_upd_s& s1ap_elem_procs_o::init_msg_c::mme_cfg_upd()
{
  assert_choice_type(types::mme_cfg_upd, type_, "InitiatingMessage");
  return c.get<mme_cfg_upd_s>();
}
write_replace_warning_request_s& s1ap_elem_procs_o::init_msg_c::write_replace_warning_request()
{
  assert_choice_type(types::write_replace_warning_request, type_, "InitiatingMessage");
  return c.get<write_replace_warning_request_s>();
}
ho_notify_s& s1ap_elem_procs_o::init_msg_c::ho_notify()
{
  assert_choice_type(types::ho_notify, type_, "InitiatingMessage");
  return c.get<ho_notify_s>();
}
erab_release_ind_s& s1ap_elem_procs_o::init_msg_c::erab_release_ind()
{
  assert_choice_type(types::erab_release_ind, type_, "InitiatingMessage");
  return c.get<erab_release_ind_s>();
}
paging_s& s1ap_elem_procs_o::init_msg_c::paging()
{
  assert_choice_type(types::paging, type_, "InitiatingMessage");
  return c.get<paging_s>();
}
dl_nas_transport_s& s1ap_elem_procs_o::init_msg_c::dl_nas_transport()
{
  assert_choice_type(types::dl_nas_transport, type_, "InitiatingMessage");
  return c.get<dl_nas_transport_s>();
}
init_ue_msg_s& s1ap_elem_procs_o::init_msg_c::init_ue_msg()
{
  assert_choice_type(types::init_ue_msg, type_, "InitiatingMessage");
  return c.get<init_ue_msg_s>();
}
ul_nas_transport_s& s1ap_elem_procs_o::init_msg_c::ul_nas_transport()
{
  assert_choice_type(types::ul_nas_transport, type_, "InitiatingMessage");
  return c.get<ul_nas_transport_s>();
}
error_ind_s& s1ap_elem_procs_o::init_msg_c::error_ind()
{
  assert_choice_type(types::error_ind, type_, "InitiatingMessage");
  return c.get<error_ind_s>();
}
nas_non_delivery_ind_s& s1ap_elem_procs_o::init_msg_c::nas_non_delivery_ind()
{
  assert_choice_type(types::nas_non_delivery_ind, type_, "InitiatingMessage");
  return c.get<nas_non_delivery_ind_s>();
}
ue_context_release_request_s& s1ap_elem_procs_o::init_msg_c::ue_context_release_request()
{
  assert_choice_type(types::ue_context_release_request, type_, "InitiatingMessage");
  return c.get<ue_context_release_request_s>();
}
dl_s1cdma2000tunnelling_s& s1ap_elem_procs_o::init_msg_c::dl_s1cdma2000tunnelling()
{
  assert_choice_type(types::dl_s1cdma2000tunnelling, type_, "InitiatingMessage");
  return c.get<dl_s1cdma2000tunnelling_s>();
}
ul_s1cdma2000tunnelling_s& s1ap_elem_procs_o::init_msg_c::ul_s1cdma2000tunnelling()
{
  assert_choice_type(types::ul_s1cdma2000tunnelling, type_, "InitiatingMessage");
  return c.get<ul_s1cdma2000tunnelling_s>();
}
ue_cap_info_ind_s& s1ap_elem_procs_o::init_msg_c::ue_cap_info_ind()
{
  assert_choice_type(types::ue_cap_info_ind, type_, "InitiatingMessage");
  return c.get<ue_cap_info_ind_s>();
}
enb_status_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_status_transfer()
{
  assert_choice_type(types::enb_status_transfer, type_, "InitiatingMessage");
  return c.get<enb_status_transfer_s>();
}
mme_status_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_status_transfer()
{
  assert_choice_type(types::mme_status_transfer, type_, "InitiatingMessage");
  return c.get<mme_status_transfer_s>();
}
deactiv_trace_s& s1ap_elem_procs_o::init_msg_c::deactiv_trace()
{
  assert_choice_type(types::deactiv_trace, type_, "InitiatingMessage");
  return c.get<deactiv_trace_s>();
}
trace_start_s& s1ap_elem_procs_o::init_msg_c::trace_start()
{
  assert_choice_type(types::trace_start, type_, "InitiatingMessage");
  return c.get<trace_start_s>();
}
trace_fail_ind_s& s1ap_elem_procs_o::init_msg_c::trace_fail_ind()
{
  assert_choice_type(types::trace_fail_ind, type_, "InitiatingMessage");
  return c.get<trace_fail_ind_s>();
}
cell_traffic_trace_s& s1ap_elem_procs_o::init_msg_c::cell_traffic_trace()
{
  assert_choice_type(types::cell_traffic_trace, type_, "InitiatingMessage");
  return c.get<cell_traffic_trace_s>();
}
location_report_ctrl_s& s1ap_elem_procs_o::init_msg_c::location_report_ctrl()
{
  assert_choice_type(types::location_report_ctrl, type_, "InitiatingMessage");
  return c.get<location_report_ctrl_s>();
}
location_report_fail_ind_s& s1ap_elem_procs_o::init_msg_c::location_report_fail_ind()
{
  assert_choice_type(types::location_report_fail_ind, type_, "InitiatingMessage");
  return c.get<location_report_fail_ind_s>();
}
location_report_s& s1ap_elem_procs_o::init_msg_c::location_report()
{
  assert_choice_type(types::location_report, type_, "InitiatingMessage");
  return c.get<location_report_s>();
}
overload_start_s& s1ap_elem_procs_o::init_msg_c::overload_start()
{
  assert_choice_type(types::overload_start, type_, "InitiatingMessage");
  return c.get<overload_start_s>();
}
overload_stop_s& s1ap_elem_procs_o::init_msg_c::overload_stop()
{
  assert_choice_type(types::overload_stop, type_, "InitiatingMessage");
  return c.get<overload_stop_s>();
}
enb_direct_info_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_direct_info_transfer()
{
  assert_choice_type(types::enb_direct_info_transfer, type_, "InitiatingMessage");
  return c.get<enb_direct_info_transfer_s>();
}
mme_direct_info_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_direct_info_transfer()
{
  assert_choice_type(types::mme_direct_info_transfer, type_, "InitiatingMessage");
  return c.get<mme_direct_info_transfer_s>();
}
enb_cfg_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_cfg_transfer()
{
  assert_choice_type(types::enb_cfg_transfer, type_, "InitiatingMessage");
  return c.get<enb_cfg_transfer_s>();
}
mme_cfg_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_cfg_transfer()
{
  assert_choice_type(types::mme_cfg_transfer, type_, "InitiatingMessage");
  return c.get<mme_cfg_transfer_s>();
}
private_msg_s& s1ap_elem_procs_o::init_msg_c::private_msg()
{
  assert_choice_type(types::private_msg, type_, "InitiatingMessage");
  return c.get<private_msg_s>();
}
const ho_required_s& s1ap_elem_procs_o::init_msg_c::ho_required() const
{
  assert_choice_type(types::ho_required, type_, "InitiatingMessage");
  return c.get<ho_required_s>();
}
const ho_request_s& s1ap_elem_procs_o::init_msg_c::ho_request() const
{
  assert_choice_type(types::ho_request, type_, "InitiatingMessage");
  return c.get<ho_request_s>();
}
const path_switch_request_s& s1ap_elem_procs_o::init_msg_c::path_switch_request() const
{
  assert_choice_type(types::path_switch_request, type_, "InitiatingMessage");
  return c.get<path_switch_request_s>();
}
const erab_setup_request_s& s1ap_elem_procs_o::init_msg_c::erab_setup_request() const
{
  assert_choice_type(types::erab_setup_request, type_, "InitiatingMessage");
  return c.get<erab_setup_request_s>();
}
const erab_modify_request_s& s1ap_elem_procs_o::init_msg_c::erab_modify_request() const
{
  assert_choice_type(types::erab_modify_request, type_, "InitiatingMessage");
  return c.get<erab_modify_request_s>();
}
const erab_release_cmd_s& s1ap_elem_procs_o::init_msg_c::erab_release_cmd() const
{
  assert_choice_type(types::erab_release_cmd, type_, "InitiatingMessage");
  return c.get<erab_release_cmd_s>();
}
const init_context_setup_request_s& s1ap_elem_procs_o::init_msg_c::init_context_setup_request() const
{
  assert_choice_type(types::init_context_setup_request, type_, "InitiatingMessage");
  return c.get<init_context_setup_request_s>();
}
const ho_cancel_s& s1ap_elem_procs_o::init_msg_c::ho_cancel() const
{
  assert_choice_type(types::ho_cancel, type_, "InitiatingMessage");
  return c.get<ho_cancel_s>();
}
const kill_request_s& s1ap_elem_procs_o::init_msg_c::kill_request() const
{
  assert_choice_type(types::kill_request, type_, "InitiatingMessage");
  return c.get<kill_request_s>();
}
const reset_s& s1ap_elem_procs_o::init_msg_c::reset() const
{
  assert_choice_type(types::reset, type_, "InitiatingMessage");
  return c.get<reset_s>();
}
const s1_setup_request_s& s1ap_elem_procs_o::init_msg_c::s1_setup_request() const
{
  assert_choice_type(types::s1_setup_request, type_, "InitiatingMessage");
  return c.get<s1_setup_request_s>();
}
const ue_context_mod_request_s& s1ap_elem_procs_o::init_msg_c::ue_context_mod_request() const
{
  assert_choice_type(types::ue_context_mod_request, type_, "InitiatingMessage");
  return c.get<ue_context_mod_request_s>();
}
const ue_context_release_cmd_s& s1ap_elem_procs_o::init_msg_c::ue_context_release_cmd() const
{
  assert_choice_type(types::ue_context_release_cmd, type_, "InitiatingMessage");
  return c.get<ue_context_release_cmd_s>();
}
const enb_cfg_upd_s& s1ap_elem_procs_o::init_msg_c::enb_cfg_upd() const
{
  assert_choice_type(types::enb_cfg_upd, type_, "InitiatingMessage");
  return c.get<enb_cfg_upd_s>();
}
const mme_cfg_upd_s& s1ap_elem_procs_o::init_msg_c::mme_cfg_upd() const
{
  assert_choice_type(types::mme_cfg_upd, type_, "InitiatingMessage");
  return c.get<mme_cfg_upd_s>();
}
const write_replace_warning_request_s& s1ap_elem_procs_o::init_msg_c::write_replace_warning_request() const
{
  assert_choice_type(types::write_replace_warning_request, type_, "InitiatingMessage");
  return c.get<write_replace_warning_request_s>();
}
const ho_notify_s& s1ap_elem_procs_o::init_msg_c::ho_notify() const
{
  assert_choice_type(types::ho_notify, type_, "InitiatingMessage");
  return c.get<ho_notify_s>();
}
const erab_release_ind_s& s1ap_elem_procs_o::init_msg_c::erab_release_ind() const
{
  assert_choice_type(types::erab_release_ind, type_, "InitiatingMessage");
  return c.get<erab_release_ind_s>();
}
const paging_s& s1ap_elem_procs_o::init_msg_c::paging() const
{
  assert_choice_type(types::paging, type_, "InitiatingMessage");
  return c.get<paging_s>();
}
const dl_nas_transport_s& s1ap_elem_procs_o::init_msg_c::dl_nas_transport() const
{
  assert_choice_type(types::dl_nas_transport, type_, "InitiatingMessage");
  return c.get<dl_nas_transport_s>();
}
const init_ue_msg_s& s1ap_elem_procs_o::init_msg_c::init_ue_msg() const
{
  assert_choice_type(types::init_ue_msg, type_, "InitiatingMessage");
  return c.get<init_ue_msg_s>();
}
const ul_nas_transport_s& s1ap_elem_procs_o::init_msg_c::ul_nas_transport() const
{
  assert_choice_type(types::ul_nas_transport, type_, "InitiatingMessage");
  return c.get<ul_nas_transport_s>();
}
const error_ind_s& s1ap_elem_procs_o::init_msg_c::error_ind() const
{
  assert_choice_type(types::error_ind, type_, "InitiatingMessage");
  return c.get<error_ind_s>();
}
const nas_non_delivery_ind_s& s1ap_elem_procs_o::init_msg_c::nas_non_delivery_ind() const
{
  assert_choice_type(types::nas_non_delivery_ind, type_, "InitiatingMessage");
  return c.get<nas_non_delivery_ind_s>();
}
const ue_context_release_request_s& s1ap_elem_procs_o::init_msg_c::ue_context_release_request() const
{
  assert_choice_type(types::ue_context_release_request, type_, "InitiatingMessage");
  return c.get<ue_context_release_request_s>();
}
const dl_s1cdma2000tunnelling_s& s1ap_elem_procs_o::init_msg_c::dl_s1cdma2000tunnelling() const
{
  assert_choice_type(types::dl_s1cdma2000tunnelling, type_, "InitiatingMessage");
  return c.get<dl_s1cdma2000tunnelling_s>();
}
const ul_s1cdma2000tunnelling_s& s1ap_elem_procs_o::init_msg_c::ul_s1cdma2000tunnelling() const
{
  assert_choice_type(types::ul_s1cdma2000tunnelling, type_, "InitiatingMessage");
  return c.get<ul_s1cdma2000tunnelling_s>();
}
const ue_cap_info_ind_s& s1ap_elem_procs_o::init_msg_c::ue_cap_info_ind() const
{
  assert_choice_type(types::ue_cap_info_ind, type_, "InitiatingMessage");
  return c.get<ue_cap_info_ind_s>();
}
const enb_status_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_status_transfer() const
{
  assert_choice_type(types::enb_status_transfer, type_, "InitiatingMessage");
  return c.get<enb_status_transfer_s>();
}
const mme_status_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_status_transfer() const
{
  assert_choice_type(types::mme_status_transfer, type_, "InitiatingMessage");
  return c.get<mme_status_transfer_s>();
}
const deactiv_trace_s& s1ap_elem_procs_o::init_msg_c::deactiv_trace() const
{
  assert_choice_type(types::deactiv_trace, type_, "InitiatingMessage");
  return c.get<deactiv_trace_s>();
}
const trace_start_s& s1ap_elem_procs_o::init_msg_c::trace_start() const
{
  assert_choice_type(types::trace_start, type_, "InitiatingMessage");
  return c.get<trace_start_s>();
}
const trace_fail_ind_s& s1ap_elem_procs_o::init_msg_c::trace_fail_ind() const
{
  assert_choice_type(types::trace_fail_ind, type_, "InitiatingMessage");
  return c.get<trace_fail_ind_s>();
}
const cell_traffic_trace_s& s1ap_elem_procs_o::init_msg_c::cell_traffic_trace() const
{
  assert_choice_type(types::cell_traffic_trace, type_, "InitiatingMessage");
  return c.get<cell_traffic_trace_s>();
}
const location_report_ctrl_s& s1ap_elem_procs_o::init_msg_c::location_report_ctrl() const
{
  assert_choice_type(types::location_report_ctrl, type_, "InitiatingMessage");
  return c.get<location_report_ctrl_s>();
}
const location_report_fail_ind_s& s1ap_elem_procs_o::init_msg_c::location_report_fail_ind() const
{
  assert_choice_type(types::location_report_fail_ind, type_, "InitiatingMessage");
  return c.get<location_report_fail_ind_s>();
}
const location_report_s& s1ap_elem_procs_o::init_msg_c::location_report() const
{
  assert_choice_type(types::location_report, type_, "InitiatingMessage");
  return c.get<location_report_s>();
}
const overload_start_s& s1ap_elem_procs_o::init_msg_c::overload_start() const
{
  assert_choice_type(types::overload_start, type_, "InitiatingMessage");
  return c.get<overload_start_s>();
}
const overload_stop_s& s1ap_elem_procs_o::init_msg_c::overload_stop() const
{
  assert_choice_type(types::overload_stop, type_, "InitiatingMessage");
  return c.get<overload_stop_s>();
}
const enb_direct_info_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_direct_info_transfer() const
{
  assert_choice_type(types::enb_direct_info_transfer, type_, "InitiatingMessage");
  return c.get<enb_direct_info_transfer_s>();
}
const mme_direct_info_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_direct_info_transfer() const
{
  assert_choice_type(types::mme_direct_info_transfer, type_, "InitiatingMessage");
  return c.get<mme_direct_info_transfer_s>();
}
const enb_cfg_transfer_s& s1ap_elem_procs_o::init_msg_c::enb_cfg_transfer() const
{
  assert_choice_type(types::enb_cfg_transfer, type_, "InitiatingMessage");
  return c.get<enb_cfg_transfer_s>();
}
const mme_cfg_transfer_s& s1ap_elem_procs_o::init_msg_c::mme_cfg_transfer() const
{
  assert_choice_type(types::mme_cfg_transfer, type_, "InitiatingMessage");
  return c.get<mme_cfg_transfer_s>();
}
const private_msg_s& s1ap_elem_procs_o::init_msg_c::private_msg() const
{
  assert_choice_type(types::private_msg, type_, "InitiatingMessage");
  return c.get<private_msg_s>();
}
void s1ap_elem_procs_o::init_msg_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_required:
      j.write_fieldname("HandoverRequired");
      c.get<ho_required_s>().to_json(j);
      break;
    case types::ho_request:
      j.write_fieldname("HandoverRequest");
      c.get<ho_request_s>().to_json(j);
      break;
    case types::path_switch_request:
      j.write_fieldname("PathSwitchRequest");
      c.get<path_switch_request_s>().to_json(j);
      break;
    case types::erab_setup_request:
      j.write_fieldname("E-RABSetupRequest");
      c.get<erab_setup_request_s>().to_json(j);
      break;
    case types::erab_modify_request:
      j.write_fieldname("E-RABModifyRequest");
      c.get<erab_modify_request_s>().to_json(j);
      break;
    case types::erab_release_cmd:
      j.write_fieldname("E-RABReleaseCommand");
      c.get<erab_release_cmd_s>().to_json(j);
      break;
    case types::init_context_setup_request:
      j.write_fieldname("InitialContextSetupRequest");
      c.get<init_context_setup_request_s>().to_json(j);
      break;
    case types::ho_cancel:
      j.write_fieldname("HandoverCancel");
      c.get<ho_cancel_s>().to_json(j);
      break;
    case types::kill_request:
      j.write_fieldname("KillRequest");
      c.get<kill_request_s>().to_json(j);
      break;
    case types::reset:
      j.write_fieldname("Reset");
      c.get<reset_s>().to_json(j);
      break;
    case types::s1_setup_request:
      j.write_fieldname("S1SetupRequest");
      c.get<s1_setup_request_s>().to_json(j);
      break;
    case types::ue_context_mod_request:
      j.write_fieldname("UEContextModificationRequest");
      c.get<ue_context_mod_request_s>().to_json(j);
      break;
    case types::ue_context_release_cmd:
      j.write_fieldname("UEContextReleaseCommand");
      c.get<ue_context_release_cmd_s>().to_json(j);
      break;
    case types::enb_cfg_upd:
      j.write_fieldname("ENBConfigurationUpdate");
      c.get<enb_cfg_upd_s>().to_json(j);
      break;
    case types::mme_cfg_upd:
      j.write_fieldname("MMEConfigurationUpdate");
      c.get<mme_cfg_upd_s>().to_json(j);
      break;
    case types::write_replace_warning_request:
      j.write_fieldname("WriteReplaceWarningRequest");
      c.get<write_replace_warning_request_s>().to_json(j);
      break;
    case types::ho_notify:
      j.write_fieldname("HandoverNotify");
      c.get<ho_notify_s>().to_json(j);
      break;
    case types::erab_release_ind:
      j.write_fieldname("E-RABReleaseIndication");
      c.get<erab_release_ind_s>().to_json(j);
      break;
    case types::paging:
      j.write_fieldname("Paging");
      c.get<paging_s>().to_json(j);
      break;
    case types::dl_nas_transport:
      j.write_fieldname("DownlinkNASTransport");
      c.get<dl_nas_transport_s>().to_json(j);
      break;
    case types::init_ue_msg:
      j.write_fieldname("InitialUEMessage");
      c.get<init_ue_msg_s>().to_json(j);
      break;
    case types::ul_nas_transport:
      j.write_fieldname("UplinkNASTransport");
      c.get<ul_nas_transport_s>().to_json(j);
      break;
    case types::error_ind:
      j.write_fieldname("ErrorIndication");
      c.get<error_ind_s>().to_json(j);
      break;
    case types::nas_non_delivery_ind:
      j.write_fieldname("NASNonDeliveryIndication");
      c.get<nas_non_delivery_ind_s>().to_json(j);
      break;
    case types::ue_context_release_request:
      j.write_fieldname("UEContextReleaseRequest");
      c.get<ue_context_release_request_s>().to_json(j);
      break;
    case types::dl_s1cdma2000tunnelling:
      j.write_fieldname("DownlinkS1cdma2000tunnelling");
      c.get<dl_s1cdma2000tunnelling_s>().to_json(j);
      break;
    case types::ul_s1cdma2000tunnelling:
      j.write_fieldname("UplinkS1cdma2000tunnelling");
      c.get<ul_s1cdma2000tunnelling_s>().to_json(j);
      break;
    case types::ue_cap_info_ind:
      j.write_fieldname("UECapabilityInfoIndication");
      c.get<ue_cap_info_ind_s>().to_json(j);
      break;
    case types::enb_status_transfer:
      j.write_fieldname("ENBStatusTransfer");
      c.get<enb_status_transfer_s>().to_json(j);
      break;
    case types::mme_status_transfer:
      j.write_fieldname("MMEStatusTransfer");
      c.get<mme_status_transfer_s>().to_json(j);
      break;
    case types::deactiv_trace:
      j.write_fieldname("DeactivateTrace");
      c.get<deactiv_trace_s>().to_json(j);
      break;
    case types::trace_start:
      j.write_fieldname("TraceStart");
      c.get<trace_start_s>().to_json(j);
      break;
    case types::trace_fail_ind:
      j.write_fieldname("TraceFailureIndication");
      c.get<trace_fail_ind_s>().to_json(j);
      break;
    case types::cell_traffic_trace:
      j.write_fieldname("CellTrafficTrace");
      c.get<cell_traffic_trace_s>().to_json(j);
      break;
    case types::location_report_ctrl:
      j.write_fieldname("LocationReportingControl");
      c.get<location_report_ctrl_s>().to_json(j);
      break;
    case types::location_report_fail_ind:
      j.write_fieldname("LocationReportingFailureIndication");
      c.get<location_report_fail_ind_s>().to_json(j);
      break;
    case types::location_report:
      j.write_fieldname("LocationReport");
      c.get<location_report_s>().to_json(j);
      break;
    case types::overload_start:
      j.write_fieldname("OverloadStart");
      c.get<overload_start_s>().to_json(j);
      break;
    case types::overload_stop:
      j.write_fieldname("OverloadStop");
      c.get<overload_stop_s>().to_json(j);
      break;
    case types::enb_direct_info_transfer:
      j.write_fieldname("ENBDirectInformationTransfer");
      c.get<enb_direct_info_transfer_s>().to_json(j);
      break;
    case types::mme_direct_info_transfer:
      j.write_fieldname("MMEDirectInformationTransfer");
      c.get<mme_direct_info_transfer_s>().to_json(j);
      break;
    case types::enb_cfg_transfer:
      j.write_fieldname("ENBConfigurationTransfer");
      c.get<enb_cfg_transfer_s>().to_json(j);
      break;
    case types::mme_cfg_transfer:
      j.write_fieldname("MMEConfigurationTransfer");
      c.get<mme_cfg_transfer_s>().to_json(j);
      break;
    case types::private_msg:
      j.write_fieldname("PrivateMessage");
      c.get<private_msg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
  }
  j.end_obj();
}
SRSASN_CODE s1ap_elem_procs_o::init_msg_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_required:
      HANDLE_CODE(c.get<ho_required_s>().pack(bref));
      break;
    case types::ho_request:
      HANDLE_CODE(c.get<ho_request_s>().pack(bref));
      break;
    case types::path_switch_request:
      HANDLE_CODE(c.get<path_switch_request_s>().pack(bref));
      break;
    case types::erab_setup_request:
      HANDLE_CODE(c.get<erab_setup_request_s>().pack(bref));
      break;
    case types::erab_modify_request:
      HANDLE_CODE(c.get<erab_modify_request_s>().pack(bref));
      break;
    case types::erab_release_cmd:
      HANDLE_CODE(c.get<erab_release_cmd_s>().pack(bref));
      break;
    case types::init_context_setup_request:
      HANDLE_CODE(c.get<init_context_setup_request_s>().pack(bref));
      break;
    case types::ho_cancel:
      HANDLE_CODE(c.get<ho_cancel_s>().pack(bref));
      break;
    case types::kill_request:
      HANDLE_CODE(c.get<kill_request_s>().pack(bref));
      break;
    case types::reset:
      HANDLE_CODE(c.get<reset_s>().pack(bref));
      break;
    case types::s1_setup_request:
      HANDLE_CODE(c.get<s1_setup_request_s>().pack(bref));
      break;
    case types::ue_context_mod_request:
      HANDLE_CODE(c.get<ue_context_mod_request_s>().pack(bref));
      break;
    case types::ue_context_release_cmd:
      HANDLE_CODE(c.get<ue_context_release_cmd_s>().pack(bref));
      break;
    case types::enb_cfg_upd:
      HANDLE_CODE(c.get<enb_cfg_upd_s>().pack(bref));
      break;
    case types::mme_cfg_upd:
      HANDLE_CODE(c.get<mme_cfg_upd_s>().pack(bref));
      break;
    case types::write_replace_warning_request:
      HANDLE_CODE(c.get<write_replace_warning_request_s>().pack(bref));
      break;
    case types::ho_notify:
      HANDLE_CODE(c.get<ho_notify_s>().pack(bref));
      break;
    case types::erab_release_ind:
      HANDLE_CODE(c.get<erab_release_ind_s>().pack(bref));
      break;
    case types::paging:
      HANDLE_CODE(c.get<paging_s>().pack(bref));
      break;
    case types::dl_nas_transport:
      HANDLE_CODE(c.get<dl_nas_transport_s>().pack(bref));
      break;
    case types::init_ue_msg:
      HANDLE_CODE(c.get<init_ue_msg_s>().pack(bref));
      break;
    case types::ul_nas_transport:
      HANDLE_CODE(c.get<ul_nas_transport_s>().pack(bref));
      break;
    case types::error_ind:
      HANDLE_CODE(c.get<error_ind_s>().pack(bref));
      break;
    case types::nas_non_delivery_ind:
      HANDLE_CODE(c.get<nas_non_delivery_ind_s>().pack(bref));
      break;
    case types::ue_context_release_request:
      HANDLE_CODE(c.get<ue_context_release_request_s>().pack(bref));
      break;
    case types::dl_s1cdma2000tunnelling:
      HANDLE_CODE(c.get<dl_s1cdma2000tunnelling_s>().pack(bref));
      break;
    case types::ul_s1cdma2000tunnelling:
      HANDLE_CODE(c.get<ul_s1cdma2000tunnelling_s>().pack(bref));
      break;
    case types::ue_cap_info_ind:
      HANDLE_CODE(c.get<ue_cap_info_ind_s>().pack(bref));
      break;
    case types::enb_status_transfer:
      HANDLE_CODE(c.get<enb_status_transfer_s>().pack(bref));
      break;
    case types::mme_status_transfer:
      HANDLE_CODE(c.get<mme_status_transfer_s>().pack(bref));
      break;
    case types::deactiv_trace:
      HANDLE_CODE(c.get<deactiv_trace_s>().pack(bref));
      break;
    case types::trace_start:
      HANDLE_CODE(c.get<trace_start_s>().pack(bref));
      break;
    case types::trace_fail_ind:
      HANDLE_CODE(c.get<trace_fail_ind_s>().pack(bref));
      break;
    case types::cell_traffic_trace:
      HANDLE_CODE(c.get<cell_traffic_trace_s>().pack(bref));
      break;
    case types::location_report_ctrl:
      HANDLE_CODE(c.get<location_report_ctrl_s>().pack(bref));
      break;
    case types::location_report_fail_ind:
      HANDLE_CODE(c.get<location_report_fail_ind_s>().pack(bref));
      break;
    case types::location_report:
      HANDLE_CODE(c.get<location_report_s>().pack(bref));
      break;
    case types::overload_start:
      HANDLE_CODE(c.get<overload_start_s>().pack(bref));
      break;
    case types::overload_stop:
      HANDLE_CODE(c.get<overload_stop_s>().pack(bref));
      break;
    case types::enb_direct_info_transfer:
      HANDLE_CODE(c.get<enb_direct_info_transfer_s>().pack(bref));
      break;
    case types::mme_direct_info_transfer:
      HANDLE_CODE(c.get<mme_direct_info_transfer_s>().pack(bref));
      break;
    case types::enb_cfg_transfer:
      HANDLE_CODE(c.get<enb_cfg_transfer_s>().pack(bref));
      break;
    case types::mme_cfg_transfer:
      HANDLE_CODE(c.get<mme_cfg_transfer_s>().pack(bref));
      break;
    case types::private_msg:
      HANDLE_CODE(c.get<private_msg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_elem_procs_o::init_msg_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_required:
      HANDLE_CODE(c.get<ho_required_s>().unpack(bref));
      break;
    case types::ho_request:
      HANDLE_CODE(c.get<ho_request_s>().unpack(bref));
      break;
    case types::path_switch_request:
      HANDLE_CODE(c.get<path_switch_request_s>().unpack(bref));
      break;
    case types::erab_setup_request:
      HANDLE_CODE(c.get<erab_setup_request_s>().unpack(bref));
      break;
    case types::erab_modify_request:
      HANDLE_CODE(c.get<erab_modify_request_s>().unpack(bref));
      break;
    case types::erab_release_cmd:
      HANDLE_CODE(c.get<erab_release_cmd_s>().unpack(bref));
      break;
    case types::init_context_setup_request:
      HANDLE_CODE(c.get<init_context_setup_request_s>().unpack(bref));
      break;
    case types::ho_cancel:
      HANDLE_CODE(c.get<ho_cancel_s>().unpack(bref));
      break;
    case types::kill_request:
      HANDLE_CODE(c.get<kill_request_s>().unpack(bref));
      break;
    case types::reset:
      HANDLE_CODE(c.get<reset_s>().unpack(bref));
      break;
    case types::s1_setup_request:
      HANDLE_CODE(c.get<s1_setup_request_s>().unpack(bref));
      break;
    case types::ue_context_mod_request:
      HANDLE_CODE(c.get<ue_context_mod_request_s>().unpack(bref));
      break;
    case types::ue_context_release_cmd:
      HANDLE_CODE(c.get<ue_context_release_cmd_s>().unpack(bref));
      break;
    case types::enb_cfg_upd:
      HANDLE_CODE(c.get<enb_cfg_upd_s>().unpack(bref));
      break;
    case types::mme_cfg_upd:
      HANDLE_CODE(c.get<mme_cfg_upd_s>().unpack(bref));
      break;
    case types::write_replace_warning_request:
      HANDLE_CODE(c.get<write_replace_warning_request_s>().unpack(bref));
      break;
    case types::ho_notify:
      HANDLE_CODE(c.get<ho_notify_s>().unpack(bref));
      break;
    case types::erab_release_ind:
      HANDLE_CODE(c.get<erab_release_ind_s>().unpack(bref));
      break;
    case types::paging:
      HANDLE_CODE(c.get<paging_s>().unpack(bref));
      break;
    case types::dl_nas_transport:
      HANDLE_CODE(c.get<dl_nas_transport_s>().unpack(bref));
      break;
    case types::init_ue_msg:
      HANDLE_CODE(c.get<init_ue_msg_s>().unpack(bref));
      break;
    case types::ul_nas_transport:
      HANDLE_CODE(c.get<ul_nas_transport_s>().unpack(bref));
      break;
    case types::error_ind:
      HANDLE_CODE(c.get<error_ind_s>().unpack(bref));
      break;
    case types::nas_non_delivery_ind:
      HANDLE_CODE(c.get<nas_non_delivery_ind_s>().unpack(bref));
      break;
    case types::ue_context_release_request:
      HANDLE_CODE(c.get<ue_context_release_request_s>().unpack(bref));
      break;
    case types::dl_s1cdma2000tunnelling:
      HANDLE_CODE(c.get<dl_s1cdma2000tunnelling_s>().unpack(bref));
      break;
    case types::ul_s1cdma2000tunnelling:
      HANDLE_CODE(c.get<ul_s1cdma2000tunnelling_s>().unpack(bref));
      break;
    case types::ue_cap_info_ind:
      HANDLE_CODE(c.get<ue_cap_info_ind_s>().unpack(bref));
      break;
    case types::enb_status_transfer:
      HANDLE_CODE(c.get<enb_status_transfer_s>().unpack(bref));
      break;
    case types::mme_status_transfer:
      HANDLE_CODE(c.get<mme_status_transfer_s>().unpack(bref));
      break;
    case types::deactiv_trace:
      HANDLE_CODE(c.get<deactiv_trace_s>().unpack(bref));
      break;
    case types::trace_start:
      HANDLE_CODE(c.get<trace_start_s>().unpack(bref));
      break;
    case types::trace_fail_ind:
      HANDLE_CODE(c.get<trace_fail_ind_s>().unpack(bref));
      break;
    case types::cell_traffic_trace:
      HANDLE_CODE(c.get<cell_traffic_trace_s>().unpack(bref));
      break;
    case types::location_report_ctrl:
      HANDLE_CODE(c.get<location_report_ctrl_s>().unpack(bref));
      break;
    case types::location_report_fail_ind:
      HANDLE_CODE(c.get<location_report_fail_ind_s>().unpack(bref));
      break;
    case types::location_report:
      HANDLE_CODE(c.get<location_report_s>().unpack(bref));
      break;
    case types::overload_start:
      HANDLE_CODE(c.get<overload_start_s>().unpack(bref));
      break;
    case types::overload_stop:
      HANDLE_CODE(c.get<overload_stop_s>().unpack(bref));
      break;
    case types::enb_direct_info_transfer:
      HANDLE_CODE(c.get<enb_direct_info_transfer_s>().unpack(bref));
      break;
    case types::mme_direct_info_transfer:
      HANDLE_CODE(c.get<mme_direct_info_transfer_s>().unpack(bref));
      break;
    case types::enb_cfg_transfer:
      HANDLE_CODE(c.get<enb_cfg_transfer_s>().unpack(bref));
      break;
    case types::mme_cfg_transfer:
      HANDLE_CODE(c.get<mme_cfg_transfer_s>().unpack(bref));
      break;
    case types::private_msg:
      HANDLE_CODE(c.get<private_msg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::init_msg_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1ap_elem_procs_o::init_msg_c::types_opts::to_string() const
{
  static const char* options[] = {"HandoverRequired",
                                  "HandoverRequest",
                                  "PathSwitchRequest",
                                  "E-RABSetupRequest",
                                  "E-RABModifyRequest",
                                  "E-RABReleaseCommand",
                                  "InitialContextSetupRequest",
                                  "HandoverCancel",
                                  "KillRequest",
                                  "Reset",
                                  "S1SetupRequest",
                                  "UEContextModificationRequest",
                                  "UEContextReleaseCommand",
                                  "ENBConfigurationUpdate",
                                  "MMEConfigurationUpdate",
                                  "WriteReplaceWarningRequest",
                                  "HandoverNotify",
                                  "E-RABReleaseIndication",
                                  "Paging",
                                  "DownlinkNASTransport",
                                  "InitialUEMessage",
                                  "UplinkNASTransport",
                                  "ErrorIndication",
                                  "NASNonDeliveryIndication",
                                  "UEContextReleaseRequest",
                                  "DownlinkS1cdma2000tunnelling",
                                  "UplinkS1cdma2000tunnelling",
                                  "UECapabilityInfoIndication",
                                  "ENBStatusTransfer",
                                  "MMEStatusTransfer",
                                  "DeactivateTrace",
                                  "TraceStart",
                                  "TraceFailureIndication",
                                  "CellTrafficTrace",
                                  "LocationReportingControl",
                                  "LocationReportingFailureIndication",
                                  "LocationReport",
                                  "OverloadStart",
                                  "OverloadStop",
                                  "ENBDirectInformationTransfer",
                                  "MMEDirectInformationTransfer",
                                  "ENBConfigurationTransfer",
                                  "MMEConfigurationTransfer",
                                  "PrivateMessage"};
  return convert_enum_idx(options, 44, value, "s1ap_elem_procs_o::init_msg_c::types");
}

// SuccessfulOutcome ::= OPEN TYPE
void s1ap_elem_procs_o::successful_outcome_c::destroy_()
{
  switch (type_) {
    case types::ho_cmd:
      c.destroy<ho_cmd_s>();
      break;
    case types::ho_request_ack:
      c.destroy<ho_request_ack_s>();
      break;
    case types::path_switch_request_ack:
      c.destroy<path_switch_request_ack_s>();
      break;
    case types::erab_setup_resp:
      c.destroy<erab_setup_resp_s>();
      break;
    case types::erab_modify_resp:
      c.destroy<erab_modify_resp_s>();
      break;
    case types::erab_release_resp:
      c.destroy<erab_release_resp_s>();
      break;
    case types::init_context_setup_resp:
      c.destroy<init_context_setup_resp_s>();
      break;
    case types::ho_cancel_ack:
      c.destroy<ho_cancel_ack_s>();
      break;
    case types::kill_resp:
      c.destroy<kill_resp_s>();
      break;
    case types::reset_ack:
      c.destroy<reset_ack_s>();
      break;
    case types::s1_setup_resp:
      c.destroy<s1_setup_resp_s>();
      break;
    case types::ue_context_mod_resp:
      c.destroy<ue_context_mod_resp_s>();
      break;
    case types::ue_context_release_complete:
      c.destroy<ue_context_release_complete_s>();
      break;
    case types::enb_cfg_upd_ack:
      c.destroy<enb_cfg_upd_ack_s>();
      break;
    case types::mme_cfg_upd_ack:
      c.destroy<mme_cfg_upd_ack_s>();
      break;
    case types::write_replace_warning_resp:
      c.destroy<write_replace_warning_resp_s>();
      break;
    default:
      break;
  }
}
void s1ap_elem_procs_o::successful_outcome_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_cmd:
      c.init<ho_cmd_s>();
      break;
    case types::ho_request_ack:
      c.init<ho_request_ack_s>();
      break;
    case types::path_switch_request_ack:
      c.init<path_switch_request_ack_s>();
      break;
    case types::erab_setup_resp:
      c.init<erab_setup_resp_s>();
      break;
    case types::erab_modify_resp:
      c.init<erab_modify_resp_s>();
      break;
    case types::erab_release_resp:
      c.init<erab_release_resp_s>();
      break;
    case types::init_context_setup_resp:
      c.init<init_context_setup_resp_s>();
      break;
    case types::ho_cancel_ack:
      c.init<ho_cancel_ack_s>();
      break;
    case types::kill_resp:
      c.init<kill_resp_s>();
      break;
    case types::reset_ack:
      c.init<reset_ack_s>();
      break;
    case types::s1_setup_resp:
      c.init<s1_setup_resp_s>();
      break;
    case types::ue_context_mod_resp:
      c.init<ue_context_mod_resp_s>();
      break;
    case types::ue_context_release_complete:
      c.init<ue_context_release_complete_s>();
      break;
    case types::enb_cfg_upd_ack:
      c.init<enb_cfg_upd_ack_s>();
      break;
    case types::mme_cfg_upd_ack:
      c.init<mme_cfg_upd_ack_s>();
      break;
    case types::write_replace_warning_resp:
      c.init<write_replace_warning_resp_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
  }
}
s1ap_elem_procs_o::successful_outcome_c::successful_outcome_c(const s1ap_elem_procs_o::successful_outcome_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_cmd:
      c.init(other.c.get<ho_cmd_s>());
      break;
    case types::ho_request_ack:
      c.init(other.c.get<ho_request_ack_s>());
      break;
    case types::path_switch_request_ack:
      c.init(other.c.get<path_switch_request_ack_s>());
      break;
    case types::erab_setup_resp:
      c.init(other.c.get<erab_setup_resp_s>());
      break;
    case types::erab_modify_resp:
      c.init(other.c.get<erab_modify_resp_s>());
      break;
    case types::erab_release_resp:
      c.init(other.c.get<erab_release_resp_s>());
      break;
    case types::init_context_setup_resp:
      c.init(other.c.get<init_context_setup_resp_s>());
      break;
    case types::ho_cancel_ack:
      c.init(other.c.get<ho_cancel_ack_s>());
      break;
    case types::kill_resp:
      c.init(other.c.get<kill_resp_s>());
      break;
    case types::reset_ack:
      c.init(other.c.get<reset_ack_s>());
      break;
    case types::s1_setup_resp:
      c.init(other.c.get<s1_setup_resp_s>());
      break;
    case types::ue_context_mod_resp:
      c.init(other.c.get<ue_context_mod_resp_s>());
      break;
    case types::ue_context_release_complete:
      c.init(other.c.get<ue_context_release_complete_s>());
      break;
    case types::enb_cfg_upd_ack:
      c.init(other.c.get<enb_cfg_upd_ack_s>());
      break;
    case types::mme_cfg_upd_ack:
      c.init(other.c.get<mme_cfg_upd_ack_s>());
      break;
    case types::write_replace_warning_resp:
      c.init(other.c.get<write_replace_warning_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
  }
}
s1ap_elem_procs_o::successful_outcome_c&
s1ap_elem_procs_o::successful_outcome_c::operator=(const s1ap_elem_procs_o::successful_outcome_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_cmd:
      c.set(other.c.get<ho_cmd_s>());
      break;
    case types::ho_request_ack:
      c.set(other.c.get<ho_request_ack_s>());
      break;
    case types::path_switch_request_ack:
      c.set(other.c.get<path_switch_request_ack_s>());
      break;
    case types::erab_setup_resp:
      c.set(other.c.get<erab_setup_resp_s>());
      break;
    case types::erab_modify_resp:
      c.set(other.c.get<erab_modify_resp_s>());
      break;
    case types::erab_release_resp:
      c.set(other.c.get<erab_release_resp_s>());
      break;
    case types::init_context_setup_resp:
      c.set(other.c.get<init_context_setup_resp_s>());
      break;
    case types::ho_cancel_ack:
      c.set(other.c.get<ho_cancel_ack_s>());
      break;
    case types::kill_resp:
      c.set(other.c.get<kill_resp_s>());
      break;
    case types::reset_ack:
      c.set(other.c.get<reset_ack_s>());
      break;
    case types::s1_setup_resp:
      c.set(other.c.get<s1_setup_resp_s>());
      break;
    case types::ue_context_mod_resp:
      c.set(other.c.get<ue_context_mod_resp_s>());
      break;
    case types::ue_context_release_complete:
      c.set(other.c.get<ue_context_release_complete_s>());
      break;
    case types::enb_cfg_upd_ack:
      c.set(other.c.get<enb_cfg_upd_ack_s>());
      break;
    case types::mme_cfg_upd_ack:
      c.set(other.c.get<mme_cfg_upd_ack_s>());
      break;
    case types::write_replace_warning_resp:
      c.set(other.c.get<write_replace_warning_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
  }

  return *this;
}
ho_cmd_s& s1ap_elem_procs_o::successful_outcome_c::ho_cmd()
{
  assert_choice_type(types::ho_cmd, type_, "SuccessfulOutcome");
  return c.get<ho_cmd_s>();
}
ho_request_ack_s& s1ap_elem_procs_o::successful_outcome_c::ho_request_ack()
{
  assert_choice_type(types::ho_request_ack, type_, "SuccessfulOutcome");
  return c.get<ho_request_ack_s>();
}
path_switch_request_ack_s& s1ap_elem_procs_o::successful_outcome_c::path_switch_request_ack()
{
  assert_choice_type(types::path_switch_request_ack, type_, "SuccessfulOutcome");
  return c.get<path_switch_request_ack_s>();
}
erab_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_setup_resp()
{
  assert_choice_type(types::erab_setup_resp, type_, "SuccessfulOutcome");
  return c.get<erab_setup_resp_s>();
}
erab_modify_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_modify_resp()
{
  assert_choice_type(types::erab_modify_resp, type_, "SuccessfulOutcome");
  return c.get<erab_modify_resp_s>();
}
erab_release_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_release_resp()
{
  assert_choice_type(types::erab_release_resp, type_, "SuccessfulOutcome");
  return c.get<erab_release_resp_s>();
}
init_context_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::init_context_setup_resp()
{
  assert_choice_type(types::init_context_setup_resp, type_, "SuccessfulOutcome");
  return c.get<init_context_setup_resp_s>();
}
ho_cancel_ack_s& s1ap_elem_procs_o::successful_outcome_c::ho_cancel_ack()
{
  assert_choice_type(types::ho_cancel_ack, type_, "SuccessfulOutcome");
  return c.get<ho_cancel_ack_s>();
}
kill_resp_s& s1ap_elem_procs_o::successful_outcome_c::kill_resp()
{
  assert_choice_type(types::kill_resp, type_, "SuccessfulOutcome");
  return c.get<kill_resp_s>();
}
reset_ack_s& s1ap_elem_procs_o::successful_outcome_c::reset_ack()
{
  assert_choice_type(types::reset_ack, type_, "SuccessfulOutcome");
  return c.get<reset_ack_s>();
}
s1_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::s1_setup_resp()
{
  assert_choice_type(types::s1_setup_resp, type_, "SuccessfulOutcome");
  return c.get<s1_setup_resp_s>();
}
ue_context_mod_resp_s& s1ap_elem_procs_o::successful_outcome_c::ue_context_mod_resp()
{
  assert_choice_type(types::ue_context_mod_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_mod_resp_s>();
}
ue_context_release_complete_s& s1ap_elem_procs_o::successful_outcome_c::ue_context_release_complete()
{
  assert_choice_type(types::ue_context_release_complete, type_, "SuccessfulOutcome");
  return c.get<ue_context_release_complete_s>();
}
enb_cfg_upd_ack_s& s1ap_elem_procs_o::successful_outcome_c::enb_cfg_upd_ack()
{
  assert_choice_type(types::enb_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<enb_cfg_upd_ack_s>();
}
mme_cfg_upd_ack_s& s1ap_elem_procs_o::successful_outcome_c::mme_cfg_upd_ack()
{
  assert_choice_type(types::mme_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<mme_cfg_upd_ack_s>();
}
write_replace_warning_resp_s& s1ap_elem_procs_o::successful_outcome_c::write_replace_warning_resp()
{
  assert_choice_type(types::write_replace_warning_resp, type_, "SuccessfulOutcome");
  return c.get<write_replace_warning_resp_s>();
}
const ho_cmd_s& s1ap_elem_procs_o::successful_outcome_c::ho_cmd() const
{
  assert_choice_type(types::ho_cmd, type_, "SuccessfulOutcome");
  return c.get<ho_cmd_s>();
}
const ho_request_ack_s& s1ap_elem_procs_o::successful_outcome_c::ho_request_ack() const
{
  assert_choice_type(types::ho_request_ack, type_, "SuccessfulOutcome");
  return c.get<ho_request_ack_s>();
}
const path_switch_request_ack_s& s1ap_elem_procs_o::successful_outcome_c::path_switch_request_ack() const
{
  assert_choice_type(types::path_switch_request_ack, type_, "SuccessfulOutcome");
  return c.get<path_switch_request_ack_s>();
}
const erab_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_setup_resp() const
{
  assert_choice_type(types::erab_setup_resp, type_, "SuccessfulOutcome");
  return c.get<erab_setup_resp_s>();
}
const erab_modify_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_modify_resp() const
{
  assert_choice_type(types::erab_modify_resp, type_, "SuccessfulOutcome");
  return c.get<erab_modify_resp_s>();
}
const erab_release_resp_s& s1ap_elem_procs_o::successful_outcome_c::erab_release_resp() const
{
  assert_choice_type(types::erab_release_resp, type_, "SuccessfulOutcome");
  return c.get<erab_release_resp_s>();
}
const init_context_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::init_context_setup_resp() const
{
  assert_choice_type(types::init_context_setup_resp, type_, "SuccessfulOutcome");
  return c.get<init_context_setup_resp_s>();
}
const ho_cancel_ack_s& s1ap_elem_procs_o::successful_outcome_c::ho_cancel_ack() const
{
  assert_choice_type(types::ho_cancel_ack, type_, "SuccessfulOutcome");
  return c.get<ho_cancel_ack_s>();
}
const kill_resp_s& s1ap_elem_procs_o::successful_outcome_c::kill_resp() const
{
  assert_choice_type(types::kill_resp, type_, "SuccessfulOutcome");
  return c.get<kill_resp_s>();
}
const reset_ack_s& s1ap_elem_procs_o::successful_outcome_c::reset_ack() const
{
  assert_choice_type(types::reset_ack, type_, "SuccessfulOutcome");
  return c.get<reset_ack_s>();
}
const s1_setup_resp_s& s1ap_elem_procs_o::successful_outcome_c::s1_setup_resp() const
{
  assert_choice_type(types::s1_setup_resp, type_, "SuccessfulOutcome");
  return c.get<s1_setup_resp_s>();
}
const ue_context_mod_resp_s& s1ap_elem_procs_o::successful_outcome_c::ue_context_mod_resp() const
{
  assert_choice_type(types::ue_context_mod_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_mod_resp_s>();
}
const ue_context_release_complete_s& s1ap_elem_procs_o::successful_outcome_c::ue_context_release_complete() const
{
  assert_choice_type(types::ue_context_release_complete, type_, "SuccessfulOutcome");
  return c.get<ue_context_release_complete_s>();
}
const enb_cfg_upd_ack_s& s1ap_elem_procs_o::successful_outcome_c::enb_cfg_upd_ack() const
{
  assert_choice_type(types::enb_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<enb_cfg_upd_ack_s>();
}
const mme_cfg_upd_ack_s& s1ap_elem_procs_o::successful_outcome_c::mme_cfg_upd_ack() const
{
  assert_choice_type(types::mme_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<mme_cfg_upd_ack_s>();
}
const write_replace_warning_resp_s& s1ap_elem_procs_o::successful_outcome_c::write_replace_warning_resp() const
{
  assert_choice_type(types::write_replace_warning_resp, type_, "SuccessfulOutcome");
  return c.get<write_replace_warning_resp_s>();
}
void s1ap_elem_procs_o::successful_outcome_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_cmd:
      j.write_fieldname("HandoverCommand");
      c.get<ho_cmd_s>().to_json(j);
      break;
    case types::ho_request_ack:
      j.write_fieldname("HandoverRequestAcknowledge");
      c.get<ho_request_ack_s>().to_json(j);
      break;
    case types::path_switch_request_ack:
      j.write_fieldname("PathSwitchRequestAcknowledge");
      c.get<path_switch_request_ack_s>().to_json(j);
      break;
    case types::erab_setup_resp:
      j.write_fieldname("E-RABSetupResponse");
      c.get<erab_setup_resp_s>().to_json(j);
      break;
    case types::erab_modify_resp:
      j.write_fieldname("E-RABModifyResponse");
      c.get<erab_modify_resp_s>().to_json(j);
      break;
    case types::erab_release_resp:
      j.write_fieldname("E-RABReleaseResponse");
      c.get<erab_release_resp_s>().to_json(j);
      break;
    case types::init_context_setup_resp:
      j.write_fieldname("InitialContextSetupResponse");
      c.get<init_context_setup_resp_s>().to_json(j);
      break;
    case types::ho_cancel_ack:
      j.write_fieldname("HandoverCancelAcknowledge");
      c.get<ho_cancel_ack_s>().to_json(j);
      break;
    case types::kill_resp:
      j.write_fieldname("KillResponse");
      c.get<kill_resp_s>().to_json(j);
      break;
    case types::reset_ack:
      j.write_fieldname("ResetAcknowledge");
      c.get<reset_ack_s>().to_json(j);
      break;
    case types::s1_setup_resp:
      j.write_fieldname("S1SetupResponse");
      c.get<s1_setup_resp_s>().to_json(j);
      break;
    case types::ue_context_mod_resp:
      j.write_fieldname("UEContextModificationResponse");
      c.get<ue_context_mod_resp_s>().to_json(j);
      break;
    case types::ue_context_release_complete:
      j.write_fieldname("UEContextReleaseComplete");
      c.get<ue_context_release_complete_s>().to_json(j);
      break;
    case types::enb_cfg_upd_ack:
      j.write_fieldname("ENBConfigurationUpdateAcknowledge");
      c.get<enb_cfg_upd_ack_s>().to_json(j);
      break;
    case types::mme_cfg_upd_ack:
      j.write_fieldname("MMEConfigurationUpdateAcknowledge");
      c.get<mme_cfg_upd_ack_s>().to_json(j);
      break;
    case types::write_replace_warning_resp:
      j.write_fieldname("WriteReplaceWarningResponse");
      c.get<write_replace_warning_resp_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
  }
  j.end_obj();
}
SRSASN_CODE s1ap_elem_procs_o::successful_outcome_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_cmd:
      HANDLE_CODE(c.get<ho_cmd_s>().pack(bref));
      break;
    case types::ho_request_ack:
      HANDLE_CODE(c.get<ho_request_ack_s>().pack(bref));
      break;
    case types::path_switch_request_ack:
      HANDLE_CODE(c.get<path_switch_request_ack_s>().pack(bref));
      break;
    case types::erab_setup_resp:
      HANDLE_CODE(c.get<erab_setup_resp_s>().pack(bref));
      break;
    case types::erab_modify_resp:
      HANDLE_CODE(c.get<erab_modify_resp_s>().pack(bref));
      break;
    case types::erab_release_resp:
      HANDLE_CODE(c.get<erab_release_resp_s>().pack(bref));
      break;
    case types::init_context_setup_resp:
      HANDLE_CODE(c.get<init_context_setup_resp_s>().pack(bref));
      break;
    case types::ho_cancel_ack:
      HANDLE_CODE(c.get<ho_cancel_ack_s>().pack(bref));
      break;
    case types::kill_resp:
      HANDLE_CODE(c.get<kill_resp_s>().pack(bref));
      break;
    case types::reset_ack:
      HANDLE_CODE(c.get<reset_ack_s>().pack(bref));
      break;
    case types::s1_setup_resp:
      HANDLE_CODE(c.get<s1_setup_resp_s>().pack(bref));
      break;
    case types::ue_context_mod_resp:
      HANDLE_CODE(c.get<ue_context_mod_resp_s>().pack(bref));
      break;
    case types::ue_context_release_complete:
      HANDLE_CODE(c.get<ue_context_release_complete_s>().pack(bref));
      break;
    case types::enb_cfg_upd_ack:
      HANDLE_CODE(c.get<enb_cfg_upd_ack_s>().pack(bref));
      break;
    case types::mme_cfg_upd_ack:
      HANDLE_CODE(c.get<mme_cfg_upd_ack_s>().pack(bref));
      break;
    case types::write_replace_warning_resp:
      HANDLE_CODE(c.get<write_replace_warning_resp_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_elem_procs_o::successful_outcome_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_cmd:
      HANDLE_CODE(c.get<ho_cmd_s>().unpack(bref));
      break;
    case types::ho_request_ack:
      HANDLE_CODE(c.get<ho_request_ack_s>().unpack(bref));
      break;
    case types::path_switch_request_ack:
      HANDLE_CODE(c.get<path_switch_request_ack_s>().unpack(bref));
      break;
    case types::erab_setup_resp:
      HANDLE_CODE(c.get<erab_setup_resp_s>().unpack(bref));
      break;
    case types::erab_modify_resp:
      HANDLE_CODE(c.get<erab_modify_resp_s>().unpack(bref));
      break;
    case types::erab_release_resp:
      HANDLE_CODE(c.get<erab_release_resp_s>().unpack(bref));
      break;
    case types::init_context_setup_resp:
      HANDLE_CODE(c.get<init_context_setup_resp_s>().unpack(bref));
      break;
    case types::ho_cancel_ack:
      HANDLE_CODE(c.get<ho_cancel_ack_s>().unpack(bref));
      break;
    case types::kill_resp:
      HANDLE_CODE(c.get<kill_resp_s>().unpack(bref));
      break;
    case types::reset_ack:
      HANDLE_CODE(c.get<reset_ack_s>().unpack(bref));
      break;
    case types::s1_setup_resp:
      HANDLE_CODE(c.get<s1_setup_resp_s>().unpack(bref));
      break;
    case types::ue_context_mod_resp:
      HANDLE_CODE(c.get<ue_context_mod_resp_s>().unpack(bref));
      break;
    case types::ue_context_release_complete:
      HANDLE_CODE(c.get<ue_context_release_complete_s>().unpack(bref));
      break;
    case types::enb_cfg_upd_ack:
      HANDLE_CODE(c.get<enb_cfg_upd_ack_s>().unpack(bref));
      break;
    case types::mme_cfg_upd_ack:
      HANDLE_CODE(c.get<mme_cfg_upd_ack_s>().unpack(bref));
      break;
    case types::write_replace_warning_resp:
      HANDLE_CODE(c.get<write_replace_warning_resp_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::successful_outcome_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1ap_elem_procs_o::successful_outcome_c::types_opts::to_string() const
{
  static const char* options[] = {"HandoverCommand",
                                  "HandoverRequestAcknowledge",
                                  "PathSwitchRequestAcknowledge",
                                  "E-RABSetupResponse",
                                  "E-RABModifyResponse",
                                  "E-RABReleaseResponse",
                                  "InitialContextSetupResponse",
                                  "HandoverCancelAcknowledge",
                                  "KillResponse",
                                  "ResetAcknowledge",
                                  "S1SetupResponse",
                                  "UEContextModificationResponse",
                                  "UEContextReleaseComplete",
                                  "ENBConfigurationUpdateAcknowledge",
                                  "MMEConfigurationUpdateAcknowledge",
                                  "WriteReplaceWarningResponse"};
  return convert_enum_idx(options, 16, value, "s1ap_elem_procs_o::successful_outcome_c::types");
}
uint8_t s1ap_elem_procs_o::successful_outcome_c::types_opts::to_number() const
{
  if (value == s1_setup_resp) {
    return 1;
  }
  invalid_enum_number(value, "s1ap_elem_procs_o::successful_outcome_c::types");
  return 0;
}

// UnsuccessfulOutcome ::= OPEN TYPE
void s1ap_elem_procs_o::unsuccessful_outcome_c::destroy_()
{
  switch (type_) {
    case types::ho_prep_fail:
      c.destroy<ho_prep_fail_s>();
      break;
    case types::ho_fail:
      c.destroy<ho_fail_s>();
      break;
    case types::path_switch_request_fail:
      c.destroy<path_switch_request_fail_s>();
      break;
    case types::init_context_setup_fail:
      c.destroy<init_context_setup_fail_s>();
      break;
    case types::s1_setup_fail:
      c.destroy<s1_setup_fail_s>();
      break;
    case types::ue_context_mod_fail:
      c.destroy<ue_context_mod_fail_s>();
      break;
    case types::enb_cfg_upd_fail:
      c.destroy<enb_cfg_upd_fail_s>();
      break;
    case types::mme_cfg_upd_fail:
      c.destroy<mme_cfg_upd_fail_s>();
      break;
    default:
      break;
  }
}
void s1ap_elem_procs_o::unsuccessful_outcome_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_prep_fail:
      c.init<ho_prep_fail_s>();
      break;
    case types::ho_fail:
      c.init<ho_fail_s>();
      break;
    case types::path_switch_request_fail:
      c.init<path_switch_request_fail_s>();
      break;
    case types::init_context_setup_fail:
      c.init<init_context_setup_fail_s>();
      break;
    case types::s1_setup_fail:
      c.init<s1_setup_fail_s>();
      break;
    case types::ue_context_mod_fail:
      c.init<ue_context_mod_fail_s>();
      break;
    case types::enb_cfg_upd_fail:
      c.init<enb_cfg_upd_fail_s>();
      break;
    case types::mme_cfg_upd_fail:
      c.init<mme_cfg_upd_fail_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
  }
}
s1ap_elem_procs_o::unsuccessful_outcome_c::unsuccessful_outcome_c(
    const s1ap_elem_procs_o::unsuccessful_outcome_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_prep_fail:
      c.init(other.c.get<ho_prep_fail_s>());
      break;
    case types::ho_fail:
      c.init(other.c.get<ho_fail_s>());
      break;
    case types::path_switch_request_fail:
      c.init(other.c.get<path_switch_request_fail_s>());
      break;
    case types::init_context_setup_fail:
      c.init(other.c.get<init_context_setup_fail_s>());
      break;
    case types::s1_setup_fail:
      c.init(other.c.get<s1_setup_fail_s>());
      break;
    case types::ue_context_mod_fail:
      c.init(other.c.get<ue_context_mod_fail_s>());
      break;
    case types::enb_cfg_upd_fail:
      c.init(other.c.get<enb_cfg_upd_fail_s>());
      break;
    case types::mme_cfg_upd_fail:
      c.init(other.c.get<mme_cfg_upd_fail_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
  }
}
s1ap_elem_procs_o::unsuccessful_outcome_c&
s1ap_elem_procs_o::unsuccessful_outcome_c::operator=(const s1ap_elem_procs_o::unsuccessful_outcome_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_prep_fail:
      c.set(other.c.get<ho_prep_fail_s>());
      break;
    case types::ho_fail:
      c.set(other.c.get<ho_fail_s>());
      break;
    case types::path_switch_request_fail:
      c.set(other.c.get<path_switch_request_fail_s>());
      break;
    case types::init_context_setup_fail:
      c.set(other.c.get<init_context_setup_fail_s>());
      break;
    case types::s1_setup_fail:
      c.set(other.c.get<s1_setup_fail_s>());
      break;
    case types::ue_context_mod_fail:
      c.set(other.c.get<ue_context_mod_fail_s>());
      break;
    case types::enb_cfg_upd_fail:
      c.set(other.c.get<enb_cfg_upd_fail_s>());
      break;
    case types::mme_cfg_upd_fail:
      c.set(other.c.get<mme_cfg_upd_fail_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
  }

  return *this;
}
ho_prep_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ho_prep_fail()
{
  assert_choice_type(types::ho_prep_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_prep_fail_s>();
}
ho_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ho_fail()
{
  assert_choice_type(types::ho_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_fail_s>();
}
path_switch_request_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::path_switch_request_fail()
{
  assert_choice_type(types::path_switch_request_fail, type_, "UnsuccessfulOutcome");
  return c.get<path_switch_request_fail_s>();
}
init_context_setup_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::init_context_setup_fail()
{
  assert_choice_type(types::init_context_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<init_context_setup_fail_s>();
}
s1_setup_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::s1_setup_fail()
{
  assert_choice_type(types::s1_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<s1_setup_fail_s>();
}
ue_context_mod_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ue_context_mod_fail()
{
  assert_choice_type(types::ue_context_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_mod_fail_s>();
}
enb_cfg_upd_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::enb_cfg_upd_fail()
{
  assert_choice_type(types::enb_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<enb_cfg_upd_fail_s>();
}
mme_cfg_upd_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::mme_cfg_upd_fail()
{
  assert_choice_type(types::mme_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<mme_cfg_upd_fail_s>();
}
const ho_prep_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ho_prep_fail() const
{
  assert_choice_type(types::ho_prep_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_prep_fail_s>();
}
const ho_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ho_fail() const
{
  assert_choice_type(types::ho_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_fail_s>();
}
const path_switch_request_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::path_switch_request_fail() const
{
  assert_choice_type(types::path_switch_request_fail, type_, "UnsuccessfulOutcome");
  return c.get<path_switch_request_fail_s>();
}
const init_context_setup_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::init_context_setup_fail() const
{
  assert_choice_type(types::init_context_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<init_context_setup_fail_s>();
}
const s1_setup_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::s1_setup_fail() const
{
  assert_choice_type(types::s1_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<s1_setup_fail_s>();
}
const ue_context_mod_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::ue_context_mod_fail() const
{
  assert_choice_type(types::ue_context_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_mod_fail_s>();
}
const enb_cfg_upd_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::enb_cfg_upd_fail() const
{
  assert_choice_type(types::enb_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<enb_cfg_upd_fail_s>();
}
const mme_cfg_upd_fail_s& s1ap_elem_procs_o::unsuccessful_outcome_c::mme_cfg_upd_fail() const
{
  assert_choice_type(types::mme_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<mme_cfg_upd_fail_s>();
}
void s1ap_elem_procs_o::unsuccessful_outcome_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_prep_fail:
      j.write_fieldname("HandoverPreparationFailure");
      c.get<ho_prep_fail_s>().to_json(j);
      break;
    case types::ho_fail:
      j.write_fieldname("HandoverFailure");
      c.get<ho_fail_s>().to_json(j);
      break;
    case types::path_switch_request_fail:
      j.write_fieldname("PathSwitchRequestFailure");
      c.get<path_switch_request_fail_s>().to_json(j);
      break;
    case types::init_context_setup_fail:
      j.write_fieldname("InitialContextSetupFailure");
      c.get<init_context_setup_fail_s>().to_json(j);
      break;
    case types::s1_setup_fail:
      j.write_fieldname("S1SetupFailure");
      c.get<s1_setup_fail_s>().to_json(j);
      break;
    case types::ue_context_mod_fail:
      j.write_fieldname("UEContextModificationFailure");
      c.get<ue_context_mod_fail_s>().to_json(j);
      break;
    case types::enb_cfg_upd_fail:
      j.write_fieldname("ENBConfigurationUpdateFailure");
      c.get<enb_cfg_upd_fail_s>().to_json(j);
      break;
    case types::mme_cfg_upd_fail:
      j.write_fieldname("MMEConfigurationUpdateFailure");
      c.get<mme_cfg_upd_fail_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
  }
  j.end_obj();
}
SRSASN_CODE s1ap_elem_procs_o::unsuccessful_outcome_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_prep_fail:
      HANDLE_CODE(c.get<ho_prep_fail_s>().pack(bref));
      break;
    case types::ho_fail:
      HANDLE_CODE(c.get<ho_fail_s>().pack(bref));
      break;
    case types::path_switch_request_fail:
      HANDLE_CODE(c.get<path_switch_request_fail_s>().pack(bref));
      break;
    case types::init_context_setup_fail:
      HANDLE_CODE(c.get<init_context_setup_fail_s>().pack(bref));
      break;
    case types::s1_setup_fail:
      HANDLE_CODE(c.get<s1_setup_fail_s>().pack(bref));
      break;
    case types::ue_context_mod_fail:
      HANDLE_CODE(c.get<ue_context_mod_fail_s>().pack(bref));
      break;
    case types::enb_cfg_upd_fail:
      HANDLE_CODE(c.get<enb_cfg_upd_fail_s>().pack(bref));
      break;
    case types::mme_cfg_upd_fail:
      HANDLE_CODE(c.get<mme_cfg_upd_fail_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_elem_procs_o::unsuccessful_outcome_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_prep_fail:
      HANDLE_CODE(c.get<ho_prep_fail_s>().unpack(bref));
      break;
    case types::ho_fail:
      HANDLE_CODE(c.get<ho_fail_s>().unpack(bref));
      break;
    case types::path_switch_request_fail:
      HANDLE_CODE(c.get<path_switch_request_fail_s>().unpack(bref));
      break;
    case types::init_context_setup_fail:
      HANDLE_CODE(c.get<init_context_setup_fail_s>().unpack(bref));
      break;
    case types::s1_setup_fail:
      HANDLE_CODE(c.get<s1_setup_fail_s>().unpack(bref));
      break;
    case types::ue_context_mod_fail:
      HANDLE_CODE(c.get<ue_context_mod_fail_s>().unpack(bref));
      break;
    case types::enb_cfg_upd_fail:
      HANDLE_CODE(c.get<enb_cfg_upd_fail_s>().unpack(bref));
      break;
    case types::mme_cfg_upd_fail:
      HANDLE_CODE(c.get<mme_cfg_upd_fail_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_elem_procs_o::unsuccessful_outcome_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1ap_elem_procs_o::unsuccessful_outcome_c::types_opts::to_string() const
{
  static const char* options[] = {"HandoverPreparationFailure",
                                  "HandoverFailure",
                                  "PathSwitchRequestFailure",
                                  "InitialContextSetupFailure",
                                  "S1SetupFailure",
                                  "UEContextModificationFailure",
                                  "ENBConfigurationUpdateFailure",
                                  "MMEConfigurationUpdateFailure"};
  return convert_enum_idx(options, 8, value, "s1ap_elem_procs_o::unsuccessful_outcome_c::types");
}
uint8_t s1ap_elem_procs_o::unsuccessful_outcome_c::types_opts::to_number() const
{
  if (value == s1_setup_fail) {
    return 1;
  }
  invalid_enum_number(value, "s1ap_elem_procs_o::unsuccessful_outcome_c::types");
  return 0;
}

// InitiatingMessage ::= SEQUENCE{{S1AP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE init_msg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != s1ap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_msg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = s1ap_elem_procs_o::get_init_msg(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void init_msg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool init_msg_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not s1ap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = s1ap_elem_procs_o::get_crit(proc_code);
  value     = s1ap_elem_procs_o::get_init_msg(proc_code);
  return value.type().value != s1ap_elem_procs_o::init_msg_c::types_opts::nulltype;
}

// LastVisitedEUTRANCellInformation-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t last_visited_eutran_cell_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {167, 168};
  return map_enum_number(options, 2, idx, "id");
}
bool last_visited_eutran_cell_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {167, 168};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e last_visited_eutran_cell_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 167:
      return crit_e::ignore;
    case 168:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
last_visited_eutran_cell_info_ext_ies_o::ext_c last_visited_eutran_cell_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 167:
      ret.set(ext_c::types::time_ue_stayed_in_cell_enhanced_granularity);
      break;
    case 168:
      ret.set(ext_c::types::ho_cause);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e last_visited_eutran_cell_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 167:
      return presence_e::optional;
    case 168:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void last_visited_eutran_cell_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ho_cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void last_visited_eutran_cell_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      break;
    case types::ho_cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
  }
}
last_visited_eutran_cell_info_ext_ies_o::ext_c::ext_c(const last_visited_eutran_cell_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ho_cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
  }
}
last_visited_eutran_cell_info_ext_ies_o::ext_c&
last_visited_eutran_cell_info_ext_ies_o::ext_c::operator=(const last_visited_eutran_cell_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ho_cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
  }

  return *this;
}
uint16_t& last_visited_eutran_cell_info_ext_ies_o::ext_c::time_ue_stayed_in_cell_enhanced_granularity()
{
  assert_choice_type(types::time_ue_stayed_in_cell_enhanced_granularity, type_, "Extension");
  return c.get<uint16_t>();
}
cause_c& last_visited_eutran_cell_info_ext_ies_o::ext_c::ho_cause()
{
  assert_choice_type(types::ho_cause, type_, "Extension");
  return c.get<cause_c>();
}
const uint16_t& last_visited_eutran_cell_info_ext_ies_o::ext_c::time_ue_stayed_in_cell_enhanced_granularity() const
{
  assert_choice_type(types::time_ue_stayed_in_cell_enhanced_granularity, type_, "Extension");
  return c.get<uint16_t>();
}
const cause_c& last_visited_eutran_cell_info_ext_ies_o::ext_c::ho_cause() const
{
  assert_choice_type(types::ho_cause, type_, "Extension");
  return c.get<cause_c>();
}
void last_visited_eutran_cell_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      j.write_int("INTEGER (0..40950)", c.get<uint16_t>());
      break;
    case types::ho_cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE last_visited_eutran_cell_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)40950u, false, true));
      break;
    case types::ho_cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_eutran_cell_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::time_ue_stayed_in_cell_enhanced_granularity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)40950u, false, true));
      break;
    case types::ho_cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_eutran_cell_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_eutran_cell_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {"INTEGER (0..40950)", "Cause"};
  return convert_enum_idx(options, 2, value, "last_visited_eutran_cell_info_ext_ies_o::ext_c::types");
}
uint8_t last_visited_eutran_cell_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t options[] = {0};
  return map_enum_number(options, 1, value, "last_visited_eutran_cell_info_ext_ies_o::ext_c::types");
}

template struct asn1::s1ap::protocol_ext_field_s<last_visited_eutran_cell_info_ext_ies_o>;

last_visited_eutran_cell_info_ext_ies_container::last_visited_eutran_cell_info_ext_ies_container() :
  time_ue_stayed_in_cell_enhanced_granularity(167, crit_e::ignore), ho_cause(168, crit_e::ignore)
{}
SRSASN_CODE last_visited_eutran_cell_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += time_ue_stayed_in_cell_enhanced_granularity_present ? 1 : 0;
  nof_ies += ho_cause_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    HANDLE_CODE(time_ue_stayed_in_cell_enhanced_granularity.pack(bref));
  }
  if (ho_cause_present) {
    HANDLE_CODE(ho_cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_eutran_cell_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<last_visited_eutran_cell_info_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 167:
        time_ue_stayed_in_cell_enhanced_granularity_present = true;
        time_ue_stayed_in_cell_enhanced_granularity.id      = c.id;
        time_ue_stayed_in_cell_enhanced_granularity.crit    = c.crit;
        time_ue_stayed_in_cell_enhanced_granularity.ext     = c.ext_value.time_ue_stayed_in_cell_enhanced_granularity();
        break;
      case 168:
        ho_cause_present = true;
        ho_cause.id      = c.id;
        ho_cause.crit    = c.crit;
        ho_cause.ext     = c.ext_value.ho_cause();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void last_visited_eutran_cell_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    j.write_fieldname("");
    time_ue_stayed_in_cell_enhanced_granularity.to_json(j);
  }
  if (ho_cause_present) {
    j.write_fieldname("");
    ho_cause.to_json(j);
  }
  j.end_obj();
}

// LastVisitedEUTRANCellInformation ::= SEQUENCE
SRSASN_CODE last_visited_eutran_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.pack(bref));
  HANDLE_CODE(cell_type.pack(bref));
  HANDLE_CODE(pack_integer(bref, time_ue_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_eutran_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.unpack(bref));
  HANDLE_CODE(cell_type.unpack(bref));
  HANDLE_CODE(unpack_integer(time_ue_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_eutran_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("global-Cell-ID");
  global_cell_id.to_json(j);
  j.write_fieldname("cellType");
  cell_type.to_json(j);
  j.write_int("time-UE-StayedInCell", time_ue_stayed_in_cell);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LastVisitedGERANCellInformation ::= CHOICE
void last_visited_geran_cell_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}
SRSASN_CODE last_visited_geran_cell_info_c::pack(bit_ref& bref) const
{
  pack_enum(bref, type());
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_geran_cell_info_c::unpack(cbit_ref& bref)
{
  types e;
  unpack_enum(e, bref);
  if (e != type()) {
    log_invalid_choice_id(e, "last_visited_geran_cell_info_c");
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_geran_cell_info_c::types_opts::to_string() const
{
  static const char* options[] = {"undefined"};
  return convert_enum_idx(options, 1, value, "last_visited_geran_cell_info_c::types");
}

// LastVisitedCell-Item ::= CHOICE
void last_visited_cell_item_c::destroy_()
{
  switch (type_) {
    case types::e_utran_cell:
      c.destroy<last_visited_eutran_cell_info_s>();
      break;
    case types::utran_cell:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::geran_cell:
      c.destroy<last_visited_geran_cell_info_c>();
      break;
    case types::ng_ran_cell:
      c.destroy<unbounded_octstring<true> >();
      break;
    default:
      break;
  }
}
void last_visited_cell_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::e_utran_cell:
      c.init<last_visited_eutran_cell_info_s>();
      break;
    case types::utran_cell:
      c.init<unbounded_octstring<true> >();
      break;
    case types::geran_cell:
      c.init<last_visited_geran_cell_info_c>();
      break;
    case types::ng_ran_cell:
      c.init<unbounded_octstring<true> >();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
}
last_visited_cell_item_c::last_visited_cell_item_c(const last_visited_cell_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::e_utran_cell:
      c.init(other.c.get<last_visited_eutran_cell_info_s>());
      break;
    case types::utran_cell:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran_cell:
      c.init(other.c.get<last_visited_geran_cell_info_c>());
      break;
    case types::ng_ran_cell:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
}
last_visited_cell_item_c& last_visited_cell_item_c::operator=(const last_visited_cell_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::e_utran_cell:
      c.set(other.c.get<last_visited_eutran_cell_info_s>());
      break;
    case types::utran_cell:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran_cell:
      c.set(other.c.get<last_visited_geran_cell_info_c>());
      break;
    case types::ng_ran_cell:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }

  return *this;
}
last_visited_eutran_cell_info_s& last_visited_cell_item_c::set_e_utran_cell()
{
  set(types::e_utran_cell);
  return c.get<last_visited_eutran_cell_info_s>();
}
unbounded_octstring<true>& last_visited_cell_item_c::set_utran_cell()
{
  set(types::utran_cell);
  return c.get<unbounded_octstring<true> >();
}
last_visited_geran_cell_info_c& last_visited_cell_item_c::set_geran_cell()
{
  set(types::geran_cell);
  return c.get<last_visited_geran_cell_info_c>();
}
unbounded_octstring<true>& last_visited_cell_item_c::set_ng_ran_cell()
{
  set(types::ng_ran_cell);
  return c.get<unbounded_octstring<true> >();
}
void last_visited_cell_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::e_utran_cell:
      j.write_fieldname("e-UTRAN-Cell");
      c.get<last_visited_eutran_cell_info_s>().to_json(j);
      break;
    case types::utran_cell:
      j.write_str("uTRAN-Cell", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::geran_cell:
      j.write_fieldname("gERAN-Cell");
      c.get<last_visited_geran_cell_info_c>().to_json(j);
      break;
    case types::ng_ran_cell:
      j.write_str("nG-RAN-Cell", c.get<unbounded_octstring<true> >().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
  }
  j.end_obj();
}
SRSASN_CODE last_visited_cell_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::e_utran_cell:
      HANDLE_CODE(c.get<last_visited_eutran_cell_info_s>().pack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<last_visited_geran_cell_info_c>().pack(bref));
      break;
    case types::ng_ran_cell: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::e_utran_cell:
      HANDLE_CODE(c.get<last_visited_eutran_cell_info_s>().unpack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<last_visited_geran_cell_info_c>().unpack(bref));
      break;
    case types::ng_ran_cell: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_cell_item_c::types_opts::to_string() const
{
  static const char* options[] = {"e-UTRAN-Cell", "uTRAN-Cell", "gERAN-Cell", "nG-RAN-Cell"};
  return convert_enum_idx(options, 4, value, "last_visited_cell_item_c::types");
}

// MultiCellLoadReportingRequest ::= SEQUENCE
SRSASN_CODE multi_cell_load_report_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_dyn_seq_of(bref, requested_cell_list, 1, 128, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multi_cell_load_report_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_dyn_seq_of(requested_cell_list, bref, 1, 128, true));

  return SRSASN_SUCCESS;
}
void multi_cell_load_report_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("requestedCellList");
  for (const auto& e1 : requested_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

// MultiCellLoadReportingResponse-Item ::= CHOICE
void multi_cell_load_report_resp_item_c::destroy_()
{
  switch (type_) {
    case types::eutran_resp:
      c.destroy<eutran_resp_s>();
      break;
    case types::utran_resp:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::geran_resp:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.destroy<ehrpd_multi_sector_load_report_resp_item_s>();
      break;
    default:
      break;
  }
}
void multi_cell_load_report_resp_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran_resp:
      c.init<eutran_resp_s>();
      break;
    case types::utran_resp:
      c.init<unbounded_octstring<true> >();
      break;
    case types::geran_resp:
      c.init<unbounded_octstring<true> >();
      break;
    case types::ehrpd:
      c.init<ehrpd_multi_sector_load_report_resp_item_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
  }
}
multi_cell_load_report_resp_item_c::multi_cell_load_report_resp_item_c(const multi_cell_load_report_resp_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran_resp:
      c.init(other.c.get<eutran_resp_s>());
      break;
    case types::utran_resp:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran_resp:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.init(other.c.get<ehrpd_multi_sector_load_report_resp_item_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
  }
}
multi_cell_load_report_resp_item_c&
multi_cell_load_report_resp_item_c::operator=(const multi_cell_load_report_resp_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran_resp:
      c.set(other.c.get<eutran_resp_s>());
      break;
    case types::utran_resp:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::geran_resp:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::ehrpd:
      c.set(other.c.get<ehrpd_multi_sector_load_report_resp_item_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
  }

  return *this;
}
eutran_resp_s& multi_cell_load_report_resp_item_c::set_eutran_resp()
{
  set(types::eutran_resp);
  return c.get<eutran_resp_s>();
}
unbounded_octstring<true>& multi_cell_load_report_resp_item_c::set_utran_resp()
{
  set(types::utran_resp);
  return c.get<unbounded_octstring<true> >();
}
unbounded_octstring<true>& multi_cell_load_report_resp_item_c::set_geran_resp()
{
  set(types::geran_resp);
  return c.get<unbounded_octstring<true> >();
}
ehrpd_multi_sector_load_report_resp_item_s& multi_cell_load_report_resp_item_c::set_ehrpd()
{
  set(types::ehrpd);
  return c.get<ehrpd_multi_sector_load_report_resp_item_s>();
}
void multi_cell_load_report_resp_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran_resp:
      j.write_fieldname("eUTRANResponse");
      c.get<eutran_resp_s>().to_json(j);
      break;
    case types::utran_resp:
      j.write_str("uTRANResponse", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::geran_resp:
      j.write_str("gERANResponse", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::ehrpd:
      j.write_fieldname("eHRPD");
      c.get<ehrpd_multi_sector_load_report_resp_item_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
  }
  j.end_obj();
}
SRSASN_CODE multi_cell_load_report_resp_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran_resp:
      HANDLE_CODE(c.get<eutran_resp_s>().pack(bref));
      break;
    case types::utran_resp:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::geran_resp:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::ehrpd: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ehrpd_multi_sector_load_report_resp_item_s>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multi_cell_load_report_resp_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran_resp:
      HANDLE_CODE(c.get<eutran_resp_s>().unpack(bref));
      break;
    case types::utran_resp:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::geran_resp:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::ehrpd: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ehrpd_multi_sector_load_report_resp_item_s>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "multi_cell_load_report_resp_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multi_cell_load_report_resp_item_c::types_opts::to_string() const
{
  static const char* options[] = {"eUTRANResponse", "uTRANResponse", "gERANResponse", "eHRPD"};
  return convert_enum_idx(options, 4, value, "multi_cell_load_report_resp_item_c::types");
}

// ReportingCellList-Item ::= SEQUENCE
SRSASN_CODE report_cell_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(cell_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE report_cell_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(cell_id.unpack(bref));

  return SRSASN_SUCCESS;
}
void report_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cell-ID");
  cell_id.to_json(j);
  j.end_obj();
}

// SuccessfulOutcome ::= SEQUENCE{{S1AP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE successful_outcome_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != s1ap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_outcome_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = s1ap_elem_procs_o::get_successful_outcome(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void successful_outcome_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool successful_outcome_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not s1ap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = s1ap_elem_procs_o::get_crit(proc_code);
  value     = s1ap_elem_procs_o::get_successful_outcome(proc_code);
  return value.type().value != s1ap_elem_procs_o::successful_outcome_c::types_opts::nulltype;
}

// UnsuccessfulOutcome ::= SEQUENCE{{S1AP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE unsuccessful_outcome_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != s1ap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE unsuccessful_outcome_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = s1ap_elem_procs_o::get_unsuccessful_outcome(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void unsuccessful_outcome_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool unsuccessful_outcome_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not s1ap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = s1ap_elem_procs_o::get_crit(proc_code);
  value     = s1ap_elem_procs_o::get_unsuccessful_outcome(proc_code);
  return value.type().value != s1ap_elem_procs_o::unsuccessful_outcome_c::types_opts::nulltype;
}

// S1AP-PDU ::= CHOICE
void s1ap_pdu_c::destroy_()
{
  switch (type_) {
    case types::init_msg:
      c.destroy<init_msg_s>();
      break;
    case types::successful_outcome:
      c.destroy<successful_outcome_s>();
      break;
    case types::unsuccessful_outcome:
      c.destroy<unsuccessful_outcome_s>();
      break;
    default:
      break;
  }
}
void s1ap_pdu_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::init_msg:
      c.init<init_msg_s>();
      break;
    case types::successful_outcome:
      c.init<successful_outcome_s>();
      break;
    case types::unsuccessful_outcome:
      c.init<unsuccessful_outcome_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
  }
}
s1ap_pdu_c::s1ap_pdu_c(const s1ap_pdu_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::init_msg:
      c.init(other.c.get<init_msg_s>());
      break;
    case types::successful_outcome:
      c.init(other.c.get<successful_outcome_s>());
      break;
    case types::unsuccessful_outcome:
      c.init(other.c.get<unsuccessful_outcome_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
  }
}
s1ap_pdu_c& s1ap_pdu_c::operator=(const s1ap_pdu_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::init_msg:
      c.set(other.c.get<init_msg_s>());
      break;
    case types::successful_outcome:
      c.set(other.c.get<successful_outcome_s>());
      break;
    case types::unsuccessful_outcome:
      c.set(other.c.get<unsuccessful_outcome_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
  }

  return *this;
}
init_msg_s& s1ap_pdu_c::set_init_msg()
{
  set(types::init_msg);
  return c.get<init_msg_s>();
}
successful_outcome_s& s1ap_pdu_c::set_successful_outcome()
{
  set(types::successful_outcome);
  return c.get<successful_outcome_s>();
}
unsuccessful_outcome_s& s1ap_pdu_c::set_unsuccessful_outcome()
{
  set(types::unsuccessful_outcome);
  return c.get<unsuccessful_outcome_s>();
}
void s1ap_pdu_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::init_msg:
      j.write_fieldname("initiatingMessage");
      c.get<init_msg_s>().to_json(j);
      break;
    case types::successful_outcome:
      j.write_fieldname("successfulOutcome");
      c.get<successful_outcome_s>().to_json(j);
      break;
    case types::unsuccessful_outcome:
      j.write_fieldname("unsuccessfulOutcome");
      c.get<unsuccessful_outcome_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
  }
  j.end_obj();
}
SRSASN_CODE s1ap_pdu_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::init_msg:
      HANDLE_CODE(c.get<init_msg_s>().pack(bref));
      break;
    case types::successful_outcome:
      HANDLE_CODE(c.get<successful_outcome_s>().pack(bref));
      break;
    case types::unsuccessful_outcome:
      HANDLE_CODE(c.get<unsuccessful_outcome_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE s1ap_pdu_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::init_msg:
      HANDLE_CODE(c.get<init_msg_s>().unpack(bref));
      break;
    case types::successful_outcome:
      HANDLE_CODE(c.get<successful_outcome_s>().unpack(bref));
      break;
    case types::unsuccessful_outcome:
      HANDLE_CODE(c.get<unsuccessful_outcome_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "s1ap_pdu_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* s1ap_pdu_c::types_opts::to_string() const
{
  static const char* options[] = {"initiatingMessage", "successfulOutcome", "unsuccessfulOutcome"};
  return convert_enum_idx(options, 3, value, "s1ap_pdu_c::types");
}

// CellActivationCause ::= ENUMERATED
const char* cell_activation_cause_opts::to_string() const
{
  static const char* options[] = {
      "application-container-syntax-error", "inconsistent-reporting-cell-identifier", "unspecified"};
  return convert_enum_idx(options, 3, value, "cell_activation_cause_e");
}

// CellLoadReportingCause ::= ENUMERATED
const char* cell_load_report_cause_opts::to_string() const
{
  static const char* options[] = {
      "application-container-syntax-error", "inconsistent-reporting-cell-identifier", "unspecified"};
  return convert_enum_idx(options, 3, value, "cell_load_report_cause_e");
}

// CellStateIndicationCause ::= ENUMERATED
const char* cell_state_ind_cause_opts::to_string() const
{
  static const char* options[] = {
      "application-container-syntax-error", "inconsistent-reporting-cell-identifier", "unspecified"};
  return convert_enum_idx(options, 3, value, "cell_state_ind_cause_e");
}

// FailureEventReportingCause ::= ENUMERATED
const char* fail_event_report_cause_opts::to_string() const
{
  static const char* options[] = {
      "application-container-syntax-error", "inconsistent-reporting-cell-identifier", "unspecified"};
  return convert_enum_idx(options, 3, value, "fail_event_report_cause_e");
}

// HOReportingCause ::= ENUMERATED
const char* ho_report_cause_opts::to_string() const
{
  static const char* options[] = {
      "application-container-syntax-error", "inconsistent-reporting-cell-identifier", "unspecified"};
  return convert_enum_idx(options, 3, value, "ho_report_cause_e");
}

// SONtransferCause ::= CHOICE
void so_ntransfer_cause_c::destroy_() {}
void so_ntransfer_cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
so_ntransfer_cause_c::so_ntransfer_cause_c(const so_ntransfer_cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_load_report:
      c.init(other.c.get<cell_load_report_cause_e>());
      break;
    case types::multi_cell_load_report:
      c.init(other.c.get<cell_load_report_cause_e>());
      break;
    case types::event_triggered_cell_load_report:
      c.init(other.c.get<cell_load_report_cause_e>());
      break;
    case types::horeport:
      c.init(other.c.get<ho_report_cause_e>());
      break;
    case types::eutran_cell_activation:
      c.init(other.c.get<cell_activation_cause_e>());
      break;
    case types::energy_savings_ind:
      c.init(other.c.get<cell_state_ind_cause_e>());
      break;
    case types::fail_event_report:
      c.init(other.c.get<fail_event_report_cause_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_cause_c");
  }
}
so_ntransfer_cause_c& so_ntransfer_cause_c::operator=(const so_ntransfer_cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_load_report:
      c.set(other.c.get<cell_load_report_cause_e>());
      break;
    case types::multi_cell_load_report:
      c.set(other.c.get<cell_load_report_cause_e>());
      break;
    case types::event_triggered_cell_load_report:
      c.set(other.c.get<cell_load_report_cause_e>());
      break;
    case types::horeport:
      c.set(other.c.get<ho_report_cause_e>());
      break;
    case types::eutran_cell_activation:
      c.set(other.c.get<cell_activation_cause_e>());
      break;
    case types::energy_savings_ind:
      c.set(other.c.get<cell_state_ind_cause_e>());
      break;
    case types::fail_event_report:
      c.set(other.c.get<fail_event_report_cause_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_cause_c");
  }

  return *this;
}
cell_load_report_cause_e& so_ntransfer_cause_c::set_cell_load_report()
{
  set(types::cell_load_report);
  return c.get<cell_load_report_cause_e>();
}
cell_load_report_cause_e& so_ntransfer_cause_c::set_multi_cell_load_report()
{
  set(types::multi_cell_load_report);
  return c.get<cell_load_report_cause_e>();
}
cell_load_report_cause_e& so_ntransfer_cause_c::set_event_triggered_cell_load_report()
{
  set(types::event_triggered_cell_load_report);
  return c.get<cell_load_report_cause_e>();
}
ho_report_cause_e& so_ntransfer_cause_c::set_horeport()
{
  set(types::horeport);
  return c.get<ho_report_cause_e>();
}
cell_activation_cause_e& so_ntransfer_cause_c::set_eutran_cell_activation()
{
  set(types::eutran_cell_activation);
  return c.get<cell_activation_cause_e>();
}
cell_state_ind_cause_e& so_ntransfer_cause_c::set_energy_savings_ind()
{
  set(types::energy_savings_ind);
  return c.get<cell_state_ind_cause_e>();
}
fail_event_report_cause_e& so_ntransfer_cause_c::set_fail_event_report()
{
  set(types::fail_event_report);
  return c.get<fail_event_report_cause_e>();
}
void so_ntransfer_cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_load_report:
      j.write_str("cellLoadReporting", c.get<cell_load_report_cause_e>().to_string());
      break;
    case types::multi_cell_load_report:
      j.write_str("multiCellLoadReporting", c.get<cell_load_report_cause_e>().to_string());
      break;
    case types::event_triggered_cell_load_report:
      j.write_str("eventTriggeredCellLoadReporting", c.get<cell_load_report_cause_e>().to_string());
      break;
    case types::horeport:
      j.write_str("hOReporting", c.get<ho_report_cause_e>().to_string());
      break;
    case types::eutran_cell_activation:
      j.write_str("eutranCellActivation", c.get<cell_activation_cause_e>().to_string());
      break;
    case types::energy_savings_ind:
      j.write_str("energySavingsIndication", c.get<cell_state_ind_cause_e>().to_string());
      break;
    case types::fail_event_report:
      j.write_str("failureEventReporting", c.get<fail_event_report_cause_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_cause_c");
  }
  j.end_obj();
}
SRSASN_CODE so_ntransfer_cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_load_report:
      HANDLE_CODE(c.get<cell_load_report_cause_e>().pack(bref));
      break;
    case types::multi_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_load_report_cause_e>().pack(bref));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_load_report_cause_e>().pack(bref));
    } break;
    case types::horeport: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ho_report_cause_e>().pack(bref));
    } break;
    case types::eutran_cell_activation: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_cause_e>().pack(bref));
    } break;
    case types::energy_savings_ind: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_state_ind_cause_e>().pack(bref));
    } break;
    case types::fail_event_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<fail_event_report_cause_e>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE so_ntransfer_cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_load_report:
      HANDLE_CODE(c.get<cell_load_report_cause_e>().unpack(bref));
      break;
    case types::multi_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_load_report_cause_e>().unpack(bref));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_load_report_cause_e>().unpack(bref));
    } break;
    case types::horeport: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ho_report_cause_e>().unpack(bref));
    } break;
    case types::eutran_cell_activation: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_cause_e>().unpack(bref));
    } break;
    case types::energy_savings_ind: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_state_ind_cause_e>().unpack(bref));
    } break;
    case types::fail_event_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<fail_event_report_cause_e>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* so_ntransfer_cause_c::types_opts::to_string() const
{
  static const char* options[] = {"cellLoadReporting",
                                  "multiCellLoadReporting",
                                  "eventTriggeredCellLoadReporting",
                                  "hOReporting",
                                  "eutranCellActivation",
                                  "energySavingsIndication",
                                  "failureEventReporting"};
  return convert_enum_idx(options, 7, value, "so_ntransfer_cause_c::types");
}

// SONtransferRequestContainer ::= CHOICE
void so_ntransfer_request_container_c::destroy_()
{
  switch (type_) {
    case types::multi_cell_load_report:
      c.destroy<multi_cell_load_report_request_s>();
      break;
    case types::event_triggered_cell_load_report:
      c.destroy<event_triggered_cell_load_report_request_s>();
      break;
    case types::horeport:
      c.destroy<ho_report_s>();
      break;
    case types::eutran_cell_activation:
      c.destroy<cell_activation_request_s>();
      break;
    case types::energy_savings_ind:
      c.destroy<cell_state_ind_s>();
      break;
    case types::fail_event_report:
      c.destroy<fail_event_report_c>();
      break;
    default:
      break;
  }
}
void so_ntransfer_request_container_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report:
      c.init<multi_cell_load_report_request_s>();
      break;
    case types::event_triggered_cell_load_report:
      c.init<event_triggered_cell_load_report_request_s>();
      break;
    case types::horeport:
      c.init<ho_report_s>();
      break;
    case types::eutran_cell_activation:
      c.init<cell_activation_request_s>();
      break;
    case types::energy_savings_ind:
      c.init<cell_state_ind_s>();
      break;
    case types::fail_event_report:
      c.init<fail_event_report_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
  }
}
so_ntransfer_request_container_c::so_ntransfer_request_container_c(const so_ntransfer_request_container_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report:
      c.init(other.c.get<multi_cell_load_report_request_s>());
      break;
    case types::event_triggered_cell_load_report:
      c.init(other.c.get<event_triggered_cell_load_report_request_s>());
      break;
    case types::horeport:
      c.init(other.c.get<ho_report_s>());
      break;
    case types::eutran_cell_activation:
      c.init(other.c.get<cell_activation_request_s>());
      break;
    case types::energy_savings_ind:
      c.init(other.c.get<cell_state_ind_s>());
      break;
    case types::fail_event_report:
      c.init(other.c.get<fail_event_report_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
  }
}
so_ntransfer_request_container_c&
so_ntransfer_request_container_c::operator=(const so_ntransfer_request_container_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report:
      c.set(other.c.get<multi_cell_load_report_request_s>());
      break;
    case types::event_triggered_cell_load_report:
      c.set(other.c.get<event_triggered_cell_load_report_request_s>());
      break;
    case types::horeport:
      c.set(other.c.get<ho_report_s>());
      break;
    case types::eutran_cell_activation:
      c.set(other.c.get<cell_activation_request_s>());
      break;
    case types::energy_savings_ind:
      c.set(other.c.get<cell_state_ind_s>());
      break;
    case types::fail_event_report:
      c.set(other.c.get<fail_event_report_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
  }

  return *this;
}
void so_ntransfer_request_container_c::set_cell_load_report()
{
  set(types::cell_load_report);
}
multi_cell_load_report_request_s& so_ntransfer_request_container_c::set_multi_cell_load_report()
{
  set(types::multi_cell_load_report);
  return c.get<multi_cell_load_report_request_s>();
}
event_triggered_cell_load_report_request_s& so_ntransfer_request_container_c::set_event_triggered_cell_load_report()
{
  set(types::event_triggered_cell_load_report);
  return c.get<event_triggered_cell_load_report_request_s>();
}
ho_report_s& so_ntransfer_request_container_c::set_horeport()
{
  set(types::horeport);
  return c.get<ho_report_s>();
}
cell_activation_request_s& so_ntransfer_request_container_c::set_eutran_cell_activation()
{
  set(types::eutran_cell_activation);
  return c.get<cell_activation_request_s>();
}
cell_state_ind_s& so_ntransfer_request_container_c::set_energy_savings_ind()
{
  set(types::energy_savings_ind);
  return c.get<cell_state_ind_s>();
}
fail_event_report_c& so_ntransfer_request_container_c::set_fail_event_report()
{
  set(types::fail_event_report);
  return c.get<fail_event_report_c>();
}
void so_ntransfer_request_container_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report:
      j.write_fieldname("multiCellLoadReporting");
      c.get<multi_cell_load_report_request_s>().to_json(j);
      break;
    case types::event_triggered_cell_load_report:
      j.write_fieldname("eventTriggeredCellLoadReporting");
      c.get<event_triggered_cell_load_report_request_s>().to_json(j);
      break;
    case types::horeport:
      j.write_fieldname("hOReporting");
      c.get<ho_report_s>().to_json(j);
      break;
    case types::eutran_cell_activation:
      j.write_fieldname("eutranCellActivation");
      c.get<cell_activation_request_s>().to_json(j);
      break;
    case types::energy_savings_ind:
      j.write_fieldname("energySavingsIndication");
      c.get<cell_state_ind_s>().to_json(j);
      break;
    case types::fail_event_report:
      j.write_fieldname("failureEventReporting");
      c.get<fail_event_report_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
  }
  j.end_obj();
}
SRSASN_CODE so_ntransfer_request_container_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<multi_cell_load_report_request_s>().pack(bref));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<event_triggered_cell_load_report_request_s>().pack(bref));
    } break;
    case types::horeport: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ho_report_s>().pack(bref));
    } break;
    case types::eutran_cell_activation: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_request_s>().pack(bref));
    } break;
    case types::energy_savings_ind: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_state_ind_s>().pack(bref));
    } break;
    case types::fail_event_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<fail_event_report_c>().pack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE so_ntransfer_request_container_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_load_report:
      break;
    case types::multi_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<multi_cell_load_report_request_s>().unpack(bref));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<event_triggered_cell_load_report_request_s>().unpack(bref));
    } break;
    case types::horeport: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<ho_report_s>().unpack(bref));
    } break;
    case types::eutran_cell_activation: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_request_s>().unpack(bref));
    } break;
    case types::energy_savings_ind: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_state_ind_s>().unpack(bref));
    } break;
    case types::fail_event_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<fail_event_report_c>().unpack(bref));
    } break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_request_container_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* so_ntransfer_request_container_c::types_opts::to_string() const
{
  static const char* options[] = {"cellLoadReporting",
                                  "multiCellLoadReporting",
                                  "eventTriggeredCellLoadReporting",
                                  "hOReporting",
                                  "eutranCellActivation",
                                  "energySavingsIndication",
                                  "failureEventReporting"};
  return convert_enum_idx(options, 7, value, "so_ntransfer_request_container_c::types");
}

// SONtransferResponseContainer ::= CHOICE
void so_ntransfer_resp_container_c::destroy_()
{
  switch (type_) {
    case types::cell_load_report:
      c.destroy<cell_load_report_resp_c>();
      break;
    case types::multi_cell_load_report:
      c.destroy<multi_cell_load_report_resp_l>();
      break;
    case types::event_triggered_cell_load_report:
      c.destroy<event_triggered_cell_load_report_resp_s>();
      break;
    case types::eutran_cell_activation:
      c.destroy<cell_activation_resp_s>();
      break;
    default:
      break;
  }
}
void so_ntransfer_resp_container_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_load_report:
      c.init<cell_load_report_resp_c>();
      break;
    case types::multi_cell_load_report:
      c.init<multi_cell_load_report_resp_l>();
      break;
    case types::event_triggered_cell_load_report:
      c.init<event_triggered_cell_load_report_resp_s>();
      break;
    case types::horeport:
      break;
    case types::eutran_cell_activation:
      c.init<cell_activation_resp_s>();
      break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
  }
}
so_ntransfer_resp_container_c::so_ntransfer_resp_container_c(const so_ntransfer_resp_container_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_load_report:
      c.init(other.c.get<cell_load_report_resp_c>());
      break;
    case types::multi_cell_load_report:
      c.init(other.c.get<multi_cell_load_report_resp_l>());
      break;
    case types::event_triggered_cell_load_report:
      c.init(other.c.get<event_triggered_cell_load_report_resp_s>());
      break;
    case types::horeport:
      break;
    case types::eutran_cell_activation:
      c.init(other.c.get<cell_activation_resp_s>());
      break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
  }
}
so_ntransfer_resp_container_c& so_ntransfer_resp_container_c::operator=(const so_ntransfer_resp_container_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_load_report:
      c.set(other.c.get<cell_load_report_resp_c>());
      break;
    case types::multi_cell_load_report:
      c.set(other.c.get<multi_cell_load_report_resp_l>());
      break;
    case types::event_triggered_cell_load_report:
      c.set(other.c.get<event_triggered_cell_load_report_resp_s>());
      break;
    case types::horeport:
      break;
    case types::eutran_cell_activation:
      c.set(other.c.get<cell_activation_resp_s>());
      break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
  }

  return *this;
}
cell_load_report_resp_c& so_ntransfer_resp_container_c::set_cell_load_report()
{
  set(types::cell_load_report);
  return c.get<cell_load_report_resp_c>();
}
multi_cell_load_report_resp_l& so_ntransfer_resp_container_c::set_multi_cell_load_report()
{
  set(types::multi_cell_load_report);
  return c.get<multi_cell_load_report_resp_l>();
}
event_triggered_cell_load_report_resp_s& so_ntransfer_resp_container_c::set_event_triggered_cell_load_report()
{
  set(types::event_triggered_cell_load_report);
  return c.get<event_triggered_cell_load_report_resp_s>();
}
void so_ntransfer_resp_container_c::set_horeport()
{
  set(types::horeport);
}
cell_activation_resp_s& so_ntransfer_resp_container_c::set_eutran_cell_activation()
{
  set(types::eutran_cell_activation);
  return c.get<cell_activation_resp_s>();
}
void so_ntransfer_resp_container_c::set_energy_savings_ind()
{
  set(types::energy_savings_ind);
}
void so_ntransfer_resp_container_c::set_fail_event_report()
{
  set(types::fail_event_report);
}
void so_ntransfer_resp_container_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_load_report:
      j.write_fieldname("cellLoadReporting");
      c.get<cell_load_report_resp_c>().to_json(j);
      break;
    case types::multi_cell_load_report:
      j.start_array("multiCellLoadReporting");
      for (const auto& e1 : c.get<multi_cell_load_report_resp_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::event_triggered_cell_load_report:
      j.write_fieldname("eventTriggeredCellLoadReporting");
      c.get<event_triggered_cell_load_report_resp_s>().to_json(j);
      break;
    case types::horeport:
      break;
    case types::eutran_cell_activation:
      j.write_fieldname("eutranCellActivation");
      c.get<cell_activation_resp_s>().to_json(j);
      break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
  }
  j.end_obj();
}
SRSASN_CODE so_ntransfer_resp_container_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_load_report:
      HANDLE_CODE(c.get<cell_load_report_resp_c>().pack(bref));
      break;
    case types::multi_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<multi_cell_load_report_resp_l>(), 1, 128, true));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<event_triggered_cell_load_report_resp_s>().pack(bref));
    } break;
    case types::horeport:
      break;
    case types::eutran_cell_activation: {
      varlength_field_pack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_resp_s>().pack(bref));
    } break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE so_ntransfer_resp_container_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_load_report:
      HANDLE_CODE(c.get<cell_load_report_resp_c>().unpack(bref));
      break;
    case types::multi_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(unpack_dyn_seq_of(c.get<multi_cell_load_report_resp_l>(), bref, 1, 128, true));
    } break;
    case types::event_triggered_cell_load_report: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<event_triggered_cell_load_report_resp_s>().unpack(bref));
    } break;
    case types::horeport:
      break;
    case types::eutran_cell_activation: {
      varlength_field_unpack_guard varlen_scope(bref, true);
      HANDLE_CODE(c.get<cell_activation_resp_s>().unpack(bref));
    } break;
    case types::energy_savings_ind:
      break;
    case types::fail_event_report:
      break;
    default:
      log_invalid_choice_id(type_, "so_ntransfer_resp_container_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* so_ntransfer_resp_container_c::types_opts::to_string() const
{
  static const char* options[] = {"cellLoadReporting",
                                  "multiCellLoadReporting",
                                  "eventTriggeredCellLoadReporting",
                                  "hOReporting",
                                  "eutranCellActivation",
                                  "energySavingsIndication",
                                  "failureEventReporting"};
  return convert_enum_idx(options, 7, value, "so_ntransfer_resp_container_c::types");
}

// IMSvoiceEPSfallbackfrom5G ::= ENUMERATED
const char* im_svoice_ep_sfallbackfrom5_g_opts::to_string() const
{
  static const char* options[] = {"true"};
  return convert_enum_idx(options, 1, value, "im_svoice_ep_sfallbackfrom5_g_e");
}

// SourceeNB-ToTargeteNB-TransparentContainer-ExtIEs ::= OBJECT SET OF S1AP-PROTOCOL-EXTENSION
uint32_t sourceenb_to_targetenb_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t options[] = {175, 194, 296, 299, 300};
  return map_enum_number(options, 5, idx, "id");
}
bool sourceenb_to_targetenb_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t options[] = {175, 194, 296, 299, 300};
  for (const auto& o : options) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e sourceenb_to_targetenb_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 175:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    case 296:
      return crit_e::ignore;
    case 299:
      return crit_e::ignore;
    case 300:
      return crit_e::ignore;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c
sourceenb_to_targetenb_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 175:
      ret.set(ext_c::types::mob_info);
      break;
    case 194:
      ret.set(ext_c::types::ue_history_info_from_the_ue);
      break;
    case 296:
      ret.set(ext_c::types::im_svoice_ep_sfallbackfrom5_g);
      break;
    case 299:
      ret.set(ext_c::types::add_rrm_prio_idx);
      break;
    case 300:
      ret.set(ext_c::types::contextat_source);
      break;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return ret;
}
presence_e sourceenb_to_targetenb_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 175:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    case 296:
      return presence_e::optional;
    case 299:
      return presence_e::optional;
    case 300:
      return presence_e::optional;
    default:
      asn1::log_error("The id=%d is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::mob_info:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    case types::ue_history_info_from_the_ue:
      c.destroy<unbounded_octstring<true> >();
      break;
    case types::add_rrm_prio_idx:
      c.destroy<fixed_bitstring<32, false, true> >();
      break;
    case types::contextat_source:
      c.destroy<contextat_source_s>();
      break;
    default:
      break;
  }
}
void sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mob_info:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::ue_history_info_from_the_ue:
      c.init<unbounded_octstring<true> >();
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      break;
    case types::add_rrm_prio_idx:
      c.init<fixed_bitstring<32, false, true> >();
      break;
    case types::contextat_source:
      c.init<contextat_source_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
  }
}
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::ext_c(
    const sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mob_info:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::ue_history_info_from_the_ue:
      c.init(other.c.get<unbounded_octstring<true> >());
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      c.init(other.c.get<im_svoice_ep_sfallbackfrom5_g_e>());
      break;
    case types::add_rrm_prio_idx:
      c.init(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::contextat_source:
      c.init(other.c.get<contextat_source_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
  }
}
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c&
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::operator=(
    const sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mob_info:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::ue_history_info_from_the_ue:
      c.set(other.c.get<unbounded_octstring<true> >());
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      c.set(other.c.get<im_svoice_ep_sfallbackfrom5_g_e>());
      break;
    case types::add_rrm_prio_idx:
      c.set(other.c.get<fixed_bitstring<32, false, true> >());
      break;
    case types::contextat_source:
      c.set(other.c.get<contextat_source_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
  }

  return *this;
}
fixed_bitstring<32, false, true>& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::mob_info()
{
  assert_choice_type(types::mob_info, type_, "Extension");
  return c.get<fixed_bitstring<32, false, true> >();
}
unbounded_octstring<true>& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue()
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<unbounded_octstring<true> >();
}
im_svoice_ep_sfallbackfrom5_g_e&
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::im_svoice_ep_sfallbackfrom5_g()
{
  assert_choice_type(types::im_svoice_ep_sfallbackfrom5_g, type_, "Extension");
  return c.get<im_svoice_ep_sfallbackfrom5_g_e>();
}
fixed_bitstring<32, false, true>& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::add_rrm_prio_idx()
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Extension");
  return c.get<fixed_bitstring<32, false, true> >();
}
contextat_source_s& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::contextat_source()
{
  assert_choice_type(types::contextat_source, type_, "Extension");
  return c.get<contextat_source_s>();
}
const fixed_bitstring<32, false, true>& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::mob_info() const
{
  assert_choice_type(types::mob_info, type_, "Extension");
  return c.get<fixed_bitstring<32, false, true> >();
}
const unbounded_octstring<true>&
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue() const
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<unbounded_octstring<true> >();
}
const im_svoice_ep_sfallbackfrom5_g_e&
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::im_svoice_ep_sfallbackfrom5_g() const
{
  assert_choice_type(types::im_svoice_ep_sfallbackfrom5_g, type_, "Extension");
  return c.get<im_svoice_ep_sfallbackfrom5_g_e>();
}
const fixed_bitstring<32, false, true>&
sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::add_rrm_prio_idx() const
{
  assert_choice_type(types::add_rrm_prio_idx, type_, "Extension");
  return c.get<fixed_bitstring<32, false, true> >();
}
const contextat_source_s& sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::contextat_source() const
{
  assert_choice_type(types::contextat_source, type_, "Extension");
  return c.get<contextat_source_s>();
}
void sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mob_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    case types::ue_history_info_from_the_ue:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true> >().to_string());
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      j.write_str("IMSvoiceEPSfallbackfrom5G", "true");
      break;
    case types::add_rrm_prio_idx:
      j.write_str("BIT STRING", c.get<fixed_bitstring<32, false, true> >().to_string());
      break;
    case types::contextat_source:
      j.write_fieldname("ContextatSource");
      c.get<contextat_source_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mob_info:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().pack(bref));
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      HANDLE_CODE(c.get<im_svoice_ep_sfallbackfrom5_g_e>().pack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().pack(bref)));
      break;
    case types::contextat_source:
      HANDLE_CODE(c.get<contextat_source_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mob_info:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<unbounded_octstring<true> >().unpack(bref));
      break;
    case types::im_svoice_ep_sfallbackfrom5_g:
      HANDLE_CODE(c.get<im_svoice_ep_sfallbackfrom5_g_e>().unpack(bref));
      break;
    case types::add_rrm_prio_idx:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true> >().unpack(bref)));
      break;
    case types::contextat_source:
      HANDLE_CODE(c.get<contextat_source_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* options[] = {
      "BIT STRING", "OCTET STRING", "IMSvoiceEPSfallbackfrom5G", "BIT STRING", "ContextatSource"};
  return convert_enum_idx(options, 5, value, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::types");
}
uint8_t sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == im_svoice_ep_sfallbackfrom5_g) {
    return 5;
  }
  invalid_enum_number(value, "sourceenb_to_targetenb_transparent_container_ext_ies_o::ext_c::types");
  return 0;
}

template struct asn1::s1ap::protocol_ext_field_s<sourceenb_to_targetenb_transparent_container_ext_ies_o>;

sourceenb_to_targetenb_transparent_container_ext_ies_container::
    sourceenb_to_targetenb_transparent_container_ext_ies_container() :
  mob_info(175, crit_e::ignore),
  ue_history_info_from_the_ue(194, crit_e::ignore),
  im_svoice_ep_sfallbackfrom5_g(296, crit_e::ignore),
  add_rrm_prio_idx(299, crit_e::ignore),
  contextat_source(300, crit_e::ignore)
{}
SRSASN_CODE sourceenb_to_targetenb_transparent_container_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mob_info_present ? 1 : 0;
  nof_ies += ue_history_info_from_the_ue_present ? 1 : 0;
  nof_ies += im_svoice_ep_sfallbackfrom5_g_present ? 1 : 0;
  nof_ies += add_rrm_prio_idx_present ? 1 : 0;
  nof_ies += contextat_source_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (mob_info_present) {
    HANDLE_CODE(mob_info.pack(bref));
  }
  if (ue_history_info_from_the_ue_present) {
    HANDLE_CODE(ue_history_info_from_the_ue.pack(bref));
  }
  if (im_svoice_ep_sfallbackfrom5_g_present) {
    HANDLE_CODE(im_svoice_ep_sfallbackfrom5_g.pack(bref));
  }
  if (add_rrm_prio_idx_present) {
    HANDLE_CODE(add_rrm_prio_idx.pack(bref));
  }
  if (contextat_source_present) {
    HANDLE_CODE(contextat_source.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sourceenb_to_targetenb_transparent_container_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    protocol_ext_field_s<sourceenb_to_targetenb_transparent_container_ext_ies_o> c;
    HANDLE_CODE(c.unpack(bref));
    switch (c.id) {
      case 175:
        mob_info_present = true;
        mob_info.id      = c.id;
        mob_info.crit    = c.crit;
        mob_info.ext     = c.ext_value.mob_info();
        break;
      case 194:
        ue_history_info_from_the_ue_present = true;
        ue_history_info_from_the_ue.id      = c.id;
        ue_history_info_from_the_ue.crit    = c.crit;
        ue_history_info_from_the_ue.ext     = c.ext_value.ue_history_info_from_the_ue();
        break;
      case 296:
        im_svoice_ep_sfallbackfrom5_g_present = true;
        im_svoice_ep_sfallbackfrom5_g.id      = c.id;
        im_svoice_ep_sfallbackfrom5_g.crit    = c.crit;
        im_svoice_ep_sfallbackfrom5_g.ext     = c.ext_value.im_svoice_ep_sfallbackfrom5_g();
        break;
      case 299:
        add_rrm_prio_idx_present = true;
        add_rrm_prio_idx.id      = c.id;
        add_rrm_prio_idx.crit    = c.crit;
        add_rrm_prio_idx.ext     = c.ext_value.add_rrm_prio_idx();
        break;
      case 300:
        contextat_source_present = true;
        contextat_source.id      = c.id;
        contextat_source.crit    = c.crit;
        contextat_source.ext     = c.ext_value.contextat_source();
        break;
      default:
        asn1::log_error("Unpacked object ID=%d is not recognized\n", c.id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void sourceenb_to_targetenb_transparent_container_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mob_info_present) {
    j.write_fieldname("");
    mob_info.to_json(j);
  }
  if (ue_history_info_from_the_ue_present) {
    j.write_fieldname("");
    ue_history_info_from_the_ue.to_json(j);
  }
  if (im_svoice_ep_sfallbackfrom5_g_present) {
    j.write_fieldname("");
    im_svoice_ep_sfallbackfrom5_g.to_json(j);
  }
  if (add_rrm_prio_idx_present) {
    j.write_fieldname("");
    add_rrm_prio_idx.to_json(j);
  }
  if (contextat_source_present) {
    j.write_fieldname("");
    contextat_source.to_json(j);
  }
  j.end_obj();
}

// SourceeNB-ToTargeteNB-TransparentContainer ::= SEQUENCE
SRSASN_CODE sourceenb_to_targetenb_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(erab_info_list_present, 1));
  HANDLE_CODE(bref.pack(subscriber_profile_idfor_rfp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (erab_info_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, erab_info_list, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.pack(bref));
  if (subscriber_profile_idfor_rfp_present) {
    HANDLE_CODE(pack_integer(bref, subscriber_profile_idfor_rfp, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, ue_history_info, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sourceenb_to_targetenb_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(erab_info_list_present, 1));
  HANDLE_CODE(bref.unpack(subscriber_profile_idfor_rfp_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (erab_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(erab_info_list, bref, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.unpack(bref));
  if (subscriber_profile_idfor_rfp_present) {
    HANDLE_CODE(unpack_integer(subscriber_profile_idfor_rfp, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(ue_history_info, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sourceenb_to_targetenb_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRC-Container", rrc_container.to_string());
  if (erab_info_list_present) {
    j.start_array("e-RABInformationList");
    for (const auto& e1 : erab_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_fieldname("targetCell-ID");
  target_cell_id.to_json(j);
  if (subscriber_profile_idfor_rfp_present) {
    j.write_int("subscriberProfileIDforRFP", subscriber_profile_idfor_rfp);
  }
  j.start_array("uE-HistoryInformation");
  for (const auto& e1 : ue_history_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargeteNB-ToSourceeNB-TransparentContainer ::= SEQUENCE
SRSASN_CODE targetenb_to_sourceenb_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE targetenb_to_sourceenb_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void targetenb_to_sourceenb_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRC-Container", rrc_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}
